<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>堆入门-__malloc_hook和__free_hook劫持原理 | Zechariahの博客</title><meta name="author" content="Zechariah"><meta name="copyright" content="Zechariah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="malloc_hook和free_hook劫持原理_freehook-CSDN博客 打堆的一个关键的方法就是劫持堆相关函数中的 hook 函数。即在堆中的三大 hook 函数，malloc_hook、realloc_hook、free_hook Hook介绍 hook 的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。 hook 翻译过来是钩子。假设 a 函数中有这样一个执行过程：判">
<meta property="og:type" content="article">
<meta property="og:title" content="堆入门-__malloc_hook和__free_hook劫持原理">
<meta property="og:url" content="https://zechariah-0703.github.io/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Zechariahの博客">
<meta property="og:description" content="malloc_hook和free_hook劫持原理_freehook-CSDN博客 打堆的一个关键的方法就是劫持堆相关函数中的 hook 函数。即在堆中的三大 hook 函数，malloc_hook、realloc_hook、free_hook Hook介绍 hook 的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。 hook 翻译过来是钩子。假设 a 函数中有这样一个执行过程：判">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zechariah-0703.github.io/img/fengmian.png">
<meta property="article:published_time" content="2025-03-10T13:44:38.000Z">
<meta property="article:modified_time" content="2025-03-27T11:52:12.301Z">
<meta property="article:author" content="Zechariah">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zechariah-0703.github.io/img/fengmian.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zechariah-0703.github.io/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '堆入门-__malloc_hook和__free_hook劫持原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-27 19:52:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/fengmian.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Zechariahの博客"><span class="site-name">Zechariahの博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆入门-__malloc_hook和__free_hook劫持原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-10T13:44:38.000Z" title="发表于 2025-03-10 21:44:38">2025-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-27T11:52:12.301Z" title="更新于 2025-03-27 19:52:12">2025-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="堆入门-__malloc_hook和__free_hook劫持原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_69107736/article/details/129674212"><strong>malloc_hook和</strong>free_hook劫持原理_freehook-CSDN博客</a></p>
<p>打堆的一个关键的方法就是劫持堆相关函数中的 <code>hook</code> 函数。即在堆中的三大 <code>hook</code> 函数，<code>malloc_hook</code>、<code>realloc_hook</code>、<code>free_hook</code></p>
<h2 id="Hook介绍"><a href="#Hook介绍" class="headerlink" title="Hook介绍"></a>Hook介绍</h2><ul>
<li><code>hook</code> 的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。<ul>
<li><code>hook</code> 翻译过来是<code>钩子</code>。假设 <code>a</code> 函数中有这样一个执行过程：<code>判断b函数指针是否为空，如果不为空就先b函数指针所指向的函数</code>。这样当我们使用 <code>b</code> 钩子的时候，我们在执行 <code>a</code> 函数，执行流就会被 <code>b</code> 钩子给钩过来，这样就达到了执行 <code>b</code> 函数指针所指向的函数地址。</li>
</ul>
</li>
<li>为了方便调试程序，在 <code>glibc</code> 中有四个比较重要的函数指针，分别是 <code>malloc_hook</code>、<code>free_hook</code>、<code>realloc_hook</code>、<code>exit_hook</code>。</li>
<li>我们可以通过一些堆漏洞或者其他漏洞就可以将原本指向 <code>NULL</code> 的这些函数指针，修改为 <code>one_gadget</code>，这样我们在满足一定的条件后就可以 <code>getshell</code>，这样就是 pwn 中的劫持 <code>hook</code> 函数最常见的用法。</li>
</ul>
<h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h2><h3 id="malloc函数流程"><a href="#malloc函数流程" class="headerlink" title="malloc函数流程"></a>malloc函数流程</h3><p><img src="/img/loading.gif" data-original="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/malloc函数流程.png" alt="malloc函数流程"></p>
<h4 id="glibc2-23malloc函数源码"><a href="#glibc2-23malloc函数源码" class="headerlink" title="glibc2.23malloc函数源码"></a>glibc2.23malloc函数源码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;_int_malloc
&#x2F;*
   ------------------------------ malloc ------------------------------
 *&#x2F;

static void *
_int_malloc (mstate av, size_t bytes)
&#123;
  INTERNAL_SIZE_T nb;               &#x2F;* normalized request size *&#x2F;
  unsigned int idx;                 &#x2F;* associated bin index *&#x2F;
  mbinptr bin;                      &#x2F;* associated bin *&#x2F;

  mchunkptr victim;                 &#x2F;* inspected&#x2F;selected chunk *&#x2F;
  INTERNAL_SIZE_T size;             &#x2F;* its size *&#x2F;
  int victim_index;                 &#x2F;* its bin index *&#x2F;

  mchunkptr remainder;              &#x2F;* remainder from a split *&#x2F;
  unsigned long remainder_size;     &#x2F;* its size *&#x2F;

  unsigned int block;               &#x2F;* bit map traverser *&#x2F;
  unsigned int bit;                 &#x2F;* bit map traverser *&#x2F;
  unsigned int map;                 &#x2F;* current word of binmap *&#x2F;

  mchunkptr fwd;                    &#x2F;* misc temp for linking *&#x2F;
  mchunkptr bck;                    &#x2F;* misc temp for linking *&#x2F;

  const char *errstr &#x3D; NULL;

  &#x2F;*
     Convert request size to internal form by adding SIZE_SZ bytes
     overhead plus possibly more to obtain necessary alignment and&#x2F;or
     to obtain a size of at least MINSIZE, the smallest allocatable
     size. Also, checked_request2size traps (returning 0) request sizes
     that are so large that they wrap around zero when padded and
     aligned.
   *&#x2F;

  checked_request2size (bytes, nb);

  &#x2F;* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
     mmap.  *&#x2F;
  if (__glibc_unlikely (av &#x3D;&#x3D; NULL))
    &#123;
      void *p &#x3D; sysmalloc (nb, av);
      if (p !&#x3D; NULL)
	alloc_perturb (p, bytes);
      return p;
    &#125;

  &#x2F;*
     If the size qualifies as a fastbin, first check corresponding bin.
     This code is safe to execute even if av is not yet initialized, so we
     can try it without checking, which saves some time on this fast path.
   *&#x2F;

  if ((unsigned long) (nb) &lt;&#x3D; (unsigned long) (get_max_fast ()))
    &#123;
      idx &#x3D; fastbin_index (nb);
      mfastbinptr *fb &#x3D; &amp;fastbin (av, idx);
      mchunkptr pp &#x3D; *fb;
      do
        &#123;
          victim &#x3D; pp;
          if (victim &#x3D;&#x3D; NULL)
            break;
        &#125;
      while ((pp &#x3D; catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))
             !&#x3D; victim);
      if (victim !&#x3D; 0)
        &#123;
          if (__builtin_expect (fastbin_index (chunksize (victim)) !&#x3D; idx, 0))
            &#123;
              errstr &#x3D; &quot;malloc(): memory corruption (fast)&quot;;
            errout:
              malloc_printerr (check_action, errstr, chunk2mem (victim), av);
              return NULL;
            &#125;
          check_remalloced_chunk (av, victim, nb);
          void *p &#x3D; chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        &#125;
    &#125;

  &#x2F;*
     If a small request, check regular bin.  Since these &quot;smallbins&quot;
     hold one size each, no searching within bins is necessary.
     (For a large request, we need to wait until unsorted chunks are
     processed to find best fit. But for small ones, fits are exact
     anyway, so we can check now, which is faster.)
   *&#x2F;

  if (in_smallbin_range (nb))
    &#123;
      idx &#x3D; smallbin_index (nb);
      bin &#x3D; bin_at (av, idx);

      if ((victim &#x3D; last (bin)) !&#x3D; bin)
        &#123;
          if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;
            malloc_consolidate (av);
          else
            &#123;
              bck &#x3D; victim-&gt;bk;
	if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))
                &#123;
                  errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;
                  goto errout;
                &#125;
              set_inuse_bit_at_offset (victim, nb);
              bin-&gt;bk &#x3D; bck;
              bck-&gt;fd &#x3D; bin;

              if (av !&#x3D; &amp;main_arena)
                victim-&gt;size |&#x3D; NON_MAIN_ARENA;
              check_malloced_chunk (av, victim, nb);
              void *p &#x3D; chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            &#125;
        &#125;
    &#125;

  &#x2F;*
     If this is a large request, consolidate fastbins before continuing.
     While it might look excessive to kill all fastbins before
     even seeing if there is space available, this avoids
     fragmentation problems normally associated with fastbins.
     Also, in practice, programs tend to have runs of either small or
     large requests, but less often mixtures, so consolidation is not
     invoked all that often in most programs. And the programs that
     it is called frequently in otherwise tend to fragment.
   *&#x2F;

  else
    &#123;
      idx &#x3D; largebin_index (nb);
      if (have_fastchunks (av))
        malloc_consolidate (av);
    &#125;

  &#x2F;*
     Process recently freed or remaindered chunks, taking one only if
     it is exact fit, or, if this a small request, the chunk is remainder from
     the most recent non-exact fit.  Place other traversed chunks in
     bins.  Note that this step is the only place in any routine where
     chunks are placed in bins.

     The outer loop here is needed because we might not realize until
     near the end of malloc that we should have consolidated, so must
     do so and retry. This happens at most once, and only when we would
     otherwise need to expand memory to service a &quot;small&quot; request.
   *&#x2F;

  for (;; )
    &#123;
      int iters &#x3D; 0;
      while ((victim &#x3D; unsorted_chunks (av)-&gt;bk) !&#x3D; unsorted_chunks (av))
        &#123;
          bck &#x3D; victim-&gt;bk;
          if (__builtin_expect (victim-&gt;size &lt;&#x3D; 2 * SIZE_SZ, 0)
              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))
            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,
                             chunk2mem (victim), av);
          size &#x3D; chunksize (victim);

          &#x2F;*
             If a small request, try to use last remainder if it is the
             only chunk in unsorted bin.  This helps promote locality for
             runs of consecutive small requests. This is the only
             exception to best-fit, and applies only when there is
             no exact fit for a small chunk.
           *&#x2F;

          if (in_smallbin_range (nb) &amp;&amp;
              bck &#x3D;&#x3D; unsorted_chunks (av) &amp;&amp;
              victim &#x3D;&#x3D; av-&gt;last_remainder &amp;&amp;
              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))
            &#123;
              &#x2F;* split and reattach remainder *&#x2F;
              remainder_size &#x3D; size - nb;
              remainder &#x3D; chunk_at_offset (victim, nb);
              unsorted_chunks (av)-&gt;bk &#x3D; unsorted_chunks (av)-&gt;fd &#x3D; remainder;
              av-&gt;last_remainder &#x3D; remainder;
              remainder-&gt;bk &#x3D; remainder-&gt;fd &#x3D; unsorted_chunks (av);
              if (!in_smallbin_range (remainder_size))
                &#123;
                  remainder-&gt;fd_nextsize &#x3D; NULL;
                  remainder-&gt;bk_nextsize &#x3D; NULL;
                &#125;

              set_head (victim, nb | PREV_INUSE |
                        (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));
              set_head (remainder, remainder_size | PREV_INUSE);
              set_foot (remainder, remainder_size);

              check_malloced_chunk (av, victim, nb);
              void *p &#x3D; chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            &#125;

          &#x2F;* remove from unsorted list *&#x2F;
          unsorted_chunks (av)-&gt;bk &#x3D; bck;
          bck-&gt;fd &#x3D; unsorted_chunks (av);

          &#x2F;* Take now instead of binning if exact fit *&#x2F;

          if (size &#x3D;&#x3D; nb)
            &#123;
              set_inuse_bit_at_offset (victim, size);
              if (av !&#x3D; &amp;main_arena)
                victim-&gt;size |&#x3D; NON_MAIN_ARENA;
              check_malloced_chunk (av, victim, nb);
              void *p &#x3D; chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            &#125;

          &#x2F;* place chunk in bin *&#x2F;

          if (in_smallbin_range (size))
            &#123;
              victim_index &#x3D; smallbin_index (size);
              bck &#x3D; bin_at (av, victim_index);
              fwd &#x3D; bck-&gt;fd;
            &#125;
          else
            &#123;
              victim_index &#x3D; largebin_index (size);
              bck &#x3D; bin_at (av, victim_index);
              fwd &#x3D; bck-&gt;fd;

              &#x2F;* maintain large bins in sorted order *&#x2F;
              if (fwd !&#x3D; bck)
                &#123;
                  &#x2F;* Or with inuse bit to speed comparisons *&#x2F;
                  size |&#x3D; PREV_INUSE;
                  &#x2F;* if smaller than smallest, bypass loop below *&#x2F;
                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) &#x3D;&#x3D; 0);
                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))
                    &#123;
                      fwd &#x3D; bck;
                      bck &#x3D; bck-&gt;bk;

                      victim-&gt;fd_nextsize &#x3D; fwd-&gt;fd;
                      victim-&gt;bk_nextsize &#x3D; fwd-&gt;fd-&gt;bk_nextsize;
                      fwd-&gt;fd-&gt;bk_nextsize &#x3D; victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;
                    &#125;
                  else
                    &#123;
                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) &#x3D;&#x3D; 0);
                      while ((unsigned long) size &lt; fwd-&gt;size)
                        &#123;
                          fwd &#x3D; fwd-&gt;fd_nextsize;
                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) &#x3D;&#x3D; 0);
                        &#125;

                      if ((unsigned long) size &#x3D;&#x3D; (unsigned long) fwd-&gt;size)
                        &#x2F;* Always insert in the second position.  *&#x2F;
                        fwd &#x3D; fwd-&gt;fd;
                      else
                        &#123;
                          victim-&gt;fd_nextsize &#x3D; fwd;
                          victim-&gt;bk_nextsize &#x3D; fwd-&gt;bk_nextsize;
                          fwd-&gt;bk_nextsize &#x3D; victim;
                          victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;
                        &#125;
                      bck &#x3D; fwd-&gt;bk;
                    &#125;
                &#125;
              else
                victim-&gt;fd_nextsize &#x3D; victim-&gt;bk_nextsize &#x3D; victim;
            &#125;

          mark_bin (av, victim_index);
          victim-&gt;bk &#x3D; bck;
          victim-&gt;fd &#x3D; fwd;
          fwd-&gt;bk &#x3D; victim;
          bck-&gt;fd &#x3D; victim;

#define MAX_ITERS       10000
          if (++iters &gt;&#x3D; MAX_ITERS)
            break;
        &#125;

      &#x2F;*
         If a large request, scan through the chunks of current bin in
         sorted order to find smallest that fits.  Use the skip list for this.
       *&#x2F;

      if (!in_smallbin_range (nb))
        &#123;
          bin &#x3D; bin_at (av, idx);

          &#x2F;* skip scan if empty or largest chunk is too small *&#x2F;
          if ((victim &#x3D; first (bin)) !&#x3D; bin &amp;&amp;
              (unsigned long) (victim-&gt;size) &gt;&#x3D; (unsigned long) (nb))
            &#123;
              victim &#x3D; victim-&gt;bk_nextsize;
              while (((unsigned long) (size &#x3D; chunksize (victim)) &lt;
                      (unsigned long) (nb)))
                victim &#x3D; victim-&gt;bk_nextsize;

              &#x2F;* Avoid removing the first entry for a size so that the skip
                 list does not have to be rerouted.  *&#x2F;
              if (victim !&#x3D; last (bin) &amp;&amp; victim-&gt;size &#x3D;&#x3D; victim-&gt;fd-&gt;size)
                victim &#x3D; victim-&gt;fd;

              remainder_size &#x3D; size - nb;
              unlink (av, victim, bck, fwd);

              &#x2F;* Exhaust *&#x2F;
              if (remainder_size &lt; MINSIZE)
                &#123;
                  set_inuse_bit_at_offset (victim, size);
                  if (av !&#x3D; &amp;main_arena)
                    victim-&gt;size |&#x3D; NON_MAIN_ARENA;
                &#125;
              &#x2F;* Split *&#x2F;
              else
                &#123;
                  remainder &#x3D; chunk_at_offset (victim, nb);
                  &#x2F;* We cannot assume the unsorted list is empty and therefore
                     have to perform a complete insert here.  *&#x2F;
                  bck &#x3D; unsorted_chunks (av);
                  fwd &#x3D; bck-&gt;fd;
	  if (__glibc_unlikely (fwd-&gt;bk !&#x3D; bck))
                    &#123;
                      errstr &#x3D; &quot;malloc(): corrupted unsorted chunks&quot;;
                      goto errout;
                    &#125;
                  remainder-&gt;bk &#x3D; bck;
                  remainder-&gt;fd &#x3D; fwd;
                  bck-&gt;fd &#x3D; remainder;
                  fwd-&gt;bk &#x3D; remainder;
                  if (!in_smallbin_range (remainder_size))
                    &#123;
                      remainder-&gt;fd_nextsize &#x3D; NULL;
                      remainder-&gt;bk_nextsize &#x3D; NULL;
                    &#125;
                  set_head (victim, nb | PREV_INUSE |
                            (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));
                  set_head (remainder, remainder_size | PREV_INUSE);
                  set_foot (remainder, remainder_size);
                &#125;
              check_malloced_chunk (av, victim, nb);
              void *p &#x3D; chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            &#125;
        &#125;

      &#x2F;*
         Search for a chunk by scanning bins, starting with next largest
         bin. This search is strictly by best-fit; i.e., the smallest
         (with ties going to approximately the least recently used) chunk
         that fits is selected.

         The bitmap avoids needing to check that most blocks are nonempty.
         The particular case of skipping all bins during warm-up phases
         when no chunks have been returned yet is faster than it might look.
       *&#x2F;

      ++idx;
      bin &#x3D; bin_at (av, idx);
      block &#x3D; idx2block (idx);
      map &#x3D; av-&gt;binmap[block];
      bit &#x3D; idx2bit (idx);

      for (;; )
        &#123;
          &#x2F;* Skip rest of block if there are no more set bits in this block.  *&#x2F;
          if (bit &gt; map || bit &#x3D;&#x3D; 0)
            &#123;
              do
                &#123;
                  if (++block &gt;&#x3D; BINMAPSIZE) &#x2F;* out of bins *&#x2F;
                    goto use_top;
                &#125;
              while ((map &#x3D; av-&gt;binmap[block]) &#x3D;&#x3D; 0);

              bin &#x3D; bin_at (av, (block &lt;&lt; BINMAPSHIFT));
              bit &#x3D; 1;
            &#125;

          &#x2F;* Advance to bin with set bit. There must be one. *&#x2F;
          while ((bit &amp; map) &#x3D;&#x3D; 0)
            &#123;
              bin &#x3D; next_bin (bin);
              bit &lt;&lt;&#x3D; 1;
              assert (bit !&#x3D; 0);
            &#125;

          &#x2F;* Inspect the bin. It is likely to be non-empty *&#x2F;
          victim &#x3D; last (bin);

          &#x2F;*  If a false alarm (empty bin), clear the bit. *&#x2F;
          if (victim &#x3D;&#x3D; bin)
            &#123;
              av-&gt;binmap[block] &#x3D; map &amp;&#x3D; ~bit; &#x2F;* Write through *&#x2F;
              bin &#x3D; next_bin (bin);
              bit &lt;&lt;&#x3D; 1;
            &#125;

          else
            &#123;
              size &#x3D; chunksize (victim);

              &#x2F;*  We know the first chunk in this bin is big enough to use. *&#x2F;
              assert ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb));

              remainder_size &#x3D; size - nb;

              &#x2F;* unlink *&#x2F;
              unlink (av, victim, bck, fwd);

              &#x2F;* Exhaust *&#x2F;
              if (remainder_size &lt; MINSIZE)
                &#123;
                  set_inuse_bit_at_offset (victim, size);
                  if (av !&#x3D; &amp;main_arena)
                    victim-&gt;size |&#x3D; NON_MAIN_ARENA;
                &#125;

              &#x2F;* Split *&#x2F;
              else
                &#123;
                  remainder &#x3D; chunk_at_offset (victim, nb);

                  &#x2F;* We cannot assume the unsorted list is empty and therefore
                     have to perform a complete insert here.  *&#x2F;
                  bck &#x3D; unsorted_chunks (av);
                  fwd &#x3D; bck-&gt;fd;
	  if (__glibc_unlikely (fwd-&gt;bk !&#x3D; bck))
                    &#123;
                      errstr &#x3D; &quot;malloc(): corrupted unsorted chunks 2&quot;;
                      goto errout;
                    &#125;
                  remainder-&gt;bk &#x3D; bck;
                  remainder-&gt;fd &#x3D; fwd;
                  bck-&gt;fd &#x3D; remainder;
                  fwd-&gt;bk &#x3D; remainder;

                  &#x2F;* advertise as last remainder *&#x2F;
                  if (in_smallbin_range (nb))
                    av-&gt;last_remainder &#x3D; remainder;
                  if (!in_smallbin_range (remainder_size))
                    &#123;
                      remainder-&gt;fd_nextsize &#x3D; NULL;
                      remainder-&gt;bk_nextsize &#x3D; NULL;
                    &#125;
                  set_head (victim, nb | PREV_INUSE |
                            (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));
                  set_head (remainder, remainder_size | PREV_INUSE);
                  set_foot (remainder, remainder_size);
                &#125;
              check_malloced_chunk (av, victim, nb);
              void *p &#x3D; chunk2mem (victim);
              alloc_perturb (p, bytes);
              return p;
            &#125;
        &#125;

    use_top:
      &#x2F;*
         If large enough, split off the chunk bordering the end of memory
         (held in av-&gt;top). Note that this is in accord with the best-fit
         search rule.  In effect, av-&gt;top is treated as larger (and thus
         less well fitting) than any other available chunk since it can
         be extended to be as large as necessary (up to system
         limitations).

         We require that av-&gt;top always exists (i.e., has size &gt;&#x3D;
         MINSIZE) after initialization, so if it would otherwise be
         exhausted by current request, it is replenished. (The main
         reason for ensuring it exists is that we may need MINSIZE space
         to put in fenceposts in sysmalloc.)
       *&#x2F;

      victim &#x3D; av-&gt;top;
      size &#x3D; chunksize (victim);

      if ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb + MINSIZE))
        &#123;
          remainder_size &#x3D; size - nb;
          remainder &#x3D; chunk_at_offset (victim, nb);
          av-&gt;top &#x3D; remainder;
          set_head (victim, nb | PREV_INUSE |
                    (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));
          set_head (remainder, remainder_size | PREV_INUSE);

          check_malloced_chunk (av, victim, nb);
          void *p &#x3D; chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
        &#125;

      &#x2F;* When we are using atomic ops to free fast chunks we can get
         here for all block sizes.  *&#x2F;
      else if (have_fastchunks (av))
        &#123;
          malloc_consolidate (av);
          &#x2F;* restore original bin index *&#x2F;
          if (in_smallbin_range (nb))
            idx &#x3D; smallbin_index (nb);
          else
            idx &#x3D; largebin_index (nb);
        &#125;

      &#x2F;*
         Otherwise, relay to handle system-dependent cases
       *&#x2F;
      else
        &#123;
          void *p &#x3D; sysmalloc (nb, av);
          if (p !&#x3D; NULL)
            alloc_perturb (p, bytes);
          return p;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;__libc_malloc
&#x2F;*------------------------ Public wrappers. --------------------------------*&#x2F;

void *
__libc_malloc (size_t bytes)
&#123;
  mstate ar_ptr;
  void *victim;

  void *(*hook) (size_t, const void *)
    &#x3D; atomic_forced_read (__malloc_hook);
  if (__builtin_expect (hook !&#x3D; NULL, 0))
    return (*hook)(bytes, RETURN_ADDRESS (0));

  arena_get (ar_ptr, bytes);

  victim &#x3D; _int_malloc (ar_ptr, bytes);
  &#x2F;* Retry with another arena only if we were able to find a usable arena
     before.  *&#x2F;
  if (!victim &amp;&amp; ar_ptr !&#x3D; NULL)
    &#123;
      LIBC_PROBE (memory_malloc_retry, 1, bytes);
      ar_ptr &#x3D; arena_get_retry (ar_ptr, bytes);
      victim &#x3D; _int_malloc (ar_ptr, bytes);
    &#125;

  if (ar_ptr !&#x3D; NULL)
    (void) mutex_unlock (&amp;ar_ptr-&gt;mutex);

  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
          ar_ptr &#x3D;&#x3D; arena_for_chunk (mem2chunk (victim)));
  return victim;
&#125;
libc_hidden_def (__libc_malloc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;malloc 相关宏定义
&#x2F;*申请的堆块对齐的宏定义*&#x2F;
#ifndef MALLOC_ALIGNMENT
# if !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)
&#x2F;* This is the correct definition when there is no past ABI to constrain it.

   Among configurations with a past ABI constraint, it differs from
   2*SIZE_SZ only on powerpc32.  For the time being, changing this is
   causing more compatibility problems due to malloc_get_state and
   malloc_set_state than will returning blocks not adequately aligned for
   long double objects under -mlong-double-128.  *&#x2F;

#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \
                                  ? __alignof__ (long double) : 2 *SIZE_SZ)
# else
#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ)
# endif
#endif

&#x2F;* The corresponding bit mask value *&#x2F;
#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="malloc-hook函数解析"><a href="#malloc-hook函数解析" class="headerlink" title="malloc_hook函数解析"></a>malloc_hook函数解析</h3><p>malloc_hook是malloc的钩子函数，在执行malloc时，会先检测__malloc_hook的值，如果malloc_hook的值存在，则执行该地址（值里边表现为十六进制，可以成为地址），也就是说，如果我们成功劫持malloc_hook以后并修改它的值为one_gadget，我们就能getshell<br>并且在加入tcache之后，不会对大小进行检测，使我们更好利用它</p>
<h3 id="利用范围"><a href="#利用范围" class="headerlink" title="利用范围"></a>利用范围</h3><p><strong>版本:Ubuntu18（加入了tcache，无需伪造size）—Ubuntu20.04</strong><br>因为<strong>22.04删去了几乎所有的钩子函数</strong>，使得劫持hook成为了不可能，所以它的试用范围仅限于20.04之前，在未来应该会销声匿迹</p>
<p>它在学堆之后估计就是我们的老朋友的，我们<strong>常常能在堆题里看见并利用它</strong>，与<strong>free_hook和relloc_hook</strong>简直是三兄弟</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><strong>修改chunk-&gt;fd指向malloc_hook</strong>，然后把malloc_hook申请出来<strong>成为fake_chunk</strong>，再<strong>修改fake_chunk的值为one_gadget</strong>。修改完毕后记得<strong>校准one_gadget</strong>，有可能无法生效，毕竟可能不满足one_gadget的生效条件</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io">Zechariah</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/">https://zechariah-0703.github.io/2025/03/10/堆入门-malloc-hook和-free-hook劫持原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zechariah-0703.github.io" target="_blank">Zechariahの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a></div><div class="post_share"><div class="social-share" data-image="/img/fengmian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/11/unlink/" title="unlink"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">unlink</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/10/UAF-use-after-free/" title="UAF(use_after_free)"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UAF(use_after_free)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/10/UAF-use-after-free/" title="UAF(use_after_free)"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="title">UAF(use_after_free)</div></div></a></div><div><a href="/2025/03/11/unlink/" title="unlink"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="title">unlink</div></div></a></div><div><a href="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/" title="堆相关整理"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="title">堆相关整理</div></div></a></div><div><a href="/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/" title="AWD学习"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="title">AWD学习</div></div></a></div><div><a href="/2025/02/14/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E6%95%B4%E7%90%86/" title="C语言函数原型整理"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="title">C语言函数原型整理</div></div></a></div><div><a href="/2025/02/22/Art-of-shellcode/" title="Art_of_shellcode"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-22</div><div class="title">Art_of_shellcode</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zechariah</div><div class="author-info__description">不会密码的逆向手不是好PWN手</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zechariah-0703"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Hook介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-hook"><span class="toc-number">2.</span> <span class="toc-text">malloc_hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">malloc函数流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#glibc2-23malloc%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">glibc2.23malloc函数源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-hook%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">malloc_hook函数解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">2.3.</span> <span class="toc-text">利用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">2.4.</span> <span class="toc-text">利用思路</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/27/%E5%85%B3%E4%BA%8E%E6%88%91/" title="关于我"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于我"/></a><div class="content"><a class="title" href="/2025/03/27/%E5%85%B3%E4%BA%8E%E6%88%91/" title="关于我">关于我</a><time datetime="2025-03-27T11:02:23.000Z" title="发表于 2025-03-27 19:02:23">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="PWN刷题笔记（长期更新）"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PWN刷题笔记（长期更新）"/></a><div class="content"><a class="title" href="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="PWN刷题笔记（长期更新）">PWN刷题笔记（长期更新）</a><time datetime="2025-03-25T13:39:37.000Z" title="发表于 2025-03-25 21:39:37">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/" title="Web-PWN知识"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web-PWN知识"/></a><div class="content"><a class="title" href="/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/" title="Web-PWN知识">Web-PWN知识</a><time datetime="2025-03-11T13:48:48.000Z" title="发表于 2025-03-11 21:48:48">2025-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/11/unlink/" title="unlink"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unlink"/></a><div class="content"><a class="title" href="/2025/03/11/unlink/" title="unlink">unlink</a><time datetime="2025-03-10T16:25:24.000Z" title="发表于 2025-03-11 00:25:24">2025-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/" title="堆入门-__malloc_hook和__free_hook劫持原理"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="堆入门-__malloc_hook和__free_hook劫持原理"/></a><div class="content"><a class="title" href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/" title="堆入门-__malloc_hook和__free_hook劫持原理">堆入门-__malloc_hook和__free_hook劫持原理</a><time datetime="2025-03-10T13:44:38.000Z" title="发表于 2025-03-10 21:44:38">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Zechariah</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>