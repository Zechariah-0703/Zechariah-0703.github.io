<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>堆相关整理 | Zechariahの博客</title><meta name="author" content="Zechariah"><meta name="copyright" content="Zechariah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="What is 堆？明确一下堆的概念，堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。  windows 和 linux 下的堆分配、管理方式都不同，这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识先看看堆在">
<meta property="og:type" content="article">
<meta property="og:title" content="堆相关整理">
<meta property="og:url" content="https://zechariah-0703.github.io/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Zechariahの博客">
<meta property="og:description" content="What is 堆？明确一下堆的概念，堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。  windows 和 linux 下的堆分配、管理方式都不同，这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识先看看堆在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zechariah-0703.github.io/img/fengmian.png">
<meta property="article:published_time" content="2025-02-26T13:43:42.000Z">
<meta property="article:modified_time" content="2025-04-24T07:54:33.470Z">
<meta property="article:author" content="Zechariah">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zechariah-0703.github.io/img/fengmian.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "堆相关整理",
  "url": "https://zechariah-0703.github.io/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/",
  "image": "https://zechariah-0703.github.io/img/fengmian.png",
  "datePublished": "2025-02-26T13:43:42.000Z",
  "dateModified": "2025-04-24T07:54:33.470Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zechariah",
      "url": "https://zechariah-0703.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zechariah-0703.github.io/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '堆相关整理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/fengmian.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Zechariahの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">堆相关整理</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">堆相关整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T13:43:42.000Z" title="发表于 2025-02-26 21:43:42">2025-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-24T07:54:33.470Z" title="更新于 2025-04-24 15:54:33">2025-04-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="What-is-堆？"><a href="#What-is-堆？" class="headerlink" title="What is 堆？"></a>What is 堆？</h2><p>明确一下堆的概念，堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p>
<ul>
<li>windows 和 linux 下的堆分配、管理方式都不同，<strong>这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识</strong><br>先看看堆在虚拟内存中的位置<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225175129.png" alt="Pasted image 20250225175129"></li>
<li><strong>堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。</strong><br>实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间<blockquote>
<p>对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p>
</blockquote>
</li>
</ul>
<p>下面的分析都是以 <strong>glibc 库下的 ptmalloc2 堆管理器</strong>来讲解的。</p>
<h2 id="一、堆的基本结构"><a href="#一、堆的基本结构" class="headerlink" title="一、堆的基本结构"></a>一、堆的基本结构</h2><p>先简单的画一个图吧：<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225175239.png" alt="Pasted image 20250225175239"></p>
<h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p><code>malloc_chunk</code>的结构</p>
<h4 id="malloc-chunk结构"><a href="#malloc-chunk结构" class="headerlink" title="malloc_chunk结构"></a>malloc_chunk结构</h4><p>每个程序分配的内存（这里指的是malloc函数）在内部被一个叫做”<strong>堆块</strong>”的所替代。<strong>一个堆块是由元数据和程序返回的内存组成的（实际上内存是malloc的返回值）</strong>。所有的这些堆块都是保存在堆上，这块内存区域在申请新的内存时会不断的扩大。同样，当一定数量的内存释放时，堆可以收缩。在glibc源码中定义的堆块如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设内存中没有堆块释放，新分配的内存区域紧随之前申请的堆块后。因此如果一个程序依次调用malloc(256),malloc(512),以及malloc(1024), 内存布局如下:<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225200003.png" alt="Pasted image 20250225200003"><br>在堆块之间的”.”是虚拟的边界，实际当中他们是彼此相邻的。你可能会问，为何我要在布局当中包含一个”顶块”元数据（top chunk）。<strong>顶级块表示堆中可利用的内存，而且是唯一的可以大小可以生长的堆块</strong>。当申请新的内存时，顶块分成两个部分：第一个部分变成所申请的堆块，第二个部分变为新的顶块（因此顶块大小可以收缩）。如果顶块不能够满足申请的内存区域大小，程序就会要求操作系统扩大顶块（让堆继续生长）。被释放的chunk被记录在链表中（可能是循环双向链表，也可能是单向链表)。具体结构如下<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225200210.png" alt="Pasted image 20250225200210"><br>一般情况下，物理相邻的两个空闲chunk会被合并为一个chunk。堆管理器会通过prev_size字段以及size字段合并两个物理相邻的空闲chunk块。</p>
<h4 id="1-pre-size字段"><a href="#1-pre-size字段" class="headerlink" title="1. pre size字段"></a>1. pre size字段</h4><blockquote>
<p>全称previous size</p>
</blockquote>
<p>  如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是<strong>空闲</strong>的话，<strong>那该字段记录的是前一个 chunk 的*</strong>大小<strong>* (</strong>包括 chunk 头<strong>)。否则，</strong>该字段可以用来存储物理相邻的前一个 chunk 的数据<strong>。这里的前一 chunk 指的是较低地址的 chunk。</strong>前面一个堆块在使用时并且pre_size为储存前面chunk的数据时，它的值始终为0**</p>
<h4 id="2-size-字段"><a href="#2-size-字段" class="headerlink" title="2. size 字段"></a>2. size 字段</h4><p><strong>用来指示当前堆块的大小的（头部加上（pre_size+size） +user data 的大小）</strong>。<br>大小必须是 2 <em> SIZE_SZ 的整数倍。如果申请的内存大小不是 2 </em> SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 <em> SIZE_SZ 的倍数。<br><strong>32 位系统中，SIZE_SZ 是 4；</strong><br><strong>64 位系统中，SIZE_SZ 是 8。</strong> 
</em>该字段的低三个比特位对 chunk 的大小没有影响<em>，它们从高到低分别表示<br>但是这个字段的最后<em>*三位</em></em>相当于三个 flag ，这三位的作用分别是：</p>
<ol>
<li><code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于<strong>主分配区（主线程）</strong>，1 表示不属于（是非主分配区/非主线程），0 表示属于。</li>
<li><code>IS_MAPPED</code>，表示当前chunk是从哪个内存区域获得的虚拟内存。为1表示该chunk是从<strong>mmap</strong>映射区域分配的，否则是从<strong>heap</strong>区域分配的</li>
<li><code>PREV_INUSE</code>，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250225180103.png" alt="Pasted image 20250225180103"><br>这里重点讲解最后一位：<strong>用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1</strong>，所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节。<blockquote>
<p>所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free）</p>
</blockquote>
</li>
</ol>
<h4 id="3-user-data"><a href="#3-user-data" class="headerlink" title="3. user data"></a>3. user data</h4><p>顾名思义就是用来存放用户数据的。<br>使用malloc函数分配到的内存的返回值指针是<strong>指向userdata（用户数据区）</strong><br>例如在 64 位程序中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><br>申请到的堆块总大小为<code>16 + 8 + 8 + 1 = 0x21(byte)</code></p>
<ol>
<li>第一个16字节是系统最小分配的内存，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</li>
</ol>
<ul>
<li>在64位系统中这个值是16个字节，在32位系统中是8个字节</li>
<li>例如，如果代码中是malloc(0)的话，堆管理器也会分配最小内存空间给你</li>
</ul>
<ol>
<li>第二个8字节是pre size字段的大小(32位的为4字节)</li>
<li>第三个8字节为 size字段的大小（32位的为4字节)</li>
<li>最后一个1字节是<strong>PREV_INUSE的值，只有0或1两个值</strong></li>
</ol>
<blockquote>
<p>整理一下：<strong>堆的基本结构包括pre_size、size、userdata</strong><br><strong>size字段包括</strong>:头部(pre size+size)加上 user data 的大小<br>malloc出最小大小为：系统最小分配内存+pre_size字段+size字段+prev_inuse(此处存疑）</p>
</blockquote>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><h4 id="使用中（分配后）"><a href="#使用中（分配后）" class="headerlink" title="使用中（分配后）"></a>使用中（分配后）</h4><p>如图</p>
<p><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226142821.png" alt="Pasted image 20250226142821"></p>
<h4 id="空闲中（释放后）"><a href="#空闲中（释放后）" class="headerlink" title="空闲中（释放后）"></a>空闲中（释放后）</h4><p>如图</p>
<ol>
<li>空闲中的chunk不存在M状态，只有A|P状态</li>
<li><strong>user data头部</strong>被分配出两个成员，fd和bk<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226153753.png" alt="Pasted image 20250226153753"><br><code>fd</code>，<code>bk</code>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</li>
</ol>
<ul>
<li><code>fd</code> 指向前一个（非物理相邻）空闲的 chunk 的起始地址，32位占4字节，64位占8字节</li>
<li><code>bk</code> 指向后一个（非物理相邻）空闲的 chunk 的起始地址，32位占4字节，64位占8字节</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
<blockquote>
<p>事实上，释放后的<strong>large block</strong>中还存在另外两个成员：<strong>fd_nextsize</strong>和<strong>bk_nextsize</strong></p>
</blockquote>
<p><code>fd_nextsize</code>， <code>bk_nextsize</code>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li><strong>fd_nextsize</strong> 指向前一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。</li>
<li><strong>bk_nextsize</strong> 指向后一个与当前 chunk 大小不同的第一个空闲块，<strong>不包含 bin 的头指针</strong>。  <blockquote>
<p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p>
</blockquote>
</li>
</ul>
<h3 id="堆块大小"><a href="#堆块大小" class="headerlink" title="堆块大小"></a>堆块大小</h3><ul>
<li><p>32位程序：</p>
<ol>
<li>用户分配到的最小堆块大小为<code>17B</code>：<strong>prev_size(4B) + size(4B) + fd(4B) + bk(4B) + next_chunk-&gt;p(1B)</strong></li>
<li>若用户申请的大小超过最小堆块大小，会与<strong>8B</strong>进行对齐</li>
</ol>
</li>
<li><p>64位程序：</p>
<ol>
<li>用户分配到的最小堆块大小为<code>33B</code>：<strong>prev_size(8B) + size(8B) + fd(8B) + bk(8B) + next_chunk-&gt;p(1B)</strong></li>
<li>若用户申请的大小超过最小堆块大小，会与<strong>16B</strong>进行对齐<h3 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h3><strong>描述</strong>：<strong>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 无效</strong>。所以下一个 chunk 的 prev_size 也可以被当前 chunk 使用，这就是 chunk 的空间复用</li>
</ol>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |<span class="params">             Size of previous chunk, <span class="keyword">if</span> unallocated (P clear)  </span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |<span class="params">             Size of chunk, <span class="keyword">in</span> bytes                     </span>|A|<span class="params">M</span>|P|<span class="params"></span></span><br><span class="line"><span class="params">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             <span class="title class_">User</span> data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line"><span class="keyword">next</span>    .                                                               |<span class="params"></span></span><br><span class="line"><span class="params">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             (size of chunk, but used <span class="keyword">for</span> application data)    |<span class="params"></span></span><br><span class="line"><span class="params">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="params">        </span>|             <span class="title class_">Size</span> of <span class="keyword">next</span> chunk, <span class="keyword">in</span> bytes                |<span class="params">A</span>|<span class="number">0</span>|<span class="params">1</span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h2 id="二、指针与地址"><a href="#二、指针与地址" class="headerlink" title="二、指针与地址"></a>二、指针与地址</h2><p>首先要明确用户在调用 malloc 函数时返回的值为<strong>一个指针，指向分配到堆空间（<em>用户数据区</em>）</strong>，这个在最前面的那个图片也已经标出来了。<br>有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个图中的例子：<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226190505.png" alt="Pasted image 20250226190505"><br>first chunk（second chunk）表示第一和第二个结构，<strong>每个结构中都有一个 point_heap 指针来指向存储用户数据的堆块（chunk)。</strong><br><strong>左边的这个本身就是一个堆块，用来存放一些全局信息</strong>。比如 max_size 存储了能够存储的最大结构数量；exist_num 表示已经存储的结构的数量。</p>
<h3 id="IDA中常见的指针表示形式"><a href="#IDA中常见的指针表示形式" class="headerlink" title="IDA中常见的指针表示形式"></a>IDA中常见的指针表示形式</h3><p>在 IDA 伪代码中的指针形式形如下面的情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(qword_6020A8 + <span class="number">8</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值</strong></p>
<p>汇编代码等同于：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400F</span>85                 mov     rax, cs:qword_6020A8</span><br><span class="line">.text:<span class="number">0000000000400F</span>8C                 mov     rax, [rax+<span class="number">8</span>]</span><br></pre></td></tr></table></figure><br>简单转化一下，也就是：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(addr) = [addr]</span><br></pre></td></tr></table></figure></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192122.png" alt="Pasted image 20250226192122"><br>代码提供了最基本的增删查改的功能。这个”笔记”的数据结构<strong>通常就是使用链表连接起来的</strong>，记录了当前 note 的大小、属性、内容等等。<br><strong>例如，下面这个例子就是以指针为基础来存储这个 note 结构的</strong>。这里的 i 代表 note 的索引，若这里的 i = 0 时：<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192345.png" alt="Pasted image 20250226192345"><br><code>*(qword_6020A8 + 16)</code> 就代表从 <code>qword_6020A8</code> 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址)<br>同样的<code>*(qword_6020A8 + 24)</code> 就代表偏移 24 个字节处的值为 len<br>依次类推就可以在<strong>不连续的内存空间中</strong>，把整个 note 的数据结构存储下来了。</p>
<h2 id="三、申请堆块的本质"><a href="#三、申请堆块的本质" class="headerlink" title="三、申请堆块的本质"></a>三、申请堆块的本质</h2><blockquote>
<p>堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
</blockquote>
<p>ptmalloc2 的作用通俗的讲就是<strong>相当于一个”中间商”</strong>，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。</p>
<p>简单点说就是下面这个图中的情况：<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226192641.png" alt="Pasted image 20250226192641"></p>
<h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">	<span class="type">char</span> *p; </span><br><span class="line">	p = <span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>在 gdb 中进行调试，在 call malloc 处下一个断点，<strong>在这里使用 vmmap 命令，查看内存分布</strong>。可以看到此时并没有发现堆段<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193759.png" alt="Pasted image 20250226193759"><br>单步 n ，vmmap 命令再次查看内存，发现出现了堆段<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193830.png" alt="Pasted image 20250226193830">**<br>只申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00602000     ~    0x00623000</span><br></pre></td></tr></table></figure>
<p>计算一下，刚好是 132 kB<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0x00623000-0x00602000)/1024 = 132 kB</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena</strong></p>
</blockquote>
<p>也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，<strong>以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了</strong>，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货</p>
<h3 id="查看已分配的堆内存分布"><a href="#查看已分配的堆内存分布" class="headerlink" title="查看已分配的堆内存分布"></a>查看已分配的堆内存分布</h3><p>在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226193941.png" alt="Pasted image 20250226193941"><br>我们这里使用下面这个命令来查看内存堆块情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/32gx 0x602010-0x10</span><br></pre></td></tr></table></figure>
<ul>
<li>32位的程序使用 x/32xw 比较直观一点<br>这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194002.png" alt="Pasted image 20250226194002"><h2 id="四、main-arena与top-chunk"><a href="#四、main-arena与top-chunk" class="headerlink" title="四、main_arena与top chunk"></a>四、main_arena与top chunk</h2><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3>这个 main_arena 其实就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是相当于上面所说的”批发”到的一堆货物<blockquote>
<p>因为是主线程分配的，所以叫做main arena，通过增加 program break location 的方式来增加 main arena 的大小。</p>
</blockquote>
</li>
</ul>
<p>在 gdb 调试中，使用<br>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/32gx &amp;main_arena</span><br></pre></td></tr></table></figure><br>可以看到 main_arena 的内存分配情况。</p>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>顾名思义，是堆中第一个堆块。相当于一个”带头大哥”，程序以后分配到的内存到要放在他的后面。</p>
<blockquote>
<p>在系统当前的所有 free chunk(无论那种 bin)，都无法满足用户请求的内存大小的时候，将此 chunk 当做一个应急消防员，分配给用户使用。</p>
</blockquote>
<p>简单点说，也就是在程序在向堆管理器申请内存时，<strong>没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</strong></p>
<h2 id="五、free函数和bins"><a href="#五、free函数和bins" class="headerlink" title="五、free函数和bins"></a>五、free函数和bins</h2><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free 函数的使用是和 bins 的分配息息相关的。用一个简单的例子来理解一下 free 函数的实现原理。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,<span class="string">&quot;Hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>程序将 “Hello” 字符串复制到申请到的堆内存空间中。<br>编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194730.png" alt="Pasted image 20250226194730"><br>继续使用 x/32gx 0x602010-0x10 命令查看堆块情况<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194742.png" alt="Pasted image 20250226194742"><br>继续单步 n，执行 free 函数之后，查看堆块情况<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226194753.png" alt="Pasted image 20250226194753"><br>这里可以看出原本堆块中存储的内容已经被清空，然后<strong>查看一下 main_arena 的值，发现其中 +0x8 的偏移处</strong>，存储了指向已经 free 了的指针（指向头部，而不是 user data)</li>
</ul>
<p>所以调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bins 这个概念是与内存回收相关的，也就是堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>。bins 直接翻译过来就是”垃圾桶”的意思，所以在系统在决定使用哪个 bins 时可以看作为”垃圾的分类”。<br>主要的 bins 分为以下几类，这里重点讲解一下 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。<br>描述：</p>
<ol>
<li>用户free掉的内存并不是都会马上归还给系统，ptmalloc会统一管理heap和mmap映射区域中的空闲的chunk</li>
<li>当用户进行下一次分配请求时，ptmalloc会首先试图在空闲的chunk中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销</li>
<li><strong>ptmalloc将相似大小的chunk用双向链表链接起来，这样的一个链表被称为一个bin</strong></li>
<li>ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin</li>
<li>堆管理器根据特点，将堆分为四种：<strong>fastbin | unsortedbin | smallbin | largebin</strong></li>
<li>数组中<strong>bin 1为unsorted bin；bin 2到63为small bin；bin 64到126为large bin</strong><br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226201008.png" alt="Pasted image 20250226201008"><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4>顾名思义，就是为了快速重新分配回内存而存在的一个结构。<blockquote>
<p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，<strong>会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回</strong>。</p>
</blockquote>
</li>
</ol>
<p><strong>描述：</strong></p>
<ol>
<li>在32位操作系统中，当用户释放的堆块大小小于64B时使用fastbin进行管理，即chunk空间最大为80字节</li>
<li>fastbin只使用了fd成员，是个单链表结构</li>
<li>fastbin不会对P位进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对fastbin进行合并</li>
<li>fastbinY为管理fastbin的数组，每个成员分别管理不同大小的fastbin链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其fd指针指向前一个结点</li>
<li>当用户申请chunk大小小于或等于MAX_FAST_SIZE时，优先从fastbins中查找相应的空闲块，且规则为LIFO（Last in, first out, 后进先出）<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204112.png" alt="Pasted image 20250226204112"><br>👇这里的横向排列的就是 main_arene（fast bin）的内存地址<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204137.png" alt="Pasted image 20250226204137"><br>假如此时 0x0804a000 处的堆块（实际堆块中的 size 字段要减去 PREV_INUSE 字段值 1，)已经被 free 了，那么他就会被存储<strong>在表示 40 bytes 的 fast bin 的内存地址里</strong></li>
</ol>
<ul>
<li>注意：<strong>这里把指针和地址区别开。地址存储的是指针，64 位的指针占 8 个字节</strong>。<br><strong>假设我们现在还是以 64 位下的 malloc(10) 为例子。</strong><br>根据前面那个 free 函数的例子，查看 main_arena 地址中的指针值我们可以看出来，<strong>+0x8 偏移处才是指向 malloc(10) 的堆块的指针</strong>（这个堆块分配后的 user data 实际大小是 16 字节）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">x/2gx &amp;main_arena                           (16 bytes 的链表头)</span></span><br><span class="line">0x7ffff7dd3760 &lt;main_arena&gt;:    0x0000000000000000    0x0000000000602000</span><br></pre></td></tr></table></figure>
<p>所以这个 16 字节的堆块的指针会被插入属于他的这个链表队列中，也就是如下的情况<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204230.png" alt="Pasted image 20250226204230"><br>所以这也就<strong>印证了在 main_arena 中分别表示 16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes 的内存地址中分别存储着已经 free 的而且满足这个大小的 chunk的指针。</strong></p>
<h5 id="fast-bin的特性"><a href="#fast-bin的特性" class="headerlink" title="fast bin的特性"></a>fast bin的特性</h5><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。<br>如下图所示，此时就是一个单链表结构<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204508.png" alt="Pasted image 20250226204508"><br><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong><br>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc)，堆管理器就会直接使用 fast bin 里的堆块。<br><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。也就是恢复到了上面第一个图中的情况。</p>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。<br>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。<br><strong>描述：</strong></p>
<ol>
<li>在32位操作系统中，当用户释放的堆块大小<strong>大于64B，小于等于512B</strong>时使用small bin进行管理</li>
<li>small bin 为双向循环链表，且使用 <strong>FIFO</strong>(First in, first out, 先入先出)算法</li>
<li>当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中</li>
<li>相邻的free chunk将会被合并成一个更大的fee chunk，增加内存利用率<br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226204717.png" alt="Pasted image 20250226204717"><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><blockquote>
<ol>
<li>当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中</li>
<li>unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中</li>
<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</li>
</ol>
</blockquote>
</li>
</ol>
<ul>
<li>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</li>
<li>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</li>
</ul>
<h2 id="深入理解堆的概念"><a href="#深入理解堆的概念" class="headerlink" title="深入理解堆的概念"></a>深入理解堆的概念</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。<strong>堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长</strong>。我们一般称管理堆的那部分程序为堆管理器。<br><strong>堆管理器处于用户程序与内核中间</strong>，主要做以下工作：  </p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，<em>为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互</em>。  </li>
<li>管理用户所释放的内存。<em>一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求</em>。<br>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能引起内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了ptmalloc2。<br>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。<strong>ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</strong><br>需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</strong></li>
</ol>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍  </p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用  </li>
<li>介绍堆目前的多线程支持。  <h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3>在 glibc 的<a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.h</a>中，malloc 的说明如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理  </li>
<li>当 n=0 时，<strong>返回当前系统允许的堆的最小内存块</strong>。  </li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。  <h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.h</a> 中，free 的说明如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
可以看出，free 函数会释放由 p 所指向的内存块。<strong>这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</strong><br>此外，该函数也同样对异常情况进行了处理  </li>
<li><strong>当 p 为空指针时，函数不执行任何操作</strong>。  </li>
<li>当 p 已经被释放之后，<strong>再次释放会出现乱七八糟的效果</strong>，这其实就是 <code>double free</code>。  </li>
<li><strong>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间</strong>。  </li>
</ul>
<h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。<br>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/574026/1599128488052-ad18a93d-0e6f-4713-b517-c672eed6cd56.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_480%2Climit_0" alt></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a><br>brk 和 sbrk的作用：malloc的底层实现，用于分配开辟内存，但是brk是系统调用 而sbrk不是  ，sbrk调用了brk<br>(program break location, the program break is the address of the first location beyond the current end of the data region <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sbrk\">https://en.wikipedia.org/wiki/Sbrk)的大小来向操作系统申请内存</a>%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%9D%A5%E5%90%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98)。  </p>
<blockquote>
<p>关于program break ：程序间断点</p>
</blockquote>
<p><strong>初始时，堆的起始地址 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址</strong>。根据是否开启ASLR，两者的具体位置会有所不同  </p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。  </li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。<br>具体效果如下图所示<br><img src="/img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/574026/1599129188134-82bd81ed-579a-4c91-9d4f-5b95d0eb6fb4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_819%2Climit_0" alt><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><strong>malloc会使用mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以o填充的内存，并且这块内存仅被调用进程所使用。</strong><br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213113.png" alt="Pasted image 20250226213113"></li>
</ul>
<h4 id="在执行mmap之前"><a href="#在执行mmap之前" class="headerlink" title="在执行mmap之前"></a>在执行mmap之前</h4><p><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213125.png" alt="Pasted image 20250226213125"></p>
<h4 id="mmap后"><a href="#mmap后" class="headerlink" title="mmap后"></a>mmap后</h4><p><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213144.png" alt="Pasted image 20250226213144"></p>
<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><p><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213155.png" alt="Pasted image 20250226213155"></p>
<h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213304.png" alt="Pasted image 20250226213304"><br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213327.png" alt="Pasted image 20250226213327"><br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213356.png" alt="Pasted image 20250226213356"><br><img src="/img/loading.gif" data-original="/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/Pasted image 20250226213413.png" alt="Pasted image 20250226213413"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io">Zechariah</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io/2025/02/26/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/">https://zechariah-0703.github.io/2025/02/26/堆相关整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zechariah-0703.github.io" target="_blank">Zechariahの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a></div><div class="post-share"><div class="social-share" data-image="/img/fengmian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/03/PWN%E6%8A%80%E5%B7%A7-mprotect%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9D%83%E9%99%90/" title="PWN技巧-mprotect修改内存保护权限"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">PWN技巧-mprotect修改内存保护权限</div></div><div class="info-2"><div class="info-item-1">mprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);  prot 的取值如下，通过 | 可以将几个属性结合使用（值相加）： PROT_READ：可写，值为 1 PROT_WRITE：可读， 值为 2 PROT_EXEC：可执行，值为 4 PROT_NONE：不允许访问，值为 0    需要注意的是，指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。 如果执行成功，函数返回 0；如果执行失败，函数返回 -1，并且通过 errno 变量表示具体原因。错误的原因主要有以下几个：  EACCES：该内存不能设置为相应权限。这是可能发生的，比如 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 修改为 PROT_WRITE。 EINVAL：...</div></div></div></a><a class="pagination-related" href="/2025/02/26/PWN%E6%8A%80%E5%B7%A7-%E7%BB%95%E8%BF%87Canary%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%BE%85%E5%A1%AB%E5%9D%91%EF%BC%89/" title="PWN技巧-绕过Canary的几种姿势"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PWN技巧-绕过Canary的几种姿势</div></div><div class="info-2"><div class="info-item-1">1. 格式化字符串漏洞获取Canarypl1=&#x27;a&#x27;*0x49p.sendafter(&#x27;overflow?\n&#x27;,pl1)data=p.recv()canary=b&#x27;\x00&#x27;+data[0x49:0x49+7]canary = int.from_bytes(canary,&#x27;little&#x27;)success(&#x27;canary:&#x27;)success(hex(canary)) 2. 覆盖截断字符获取Canary3. 逐字节爆破Canary 适用于有通过fork()函数创建的子进程的程序 爆破原理 对于Canary，虽然每次进程重启后Canary不同，但是同一个进程中的不同线程的Cannary是相同的，并且通过fork函数创建的子进程中的canary也是相同的，因为fork函数会直接拷贝父进程的内存。 最低位为0x00，之后逐次爆破，如果canary爆破不成功，则程序崩溃；爆破成功则程序进行下面的逻辑。由此可判断爆破是否成功。 我们可以利用这样的特点，彻底逐个字节将Canary爆破出来。通用模...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/10/UAF-use-after-free/" title="UAF(use_after_free)"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="info-item-2">UAF(use_after_free)</div></div><div class="info-2"><div class="info-item-1">原理我们将Use After Free翻译过来就是释放后使用：当一个指针所指向的指针块被释放掉之后可以再次被使用，但是这是由要求的，不妨将所有的情况列举出来：  chunk被释放之后，其对应的指针被设置为NULL，如果再次使用它，程序就会崩溃。 chunk被释放之后，其对应的指针未被设置为NULL，如果在下一次使用之前没有代码对这块内存进行修改，那么再次使用这个指针时程序很有可能正常运转。 内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。在堆中Use After Free一般指的是后两种漏洞，我们一般称被释放后没有被设置为NULL的内存指针为dangling pointer(悬空指针、悬垂指针)。 未被初始化过的内存指针称为野指针    例题 delete函数未将指针置空，存在UAF漏洞  因为free chunk之后没有将ptr = null   释放两个chunk后, tcache中会有两个0x10大小的chunk, 再申请8字节的chunk, 会返回两个chunk...</div></div></div></a><a class="pagination-related" href="/2025/03/11/unlink/" title="unlink"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">unlink</div></div><div class="info-2"><div class="info-item-1">unlinkunlink是什么？Index of /gnu/glibc unlink其实是libc中定义的一个宏，定义如下： #define unlink(AV, P, BK, FD) &#123;                                                FD = P-&gt;fd;								          BK = P-&gt;bk;								          if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);      else &#123;								              FD-&gt;bk = BK;							              BK-&gt;fd = FD;							              if (!in_smallbin_range...</div></div></div></a><a class="pagination-related" href="/2025/04/12/fastbin-attack%E7%B3%BB%E5%88%97/" title="fastbin_attack系列"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-12</div><div class="info-item-2">fastbin_attack系列</div></div><div class="info-2"><div class="info-item-1">fastbin_attackIntroductionfastbin attack指所有基于fastbin机制的漏洞利用方法，利用前提：  存在堆溢出、uaf等能控制chunk内容的漏洞 漏洞发生于 fastbin类型的chunk中  细分可做到如下分类  Fastbin Double Free House of Spirit   Fastbin Double Free 和 House of Spirit 侧重“正常由用户创建的chunk”和“由攻击者伪造的chunk”，然后再次申请chunk进行攻击   Alloc to Stack Arbitary Alloc   Alloc to Stack 和 Arbitary Alloc 侧重利用堆溢出等方式修改chunk的fd指针，即直接申请指定位置的chunk进行攻击  Principleif a chunk is freed and goes into fastbin the prev_inuse flag of the next heap will not be cleared   PREV_INUSE(abbreviated a...</div></div></div></a><a class="pagination-related" href="/2025/03/10/%E5%A0%86%E5%85%A5%E9%97%A8-malloc-hook%E5%92%8C-free-hook%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/" title="堆入门-__malloc_hook和__free_hook劫持原理"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="info-item-2">堆入门-__malloc_hook和__free_hook劫持原理</div></div><div class="info-2"><div class="info-item-1">malloc_hook和free_hook劫持原理_freehook-CSDN博客 打堆的一个关键的方法就是劫持堆相关函数中的 hook 函数。即在堆中的三大 hook 函数，malloc_hook、realloc_hook、free_hook Hook介绍 hook 的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。 hook 翻译过来是钩子。假设 a 函数中有这样一个执行过程：判断b函数指针是否为空，如果不为空就先b函数指针所指向的函数。这样当我们使用 b 钩子的时候，我们在执行 a 函数，执行流就会被 b 钩子给钩过来，这样就达到了执行 b 函数指针所指向的函数地址。   为了方便调试程序，在 glibc 中有四个比较重要的函数指针，分别是 malloc_hook、free_hook、realloc_hook、exit_hook。 我们可以通过一些堆漏洞或者其他漏洞就可以将原本指向 NULL 的这些函数指针，修改为 one_gadget，这样我们在满足一定的条件后就可以 getshell，这样就是 pwn 中的劫持 hook 函数最常见的用法。  malloc...</div></div></div></a><a class="pagination-related" href="/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/" title="AWD学习"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="info-item-2">AWD学习</div></div><div class="info-2"><div class="info-item-1">AWD流程 改init_hosts.py中的ip格式和port 改submit_flag.py中的提交方式和token 改round_wait_time patch 写exp 批量攻击  扫描IPimport requestsimport threading li = lambda x : print(&#x27;\x1b[01;38;5;214m&#x27; + x + &#x27;\x1b[0m&#x27;)ll = lambda x : print(&#x27;\x1b[01;38;5;1m&#x27; + x + &#x27;\x1b[0m&#x27;) def check_ip(i):    try:        url = f&#x27;http://192-168-1-&#123;i&#125;.awd.bugku.cn/&#x27; #*        response = requests.get(url, timeout=0.5)        if response.status_code == 200:            li(&#x27;[+] &...</div></div></div></a><a class="pagination-related" href="/2025/02/22/Art-of-shellcode/" title="Art_of_shellcode"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-22</div><div class="info-item-2">Art_of_shellcode</div></div><div class="info-2"><div class="info-item-1">很有用的网址https://www.exploit-db.com/shellcodes https://v3rdant.cn/Pwn.The-Art-of-Shellcode/ PWN:手动编写 x64 基于syscall 的 shell code(TODO)_x64 syscall pwn-CSDN博客 </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zechariah</div><div class="author-info-description">⭐晚安の魔法🪄-🎠睦缇丝🎡</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zechariah-0703"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">晚安，网友</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-%E5%A0%86%EF%BC%9F"><span class="toc-text">What is 堆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">一、堆的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">堆的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-chunk%E7%BB%93%E6%9E%84"><span class="toc-text">malloc_chunk结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-pre-size%E5%AD%97%E6%AE%B5"><span class="toc-text">1. pre size字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-size-%E5%AD%97%E6%AE%B5"><span class="toc-text">2. size 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-user-data"><span class="toc-text">3. user data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">结构图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%EF%BC%88%E5%88%86%E9%85%8D%E5%90%8E%EF%BC%89"><span class="toc-text">使用中（分配后）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%B8%AD%EF%BC%88%E9%87%8A%E6%94%BE%E5%90%8E%EF%BC%89"><span class="toc-text">空闲中（释放后）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="toc-text">堆块大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A8"><span class="toc-text">空间复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80"><span class="toc-text">二、指针与地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDA%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-text">IDA中常见的指针表示形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%B3%E8%AF%B7%E5%A0%86%E5%9D%97%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">三、申请堆块的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BE%8B"><span class="toc-text">简例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-text">查看已分配的堆内存分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81main-arena%E4%B8%8Etop-chunk"><span class="toc-text">四、main_arena与top chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main-arena"><span class="toc-text">main_arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-chunk"><span class="toc-text">top chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81free%E5%87%BD%E6%95%B0%E5%92%8Cbins"><span class="toc-text">五、free函数和bins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-text">free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin"><span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fast-bin"><span class="toc-text">fast bin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fast-bin%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">fast bin的特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin"><span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin"><span class="toc-text">unsorted bin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">深入理解堆的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">堆的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-1"><span class="toc-text">free</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">内存分配背后的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s-brk"><span class="toc-text">(s)brk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap"><span class="toc-text">mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%89%A7%E8%A1%8Cmmap%E4%B9%8B%E5%89%8D"><span class="toc-text">在执行mmap之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%90%8E"><span class="toc-text">mmap后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#munmap"><span class="toc-text">munmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-text">多线程支持</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/yi-dong-Binary/" title="江苏移动“赋能建功”-二进制相关"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="江苏移动“赋能建功”-二进制相关"/></a><div class="content"><a class="title" href="/2025/09/17/yi-dong-Binary/" title="江苏移动“赋能建功”-二进制相关">江苏移动“赋能建功”-二进制相关</a><time datetime="2025-09-17T10:01:08.000Z" title="发表于 2025-09-17 18:01:08">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/13/Cobalt-Strike/" title="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密"/></a><div class="content"><a class="title" href="/2025/09/13/Cobalt-Strike/" title="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密">Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密</a><time datetime="2025-09-13T05:47:00.000Z" title="发表于 2025-09-13 13:47:00">2025-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/ret2all/" title="「ret2all」有关栈的一切"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「ret2all」有关栈的一切"/></a><div class="content"><a class="title" href="/2025/08/30/ret2all/" title="「ret2all」有关栈的一切">「ret2all」有关栈的一切</a><time datetime="2025-08-30T10:58:13.000Z" title="发表于 2025-08-30 18:58:13">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/28/JSDSC-final-RE/" title="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP"/></a><div class="content"><a class="title" href="/2025/08/28/JSDSC-final-RE/" title="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP">江苏省数据安全技术应用职业技能竞赛决赛_逆向WP</a><time datetime="2025-08-28T03:33:59.000Z" title="发表于 2025-08-28 11:33:59">2025-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/Key_Points_for_Computer_Network_Exam/" title="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）"><img src="/img/loading.gif" data-original="/img/fengmian2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）"/></a><div class="content"><a class="title" href="/2025/06/17/Key_Points_for_Computer_Network_Exam/" title="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）">《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）</a><time datetime="2025-06-16T16:33:09.000Z" title="发表于 2025-06-17 00:33:09">2025-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Zechariah</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>